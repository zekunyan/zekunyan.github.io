<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[土土哥的技术Blog]]></title>
  <subtitle><![CDATA[iOS,Android程序猿一枚,喜欢Mac、Linux、各种开源技术，各种语言]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://tutuge.me/"/>
  <updated>2015-03-29T13:29:29.000Z</updated>
  <id>http://tutuge.me/</id>
  
  <author>
    <name><![CDATA[燕泽堃]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[为GCD队列绑定NSObject类型上下文数据-利用__bridge_retained(transfer)转移内存管理权]]></title>
    <link href="http://tutuge.me/2015/03/29/bind-data-to-gcd-queue/"/>
    <id>http://tutuge.me/2015/03/29/bind-data-to-gcd-queue/</id>
    <published>2015-03-29T11:27:40.000Z</published>
    <updated>2015-03-29T13:29:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>看过GCD（Grand Central Dispatch）的Apple<a href="https://developer.apple.com/library/prerelease/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html" target="_blank" rel="external">官方文档</a>的朋友一定见过“<strong>dispatch_set_context</strong>”和“<strong>dispatch_get_context</strong>”这两个函数，那么这两个函数该怎么用呢？  </p>
<p>我们都知道，GCD的接口参数都是“C语言类型“的，那么，我们如何将NSObject类型（Foundation框架）的数据，传入GCD的接口呢？（即：Core Foundation和Foundation对象的转换）</p>
<h2 id="本文关键字">本文关键字</h2><ul>
<li>GCD：dispatch_set_context，dispatch_get_context</li>
<li>__bridge，__bridge_retained，__bridge_transfer</li>
<li>Core Foundation, NSObject</li>
</ul>
<h2 id="dispatch_set(get)_context">dispatch_set(get)_context</h2><p>先看看这两个函数的原型：</p>
<pre><code><span class="comment">//设置context</span>
<span class="function"><span class="keyword">void</span> <span class="title">dispatch_set_context</span> <span class="params">( dispatch_object_t <span class="keyword">object</span>, <span class="keyword">void</span> *context )</span></span>;
<span class="comment">//获取context</span>
<span class="keyword">void</span> * dispatch_get_context ( dispatch_object_t <span class="keyword">object</span> );
</code></pre><p>这里的object一般指的就是通过dispatch_queue_create创建的队列。 </p>
<p>所以，这两个函数分别完成了将context“绑定”到特定GCD队列和从GCD队列获取对应context的任务。</p>
<h3 id="什么是context">什么是context</h3><p>在上述函数原型中，context是一个“<strong>void类型指针</strong>”，学过C语言的朋友应该都知道，void型指针可以指向任意类型，就是说，context在这里可以是任意类型的指针。</p>
<p>从这里可以得知，我们可以为队列“<strong>set</strong>”任意类型的数据，并在合适的时候取出来用。</p>
<h2 id="用malloc创建context并绑定到队列上">用malloc创建context并绑定到队列上</h2><p>参考<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW13" target="_blank" rel="external">Apple官方的例子</a>，我们先用传统的<strong>malloc</strong>创建context，看看如下简短例子：</p>
<pre><code><span class="comment">//定义context，即一个结构体</span>
typedef struct _Data {
    int number;
} <span class="built_in">Data</span>;

<span class="comment">//定义队列的finalizer函数，用于释放context内存</span>
<span class="literal">void</span> cleanStaff(<span class="literal">void</span> <span class="subst">*</span>context) {
    NSLog(@<span class="string">"In clean, context number: %d"</span>, ((<span class="built_in">Data</span> <span class="subst">*</span>)context)<span class="subst">-&gt;</span>number);
    <span class="comment">//释放，如果是new出来的对象，就要用delete</span>
    free(context);
}

<span class="subst">-</span> (<span class="literal">void</span>)testBody {
    <span class="comment">//创建队列</span>
    dispatch_queue_t <span class="built_in">queue</span> <span class="subst">=</span> dispatch_queue_create(<span class="string">"me.tutuge.test.gcd"</span>, DISPATCH_QUEUE_SERIAL);

    <span class="comment">//创建Data类型context数据并初始化</span>
    <span class="built_in">Data</span> <span class="subst">*</span>myData <span class="subst">=</span> malloc(sizeof(<span class="built_in">Data</span>));
    myData<span class="subst">-&gt;</span>number <span class="subst">=</span> <span class="number">10</span>;

    <span class="comment">//绑定context</span>
    dispatch_set_context(<span class="built_in">queue</span>, myData);

    <span class="comment">//设置finalizer函数，用于在队列执行完成后释放对应context内存</span>
    dispatch_set_finalizer_f(<span class="built_in">queue</span>, cleanStaff);

    dispatch_async(<span class="built_in">queue</span>, ^{
        <span class="comment">//获取队列的context数据</span>
        <span class="built_in">Data</span> <span class="subst">*</span><span class="built_in">data</span> <span class="subst">=</span> dispatch_get_context(<span class="built_in">queue</span>);
        <span class="comment">//打印</span>
        NSLog(@<span class="string">"1: context number: %d"</span>, <span class="built_in">data</span><span class="subst">-&gt;</span>number);
        <span class="comment">//修改context保存的数据</span>
        <span class="built_in">data</span><span class="subst">-&gt;</span>number <span class="subst">=</span> <span class="number">20</span>;
    });
}
</code></pre><p>上面的代码运行后如下：</p>
<pre><code>2015<span class="tag">-03-29</span> 20<span class="pseudo">:28</span><span class="pseudo">:16</span><span class="class">.854</span> <span class="tag">GCDTest</span><span class="attr_selector">[37787:1443423]</span> 1: <span class="tag">context</span> <span class="tag">number</span>: 10
2015<span class="tag">-03-29</span> 20<span class="pseudo">:28</span><span class="pseudo">:16</span><span class="class">.855</span> <span class="tag">GCDTest</span><span class="attr_selector">[37787:1443423]</span> <span class="tag">In</span> <span class="tag">clean</span>, <span class="tag">context</span> <span class="tag">number</span>: 20
</code></pre><p>看，通过为队列设置context，我们就能为队列绑定自定义的数据，然后在合适的时候取出来用。</p>
<h2 id="NSObject类型的context">NSObject类型的context</h2><p>在Mac、iOS的开发过程中，我们大部分用的都是Foundation框架下的类，就是如NSString、NSDictionary这些NSObject类型的类。<br>但是上面的<strong>dispatch_set(get)_context</strong>接受的context参数是C语言类型的，即Core Foundation类型的，我们如何转换呢？</p>
<p><strong>由于ARC不能管理Core Foundation Object的生命周期</strong>，所以我们必须先转换context的“类型”，以便转换内存管理权。</p>
<h3 id="__bridge">__bridge</h3><p>Apple已经为我们提供了用于转换的关键字，如下：</p>
<ul>
<li>__bridge: 只做了类型转换，不修改内存管理权；</li>
<li>__bridge_retained（即CFBridgingRetain）转换类型，同时将内存管理权从ARC中移除，后面需要使用CFRelease来释放对象；</li>
<li>__bridge_transfer（即CFBridgingRelease）将Core Foundation的对象转换为Objective-C的对象，同时将内存管理权交给ARC。</li>
</ul>
<h3 id="重新定义context">重新定义context</h3><p>为了方便下面的说明，我们先定义context类。</p>
<pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">Data</span> : <span class="title">NSObject</span></span>
<span class="keyword">@property</span>(<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">int</span> number;
<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">Data</span></span>

<span class="comment">//继承dealloc方法，便于观察对象何时被释放</span>
- (<span class="keyword">void</span>)dealloc {
    <span class="built_in">NSLog</span>(<span class="string">@"Data dealloc..."</span>);
}

<span class="keyword">@end</span>
</code></pre><p>看，我们继承了<strong>dealloc</strong>方法，这样就能知道Data类型对象什么时候被释放。</p>
<h3 id="需要注意的点">需要注意的点</h3><p><strong>__bridge</strong>的转换是没有转移内存管理权的，这点要特别注意。  </p>
<p>如果在传context对象时，用的是<strong>__bridge</strong>转换，那么context对象的内存管理权还在ARC手里，一旦当前作用域执行完，context就会被释放，而如果队列的任务用了context对象，就会造成“<strong>EXC_BAD_ACCESS</strong>”崩溃！</p>
<h3 id="正确的用法">正确的用法</h3><p>重写上面的例子，如下：</p>
<pre><code><span class="comment">//定义队列的finalizer函数，用于释放context内存</span>
<span class="function"><span class="keyword">void</span> <span class="title">cleanStaff</span><span class="params">(<span class="keyword">void</span> *context)</span> </span>{
    <span class="comment">//这里用__bridge转换，不改变内存管理权</span>
    Data *data = (__bridge Data *)(context);
    NSLog(@<span class="string">"In clean, context number: %d"</span>, data.number);

    <span class="comment">//释放context的内存！</span>
    CFRelease(context);
}

- (<span class="keyword">void</span>)testBody {
    <span class="comment">//创建队列</span>
    dispatch_queue_t <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"me.tutuge.test.gcd"</span>, DISPATCH_QUEUE_SERIAL);

    <span class="comment">//创建Data类型context数据并初始化</span>
    Data *myData = [Data <span class="keyword">new</span>];
    myData.number = <span class="number">10</span>;

    <span class="comment">//绑定context</span>
    <span class="comment">//这里用__bridge_retained转换，将context的内存管理权从ARC移除，交由我们自己手动释放！</span>
    dispatch_set_context(<span class="built_in">queue</span>, (__bridge_retained <span class="keyword">void</span> *)(myData));

    <span class="comment">//设置finalizer函数，用于在队列执行完成后释放对应context内存</span>
    dispatch_set_finalizer_f(<span class="built_in">queue</span>, cleanStaff);

    dispatch_async(<span class="built_in">queue</span>, ^{
        <span class="comment">//获取队列的context数据</span>
        <span class="comment">//这里用__bridge转换，不改变内存管理权</span>
        Data *data = (__bridge Data *)(dispatch_get_context(<span class="built_in">queue</span>));
        <span class="comment">//打印</span>
        NSLog(@<span class="string">"1: context number: %d"</span>, data.number);
        <span class="comment">//修改context保存的数据</span>
        data.number = <span class="number">20</span>;
    });
}
</code></pre><h4 id="解释">解释</h4><ul>
<li>在dispatch_set_context的时候用<strong>__bridge_retained</strong>转换，将context的内存管理权从ARC移除，交给我们自己管理。</li>
<li>在队列任务中，用dispatch_get_context获取context的时候，用<strong>__bridge</strong>转换，维持context的内存管理权不变，防止出了作用域context被释放。</li>
<li>最后用<strong>CFRelease</strong>释放context内存。</li>
</ul>
<h3 id="运行结果">运行结果</h3><pre><code>2015<span class="tag">-03-29</span> 21<span class="pseudo">:12</span><span class="pseudo">:41</span><span class="class">.631</span> <span class="tag">GCDTest</span><span class="attr_selector">[38131:1465900]</span> 1: <span class="tag">context</span> <span class="tag">number</span>: 10
2015<span class="tag">-03-29</span> 21<span class="pseudo">:12</span><span class="pseudo">:41</span><span class="class">.632</span> <span class="tag">GCDTest</span><span class="attr_selector">[38131:1465900]</span> <span class="tag">In</span> <span class="tag">clean</span>, <span class="tag">context</span> <span class="tag">number</span>: 20
2015<span class="tag">-03-29</span> 21<span class="pseudo">:12</span><span class="pseudo">:41</span><span class="class">.632</span> <span class="tag">GCDTest</span><span class="attr_selector">[38131:1465900]</span> <span class="tag">Data</span> <span class="tag">dealloc</span>...
</code></pre><p>由结果可知，我们的context对象在最后显式调用<strong>CFRelease</strong>才被释放。</p>
<h2 id="总结">总结</h2><p>总的来说，就是合理运用__bridge_retained(transfer)关键字转换对象的内存管理权，让我们自己控制对象的生命周期。</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/prerelease/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html" target="_blank" rel="external">Grand Central Dispatch (GCD) Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW13" target="_blank" rel="external">Concurrency Programming Guide</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html" target="_blank" rel="external">Toll-Free Bridged Types</a></li>
<li><a href="http://blog.csdn.net/diyagoanyhacker/article/details/7573801" target="_blank" rel="external">Core Foundation 框架</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>看过GCD（Grand Central Dispatch）的Apple<a href="https://developer.apple.com/library/prerelease/mac/documentation/Performan]]>
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5]]></title>
    <link href="http://tutuge.me/2015/03/21/effective-objective-c-5-enum/"/>
    <id>http://tutuge.me/2015/03/21/effective-objective-c-5-enum/</id>
    <published>2015-03-21T12:52:57.000Z</published>
    <updated>2015-03-21T08:14:11.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>Enum，也就是枚举，从C语言开始就有了，C++、Java、Objective-C、Swift这些语言，当然都有对应的枚举类型，功能可能有多有少，但是最核心的还是一个—-规范的定义代码中的状态、选项等“常量”。</p>
<h2 id="Item_5_-_Use_Enumerations_for_States,_Options,_and_Status_Codes">Item 5 - Use Enumerations for States, Options, and Status Codes</h2><p>本节的内容就是如何正确的使用枚举。</p>
<h2 id="状态与选项的区别（states_and_options）">状态与选项的区别（states and options）</h2><p>在用<strong>enum</strong>之前，我个人觉得，区分一下状态和选项的概念还是很必要的。</p>
<p><strong>状态</strong>，同时只能有一种，如“<strong>OK</strong>”，“<strong>Error</strong>”，不可能同时是OK和Error。<br><strong>选项</strong>，同时可以有一种或一种以上，如App可以<strong>同时</strong>支持横屏和竖屏，横屏竖屏在这个时候就是“屏幕方向”的两种不同的选项。</p>
<p>接下来，我们看看如何用枚举定义状态和选项。</p>
<h2 id="enum与状态（states）">enum与状态（states）</h2><h4 id="不好的做法">不好的做法</h4><p>经常看到这样的写法：</p>
<pre><code><span class="preprocessor">#<span class="keyword">define</span> STATE_OK 0</span>
<span class="preprocessor">#<span class="keyword">define</span> STATE_ERROR 1</span>
<span class="preprocessor">#<span class="keyword">define</span> STATE_UNKNOW 2</span>

<span class="comment">//直接用int型变量接收</span>
<span class="keyword">int</span> STATE = STATE_UNKNOW;
</code></pre><p>这样做有如下“不恰当”：</p>
<ul>
<li>宏定义没有类型约束，只是单纯的替换。</li>
<li>无法限制状态的所有情况，如，认为的将STATE赋值成3，程序可能就会出错，找不到匹配的状态，因为编译器不会对“<strong>STATE = 3;</strong>”提出警告。</li>
</ul>
<h4 id="正确的做法">正确的做法</h4><pre><code>typedef <span class="class"><span class="keyword">enum</span> _<span class="title">TTGState</span> </span>{
<span class="constant">    TTGStateOK</span>  = <span class="number">0</span>,
<span class="constant">    TTGStateError,
    TTGStateUnknow
} TTGState;

//指明枚举类型
TTGState state</span> = TTGStateOK;
</code></pre><p>用的时候就如下：</p>
<pre><code>- (void)dealWithState:(TTGState)state {
    <span class="keyword">switch</span> (state) {
        case TTGStateOK:
            //<span class="keyword">...</span>
            <span class="keyword">break</span>;
        case TTGStateError:
            //<span class="keyword">...</span>
            <span class="keyword">break</span>;
        case TTGStateUnknow:
            //<span class="keyword">...</span>
            <span class="keyword">break</span>;
    }
}
</code></pre><h2 id="enum与选项_(options)">enum与选项 (options)</h2><p>选项，就是说一个“选项变量”的类型要能够同时表示一个或多个组合的选择，如下例子：</p>
<pre><code><span class="comment">//方向，可同时支持一个或多个方向</span>
typedef <span class="class"><span class="keyword">enum</span> _<span class="title">TTGDirection</span> </span>{
<span class="constant">    TTGDirectionNone</span> = <span class="number">0</span>,
<span class="constant">    TTGDirectionTop</span> = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,
<span class="constant">    TTGDirectionLeft</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,
<span class="constant">    TTGDirectionRight</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,
<span class="constant">    TTGDirectionBottom</span> = <span class="number">1</span> &lt;&lt; <span class="number">3</span>
} TTGDirection;
</code></pre><p>看，这里的选项是用<strong>位运算</strong>的方式定义的，这样的好处就是，我们的选项变量可以如下表示：</p>
<pre><code><span class="comment">//用“或”运算同时赋值多个选项</span>
TTGDirection direction = TTGDirectionTop | TTGDirectionLeft | TTGDirectionBottom;

<span class="comment">//用“与”运算取出对应位</span>
<span class="keyword">if</span> (direction &amp; TTGDirectionTop) {
    <span class="built_in">NSLog</span>(<span class="string">@"top"</span>);
}
<span class="keyword">if</span> (direction &amp; TTGDirectionLeft) {
    <span class="built_in">NSLog</span>(<span class="string">@"left"</span>);
}
<span class="keyword">if</span> (direction &amp; TTGDirectionRight) {
    <span class="built_in">NSLog</span>(<span class="string">@"right"</span>);
}
<span class="keyword">if</span> (direction &amp; TTGDirectionBottom) {
    <span class="built_in">NSLog</span>(<span class="string">@"bottom"</span>);
}
</code></pre><p><strong>direction</strong>变量的实际内存如下：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_effective_objective_c_5_enum_2.jpg" alt="image"></p>
<p>这样，用位运算，就可以同时支持多个值。</p>
<h2 id="enum在Objective-C中的“升级版”">enum在Objective-C中的“升级版”</h2><p>一般来说，我们不能指定枚举变量的实际类型是什么，就是说，我们不知道枚举最后是int型，还是其他的什么类型。但是从C++ 11开始，我们可以为枚举指定其实际的存储类型，如下语法：</p>
<pre><code>enum TTGState : NSInteger {/*<span class="keyword">...</span>*/};
</code></pre><p>但是，我们在定义枚举的时候如何保证兼容性呢？Foundation框架已经为我们提供了更加“统一、便捷”的枚举定义方法，我们重新定义上面的例子：</p>
<pre><code><span class="comment">//NS_ENUM，定义状态等普通枚举</span>
typedef NS_ENUM(NSUInteger, TTGState) {
<span class="constant">    TTGStateOK</span> = <span class="number">0</span>,
<span class="constant">    TTGStateError,
    TTGStateUnknow
};

//NS_OPTIONS，定义选项
typedef NS_OPTIONS(NSUInteger, TTGDirection) {
    TTGDirectionNone</span> = <span class="number">0</span>,
<span class="constant">    TTGDirectionTop</span> = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,
<span class="constant">    TTGDirectionLeft</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,
<span class="constant">    TTGDirectionRight</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,
<span class="constant">    TTGDirectionBottom</span> = <span class="number">1</span> &lt;&lt; <span class="number">3</span>
};
</code></pre><p>所以，在开发Mac、iOS程序中，最好所有的枚举都用“<strong>NS_ENUM</strong>”和“<strong>NS_OPTIONS</strong>”定义，保证统一。</p>
<h2 id="总结">总结</h2><p>充分的用好枚举，可以增强代码的可读性，减少各种“错误”，让代码更加的规范。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>Enum，也就是枚举，从C语言开始就有了，C++、Java、Objective-C、Swift这些语言，当然都有对应的枚举类型，功能可能有多有少，但是最核心的还是一个—-规范的定义代码中的状态、选项等“常量”。</p>
<h2 id="]]>
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[@autoreleasepool-内存的分配与释放]]></title>
    <link href="http://tutuge.me/2015/03/17/what-is-autoreleasepool/"/>
    <id>http://tutuge.me/2015/03/17/what-is-autoreleasepool/</id>
    <published>2015-03-17T12:21:56.000Z</published>
    <updated>2015-03-17T15:41:20.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>开发过iOS、Mac的朋友应该对“<strong>@autoreleasepool</strong>”不陌生。只要在Xcode里创建一个工程，就能看到下面这样的代码：</p>
<pre><code><span class="comment">//iOS program</span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>{
    @autoreleasepool {
        <span class="keyword">return</span> UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate <span class="keyword">class</span>]));
    }
}

<span class="comment">//Command line program</span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>{
    @autoreleasepool {
        <span class="comment">//...</span>
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>看，每个<strong>main</strong>函数的主体都被<strong>@autoreleasepool</strong>的Block块包在里面，也就是说，接下来所有的对象创建都在这个block里面。</p>
<p>那么，<strong>@autoreleasepool</strong>的作用到底是什么呢？我们开发中可以用它来做什么呢？  </p>
<p>可以在某些情况下，大幅度降低程序的内存占用，如下图:</p>
<p><img src="https://camo.githubusercontent.com/2c1f07459d33c72de07d8a9305703b2ba40abfc4/687474703a2f2f7a6f72726f6368656e2e71696e6975646e2e636f6d2f626c6f675f776861745f69735f6175746f72656c65617365706f6f6c5f312e706e673f696d61676556696577322f302f682f343030" alt="image"></p>
<ul>
<li>测试的内容：500000次循环，每次循环创建一个NSNumber实例和两个NSString实例。</li>
<li>图：红线表示没有用<strong>@autoreleasepool</strong>时的内存占用。</li>
<li>图：绿线表示用了<strong>@autoreleasepool</strong>优化后的内存占用！</li>
</ul>
<p>效果是不是很明显！</p>
<p>代码Github地址：<a href="https://github.com/zekunyan/AutoReleasePoolTestExample" target="_blank" rel="external">AutoReleasePoolTestExample</a> Xcode 6, iOS 8, iPhone 5模拟器.</p>
<h2 id="MRC_与_ARC">MRC 与 ARC</h2><p>MRC（Mannul Reference Counting）和ARC(Automatic Reference Counting)，分别对应着手动引用计数和自动引用计数。  </p>
<p>对！是计数，不是“<strong>GC、垃圾回收</strong>”什么的，就是说，在Objective-C的开发中，ARC不代表像Java那样有GC做垃圾回收，所以本质上还是要“手动”管理内存的。也就是说，我们在ARC环境下写的代码，不用自己手动插入“<strong>retain、release这些消息</strong>”，ARC会在编译时为我们在合适的位置插入，释放不必要的内存。</p>
<p>而<strong>@autoreleasepool</strong>就跟对象的<strong>release</strong>密切相关。</p>
<h2 id="@autoreleasepool_干了啥">@autoreleasepool 干了啥</h2><p>在MRC时代，如果我们想先retain一个对象，但是并不知道在什么时候可以release它，我们可以像下面这么做：</p>
<pre><code><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];

<span class="built_in">NSString</span>* str = [[[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@"tutuge"</span>] autorelease];
<span class="comment">//use str...</span>

[pool release];
<span class="comment">//str is released</span>
</code></pre><p>就是说，我们可以在创建对象的时候给对象发送“<strong>autorelease</strong>”消息，然后当<strong>NSAutoreleasePool</strong>结束的时候，“标记过”autorelease的对象都会被“<strong>release</strong>”掉，也就是会被释放掉。</p>
<p>但是在ARC时代，我们不用手动发送<strong>autorelease</strong>消息，ARC会自动帮我们加。而这个时候，<strong>@autoreleasepool</strong>做的事情，跟<strong>NSAutoreleasePool</strong>就一模一样了。</p>
<h2 id="什么时候用@autoreleasepool">什么时候用@autoreleasepool</h2><p>根据<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html" target="_blank" rel="external">Apple的文档</a>，使用场景如下：</p>
<ul>
<li>写基于命令行的的程序时，就是没有UI框架，如AppKit等Cocoa框架时。</li>
<li>写循环，循环里面包含了大量临时创建的对象。（本文的例子）</li>
<li>创建了新的线程。（非Cocoa程序创建线程时才需要）</li>
<li>长时间在后台运行的任务。</li>
</ul>
<h2 id="利用@autoreleasepool优化循环">利用@autoreleasepool优化循环</h2><p>利用@autoreleasepool优化循环的内存占用，我觉得最有用的一点，下面就说说这个点。<br>如下面的循环，次数非常多，而且循环体里面的对象都是临时创建使用的，就可以用<strong>@autoreleasepool</strong>包起来，让每次循环结束时，可以及时的释放临时对象的内存。</p>
<pre><code><span class="comment">//来自Apple文档，见参考</span>
<span class="built_in">NSArray</span> *urls = &lt;<span class="preprocessor"># An array of file URLs #&gt;;</span>
<span class="keyword">for</span> (<span class="built_in">NSURL</span> *url <span class="keyword">in</span> urls) {

    <span class="keyword">@autoreleasepool</span> {
        <span class="built_in">NSError</span> *error;
        <span class="built_in">NSString</span> *fileContents = [<span class="built_in">NSString</span> stringWithContentsOfURL:url
                                         encoding:NSUTF8StringEncoding error:&amp;error];
        <span class="comment">/* Process the string, creating and autoreleasing more objects. */</span>
    }
}
</code></pre><p>这么做的效果是极其显著地，就如本文最开始的图一样，可以自己把示例工程下回来运行下试试~</p>
<h2 id="总结">总结</h2><p><strong>@autoreleasepool</strong>看起来很不“起眼”，平常开发很容易就忽略它了，但是仔细一看，确如此有用~</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html" target="_blank" rel="external">Using Autorelease Pool Blocks</a></li>
<li><a href="http://stackoverflow.com/questions/14677049/what-is-autoreleasepool-objective-c" target="_blank" rel="external">What is autoreleasepool? - Objective-C</a></li>
<li><a href="http://stackoverflow.com/questions/9086913/objective-c-why-is-autorelease-autoreleasepool-still-needed-with-arc" target="_blank" rel="external">Objective-C: Why is autorelease (@autoreleasepool) still needed with ARC?</a></li>
<li><a href="http://blog.zilongshanren.com/blog/2013/12/20/what-is-autorelease-pool/" target="_blank" rel="external">What-is-autorelease-pool?</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html" target="_blank" rel="external">NSAutoreleasePool</a></li>
</ul>
<h3 id="示例中的第三方库">示例中的第三方库</h3><p><a href="https://github.com/kevinzhow/PNChart" target="_blank" rel="external">PNChart</a></p>
<h3 id="运行中用代码获取App运行消耗内存">运行中用代码获取App运行消耗内存</h3><p><a href="http://stackoverflow.com/questions/787160/programmatically-retrieve-memory-usage-on-iphone" target="_blank" rel="external">Programmatically retrieve memory usage on iPhone</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>开发过iOS、Mac的朋友应该对“<strong>@autoreleasepool</strong>”不陌生。只要在Xcode里创建一个工程，就能看到下面这样的代码：</p>
<pre><code><span class="commen]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[有关宏定义的经验与技巧-简化代码-增强Log]]></title>
    <link href="http://tutuge.me/2015/03/15/%E6%9C%89%E5%85%B3%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E7%BB%8F%E9%AA%8C%E4%B8%8E%E6%8A%80%E5%B7%A7-%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81-%E5%A2%9E%E5%BC%BALog/"/>
    <id>http://tutuge.me/2015/03/15/有关宏定义的经验与技巧-简化代码-增强Log/</id>
    <published>2015-03-15T07:34:28.000Z</published>
    <updated>2015-03-16T02:45:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>宏定义、#define啥的，我们经常遇到。<br>一般来说，最常用的可能就是定义一些常量、简单的“函数”，如下：</p>
<pre><code>//定义常量<span class="constant">PI</span>
<span class="comment">#define PI 3.1415926</span>
<span class="comment">
//定义“函数”MIN</span>
<span class="comment">#define MIN(A,B) ((A) &lt; (B) ? (A) : (B))</span>
</code></pre><p>但是，这样定义常量、函数，有一定的风险。（见：<a href="http://tutuge.me/2015/03/11/Effective-Objective-C-读书笔记-Item-4-如何正确定义常量/" target="_blank" rel="external">Effective-Objective-C-读书笔记-Item-4-如何正确定义常量</a>, <a href="http://onevcat.com/2014/01/black-magic-in-macro/" target="_blank" rel="external">宏定义的黑魔法 - 宏菜鸟起飞手册</a>）</p>
<p>本文就列出几条我个人在iOS开发当中常用的经验与技巧。</p>
<h2 id="简化代码">简化代码</h2><p>在开发当中，我们可能会大量的写一些重复的，甚至具有“危险”的代码，用宏定义#define，往往可以简化代码，看看下面几个例子。</p>
<h3 id="GCD与#define">GCD与#define</h3><p><strong>dispatch_once</strong><br>项目中往往少不了各种单例类，我们一般会如下定义：</p>
<pre><code>+ (instancetype)sharedService {
    <span class="keyword">static</span> XXX *sharedService = <span class="literal">nil</span>;

    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;
    <span class="built_in">dispatch_once</span>, ^{
        sharedService = [XXX new];
    });

    <span class="keyword">return</span> sharedService;
}
</code></pre><p>这时候，就要注意几点：</p>
<ul>
<li>dispatch_once_t必须是<strong>static</strong>的，否则会各种报错=。=。</li>
<li><strong>dispatch_once</strong>的第一个参数必须取onceToken的地址，就是要“<strong>&amp;onceToken</strong>。”</li>
</ul>
<p>看，写个小小的单例都要这么注意，错了一点都很危险啊，而且总要重复写这几行。所以这个时候需要让宏定义帮忙：</p>
<pre><code><span class="comment">//定义宏定义</span>
<span class="preprocessor">#<span class="keyword">define</span> DISPATCH_ONCE_BLOCK(onceBlock) static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, onceBlock);</span>

+ (instancetype)sharedService {
    <span class="keyword">static</span> XXX *sharedService = nil;

    <span class="comment">//直接一行搞定</span>
    DISPATCH_ONCE_BLOCK(^{
        sharedService = [XXX <span class="keyword">new</span>];        
    })

    <span class="keyword">return</span> sharedService;
}
</code></pre><p>看，是不是变得更加简洁、“安全了”~</p>
<p><strong>dispatch_async</strong><br>除了dispatch_once，另一个常用的就是dispatch_async。不多说，直接看例子：</p>
<pre><code><span class="comment">//在Main线程上运行</span>
<span class="id">#define</span> <span class="tag">DISPATCH_ON_MAIN_THREAD</span>(mainQueueBlock) <span class="tag">dispatch_async</span>(<span class="function">dispatch_get_main_queue</span>(), <span class="tag">mainQueueBlock</span>);

<span class="comment">//在Global Queue上运行</span>
<span class="id">#define</span> <span class="tag">DISPATCH_ON_GLOBAL_QUEUE_HIGH</span>(globalQueueBlocl) <span class="tag">dispatch_async</span>(<span class="function">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), <span class="tag">globalQueueBlocl</span>);
<span class="id">#define</span> <span class="tag">DISPATCH_ON_GLOBAL_QUEUE_DEFAULT</span>(globalQueueBlocl) <span class="tag">dispatch_async</span>(<span class="function">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), <span class="tag">globalQueueBlocl</span>);
<span class="id">#define</span> <span class="tag">DISPATCH_ON_GLOBAL_QUEUE_LOW</span>(globalQueueBlocl) <span class="tag">dispatch_async</span>(<span class="function">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>), <span class="tag">globalQueueBlocl</span>);
<span class="id">#define</span> <span class="tag">DISPATCH_ON_GLOBAL_QUEUE_BACKGROUND</span>(globalQueueBlocl) <span class="tag">dispatch_async</span>(<span class="function">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>), <span class="tag">globalQueueBlocl</span>);

<span class="comment">//主线程上</span>
<span class="tag">DISPATCH_ON_MAIN_THREAD</span>(^{
    <span class="comment">//更新UI</span>
})

<span class="comment">//Global Queue </span>
<span class="tag">DISPATCH_ON_GLOBAL_QUEUE_DEFAULT</span>(^{
    <span class="comment">//异步耗时任务</span>
})
</code></pre><p>再也不用写一大堆”dispatch_async(dispatch_get_global_queue”了~看起来是不是很清爽~</p>
<h3 id="能一行搞定，干嘛还要写多行">能一行搞定，干嘛还要写多行</h3><p>很多时候，我们写的函数、方法都会在起始的地方加一些公共的判断，条件满足了才可以继续往下运行，如“用户是否登录”、“某个模块是否加载完成”等等，所以，我们可能会写如下样子的代码：</p>
<pre><code>- (<span class="keyword">void</span>)doSomething {
    <span class="keyword">if</span> (![[XXXAccountService sharedService] isLogin]) {
        <span class="keyword">return</span>;
    }
    <span class="comment">//do staff...</span>
}

- (<span class="keyword">void</span>)doSomething2 {
    <span class="keyword">if</span> (![[XXXAccountService sharedService] isLogin]) {
        <span class="keyword">return</span>;
    }
    <span class="comment">//do staff...</span>
}
</code></pre><p>每次都要这么写，是不是感觉很浪费时间？而且重复的好多=。=<br>所以，我们要用#define，把3行变成一行:</p>
<pre><code><span class="comment">//定义</span>
<span class="preprocessor">#<span class="keyword">define</span> CHECK_LOGIN_IN <span class="keyword">if</span> (![[XXXAccountService sharedService] isLogin]) {return;}</span>

- (<span class="keyword">void</span>)doSomething {
    CHECK_LOGIN_IN
    <span class="comment">//do staff...</span>
}

- (<span class="keyword">void</span>)doSomething2 {
    CHECK_LOGIN_IN
    <span class="comment">//do staff...</span>
}
</code></pre><p>其实#define的原理就是不管三七二十一，直接做替换，所以我们完全可以利用这个特点，发挥自己的想象，简化代码~</p>
<h2 id="宏定义与Log">宏定义与Log</h2><p>打Log，是个永恒的话题。  </p>
<h3 id="NSLog增强版">NSLog增强版</h3><p>我们会经常用到<strong>NSLog</strong>打Log，但是，这个函数能提供的信息非常少，所以，下面就是一个增强版, 最好定义在项目的pch文件中：</p>
<pre><code><span class="comment">#define NSLog(format, ...) \</span>
    <span class="keyword">do</span> { <span class="string">\</span>
        NSLog(@<span class="string">"&lt;%@ : %d : %s&gt;-: %@"</span>, <span class="string">\</span>
        [[NSString <span class="attribute">stringWithUTF8String</span>:__FILE__] lastPathComponent], <span class="string">\</span>
        __LINE__, <span class="string">\</span>
        __FUNCTION__, <span class="string">\</span>
        [NSString <span class="attribute">stringWithFormat</span>:format, <span class="comment">##__VA_ARGS__]); \</span>
    } <span class="keyword">while</span>(<span class="number">0</span>)
</code></pre><p>使用：    </p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>{
    <span class="annotation">@autoreleasepool</span> {
        NSLog(@<span class="string">"Blog: %@"</span>, @<span class="string">"http://tutuge.me"</span>);
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>输出：</p>
<pre><code>&lt;main.<span class="string">m :</span> <span class="number">22</span> : main&gt;-: <span class="string">Blog:</span> <span class="string">http:</span><span class="comment">//tutuge.me</span>
</code></pre><p>看，这下Log就带上了文件名、行号、函数名，一下子就清楚多了~<br>至于为什么要用这个奇怪的“do{…}while(0)”，其实就是为了防止在不同的使用场景中导致语法错误，详细请见：<a href="http://onevcat.com/2014/01/black-magic-in-macro/" target="_blank" rel="external">宏定义的黑魔法 - 宏菜鸟起飞手册</a></p>
<h3 id="为Log增加全局开关">为Log增加全局开关</h3><p>开发中，我们往往会在许多地方加上Log，但是在发布的时候，又不想显示这些Log，这个时候难道要一个一个的删除打Log的地方？<br>所以，为了增加开关，我们需要将上面的增强型NSLog改造一下：</p>
<pre><code>//判断是否要Log
<span class="comment">#ifdef NEED_DEBUG    </span>
<span class="comment">#define NSLog(format, ...) \</span>
    //Log定义<span class="keyword">...</span>
<span class="comment">#else</span>
    <span class="comment">#define NSLog(format, ...) do{ } while(0)</span>
<span class="comment">#endif</span>
</code></pre><p>所以，当我们需要Log的时候，在上面定义的之前加上下面这一行：</p>
<pre><code><span class="hexcolor">#def</span>ine NEED_DEBUG
</code></pre><p>就可以打开Log了。不加的话，就不会有Log~简单的条件编译~</p>
<h3 id="为Log增加等级">为Log增加等级</h3><p>开发过Android的应该都知道，Android里面可以很方便的用Log.i、Log.d输出不同“等级”的Log，调试更加方便，NSLog却不行。所以，还是要借助宏定义：</p>
<pre><code><span class="comment">//Debug等级Log, 在此之前定义自己的NSLog</span>
<span class="preprocessor">#ifdef LOG_LEVEL_DEBUG</span>
    <span class="preprocessor">#<span class="keyword">define</span> DLog(format, ...) NSLog(@"&lt;DEBUG&gt;: %@", [NSString stringWithFormat:format, ##__VA_ARGS__])</span>
<span class="preprocessor">#<span class="keyword">else</span></span>
    <span class="preprocessor">#<span class="keyword">define</span> DLog(format, ...) do{ } while(0)</span>
<span class="preprocessor">#<span class="keyword">endif</span></span>

<span class="comment">//Info等级Log</span>
<span class="preprocessor">#ifdef LOG_LEVEL_INFO</span>
    <span class="preprocessor">#<span class="keyword">define</span> ILog(format, ...) NSLog(@"&lt;Info&gt;: %@", [NSString stringWithFormat:format, ##__VA_ARGS__])</span>
<span class="preprocessor">#<span class="keyword">else</span></span>
    <span class="preprocessor">#<span class="keyword">define</span> ILog(format, ...) do{ } while(0)</span>
<span class="preprocessor">#<span class="keyword">endif</span></span>

<span class="comment">//Error等级Log</span>
<span class="preprocessor">#ifdef LOG_LEVEL_ERROR</span>
    <span class="preprocessor">#<span class="keyword">define</span> ELog(format, ...) NSLog(@"&lt;Error&gt;: %@", [NSString stringWithFormat:format, ##__VA_ARGS__])</span>
<span class="preprocessor">#<span class="keyword">else</span></span>
    <span class="preprocessor">#<span class="keyword">define</span> ELog(format, ...) do{ } while(0)</span>
<span class="preprocessor">#<span class="keyword">endif</span></span>
</code></pre><p>当我们在打Log的时候，就可以根据需要，用不同等级的Log，而且可以方便的定制需要输出哪几种，并且之前的“增强版”NSLog也可以使用。</p>
<p>完整的请看<a href="https://gist.github.com/zekunyan/2f2356136b9b40348584" target="_blank" rel="external">Gist</a>.</p>
<h2 id="其它">其它</h2><p>还有一些简单好用的宏定义，在这就只举几个典型的例子了~</p>
<h3 id="打印自定义类型信息">打印自定义类型信息</h3><p>假如有如下结构体定义(自定义类的话，直接重写description方法即可):</p>
<pre><code><span class="comment">//复数结构体</span>
typedef <span class="keyword">struct</span> Complex {
    float r; <span class="comment">//实部</span>
    float i; <span class="comment">//虚部</span>
} Complex;

<span class="comment">//定义打印Complex类型的宏</span>
<span class="comment">//输出：(1+2i), (1-2i)</span>
#define NSLogComplex(<span class="built_in">complex</span>) NSLog(@<span class="string">"Complex: (%g%s%gi)"</span>, <span class="built_in">complex</span>.r, (<span class="built_in">complex</span>.i &gt; <span class="number">0</span> ? <span class="string">"+"</span> : <span class="string">""</span>), <span class="built_in">complex</span>.i)
</code></pre><h3 id="常用函数简化、单例获取">常用函数简化、单例获取</h3><pre><code><span class="comment">//获取View的属性</span>
<span class="hexcolor">#def</span>ine <span class="function"><span class="title">GetViewWidth</span><span class="params">(view)</span></span>  view<span class="class">.frame</span><span class="class">.size</span><span class="class">.width</span>
<span class="hexcolor">#def</span>ine <span class="function"><span class="title">GetViewHeight</span><span class="params">(view)</span></span> view<span class="class">.frame</span><span class="class">.size</span><span class="class">.height</span>
<span class="hexcolor">#def</span>ine <span class="function"><span class="title">GetViewX</span><span class="params">(view)</span></span>      view<span class="class">.frame</span><span class="class">.origin</span><span class="class">.x</span>
<span class="hexcolor">#def</span>ine <span class="function"><span class="title">GetViewY</span><span class="params">(view)</span></span>      view<span class="class">.frame</span><span class="class">.origin</span><span class="class">.y</span>

<span class="comment">//屏幕常量</span>
<span class="hexcolor">#def</span>ine GetScreenWidth      [[UIScreen mainScreen] bounds]<span class="class">.size</span><span class="class">.width</span>
<span class="hexcolor">#def</span>ine GetScreenHeight     [[UIScreen mainScreen] bounds]<span class="class">.size</span><span class="class">.height</span>

<span class="comment">//获取图片资源</span>
<span class="hexcolor">#def</span>ine <span class="function"><span class="title">GetImage</span><span class="params">(imageName)</span></span> [UIImage imageNamed:[NSString stringWithFormat:@<span class="string">"%@"</span>,imageName]]

<span class="comment">//等等~只要你想得到~</span>
</code></pre><h2 id="总结">总结</h2><p>宏定义的各种Tip还远远不止这些，合理使用它，可以有效改善代码的阅读质量~</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://gcc.gnu.org/onlinedocs/cpp/index.html" target="_blank" rel="external">The C Preprocessor</a></li>
<li><a href="http://onevcat.com/2014/01/black-magic-in-macro/" target="_blank" rel="external">宏定义的黑魔法 - 宏菜鸟起飞手册</a></li>
</ul>
<p>I</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>宏定义、#define啥的，我们经常遇到。<br>一般来说，最常用的可能就是定义一些常量、简单的“函数”，如下：</p>
<pre><code>//定义常量<span class="constant">PI</span>
<span c]]>
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="技巧" scheme="http://tutuge.me/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Effective-Objective-C-读书笔记-Item-4-如何正确定义常量]]></title>
    <link href="http://tutuge.me/2015/03/11/Effective-Objective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Item-4-%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F/"/>
    <id>http://tutuge.me/2015/03/11/Effective-Objective-C-读书笔记-Item-4-如何正确定义常量/</id>
    <published>2015-03-10T16:07:23.000Z</published>
    <updated>2015-03-16T02:46:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>写博客果然比光看书要花时间=。=，书都快看完了，才写到第4节。但是总结一遍，的确印象深刻啊~~  </p>
<p>这次的主题是“<strong>常量</strong>”，非常常用，又非常重要的东西~良好的代码规范、设计，少不了各种<strong>常量</strong>。</p>
<h2 id="Item_4_-_Prefer_Typed_Constants_to_Preprocessor_#define">Item 4 - Prefer Typed Constants to Preprocessor #define</h2><p>本节着重对比了常量的定义形式，类型常量和#define的区别、各自的特点。最后得出，我们应该用带有类型的常量，而不是#define。</p>
<h2 id="一个简单的示例">一个简单的示例</h2><p>应用中，少不了各种动画，也就少不了设定动画的时间长度，一般来说，我们会设定短、中、长几种时间常量，用于不同的场合，了解C语言的童鞋估计对“<strong>#define</strong>”宏定义不陌生，于是，可能就会如下这么定义：</p>
<pre><code><span class="hexcolor">#def</span>ine ANIMATION_DURATION_SHORT <span class="number">0.3</span>
<span class="hexcolor">#def</span>ine ANIMATION_DURATION_MIDDLE <span class="number">0.6</span>
<span class="hexcolor">#def</span>ine ANIMATION_DURATION_LONG <span class="number">1.0</span>
</code></pre><p>于是，所有用到动画时长的地方，直接用这几个宏定义就行了。  </p>
<p>乍一看，似乎没什么问题。</p>
<h3 id="类型+不可变">类型+不可变</h3><p>先来看看宏定义干了什么。<br>总的来说，#define就是“替换”，在编译时，将一切宏定义替换成定义后面的内容。（参考<a href="http://baike.baidu.com/view/2076445.htm" target="_blank" rel="external">百度百科</a>）  </p>
<p>关键在于：</p>
<ul>
<li>宏定义不会检查替换的“<strong>类型</strong>”，只要遇到，就做替换。</li>
<li>宏定义不保证“<strong>不可变</strong>”，因为可以<strong>重复定义</strong>，不能保证值不变。(这个我觉得是最容易让人忽略的地方)</li>
</ul>
<p>所以，用宏定义定义常量，很“危险”。</p>
<h2 id="正确的做法">正确的做法</h2><p>恰当的常量，应该具备合适的常量名字、正确的类型，还有const、extern等关键字的修饰，当然，还要根据常量适用的“<strong>范围</strong>”，做出恰当的处理。一下举例说明。</p>
<h3 id="只在函数中用的常量">只在函数中用的常量</h3><p>只在函数中用的常量：</p>
<pre><code>- (void)runAnimation {
    //动画时间长度常量
    static const NSTimeInterval kAnimationDurationLong = <span class="number">1.</span>0f;

    //<span class="keyword">...</span>
}
</code></pre><p>static、const定义了它是静态不可变的；<strong>NSTimeInterval</strong>则“精确”指定了常量的类型。</p>
<h3 id="只在一个“-m”文件中使用的常量">只在一个“<strong>.m</strong>”文件中使用的常量</h3><p>在类的实现文件“xxx.m”文件中定义常量，也是很常见的。<br>你可能会觉得，既然是一个类使用的，那就放在类的头文件里面定义不就好了。<br><strong>但是这么想是错的=。=</strong><br><strong>因为所有要用到这个类的文件，都会无形当中包含了这些常量声明，将不必要的数据暴露在外面，这样是违反设计原则的，并且，如果常量名字取得不恰当，还有可能造成冲突。</strong></p>
<p>所以，应该如下:</p>
<pre><code>//XXX.m

//必须要static
static const NSTimeInterval kAnimationDurationLong = <span class="number">1.</span>0f;

@implementation XXX
//<span class="keyword">...</span>
@end 
</code></pre><p>需要注意的点：</p>
<ul>
<li>一定要放在.m文件中。</li>
<li>必须是<strong>static</strong>，表示此常量作用域只在此.m文件中。如果不加static的话，常量就会在全局作用域中声明，可能会导致跟其他的常量冲突。</li>
<li>const，当然。</li>
<li>NSTimeInterval，确定的类型。</li>
<li>kAnimationDurationLong，“<strong>k</strong>”开头的命名，也算是Apple的规范了吧，内部常量统一以“<strong>k</strong>”开头。</li>
</ul>
<h3 id="全局常量">全局常量</h3><p>一般来说，最常见的全局常量就是发广播Notification时用的Notification的名字，往往都是一些字符串，下面就以这个为例子：</p>
<p>假设我们的类叫“<strong>TTGClass</strong>”，我们的类会向外发送Notification，所以需要定义一个Notification的名字常量供外界注册，如下：</p>
<pre><code><span class="comment">//TTGClass.h</span>
<span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> TTGClassWorkBeginNotification;

<span class="comment">//TTGClass.m</span>
<span class="built_in">NSString</span> * <span class="keyword">const</span> TTGClassWorkBeginNotification = <span class="string">@"TTGClassWorkBeginNotification"</span>;
</code></pre><p>关键：</p>
<ul>
<li>头文件中只是做声明，不做定义。所以用extern表示常量在别处定义的，尽量隐藏细节。</li>
<li>同<strong>类名</strong>做常量名字的开头，<strong>这个非常关键，因为Objective-C里面没有像Java那样的“包”机制，所以必须靠命名来划分不同的类，常量当然也要遵循这个规则。</strong></li>
<li>NSString，确定的类型；const，表明常量；Notification后缀，表明用途。这些都是需要注意的。</li>
</ul>
<h2 id="总结">总结</h2><p>良好的代码，总是少不了定义各种常量，以避免“魔鬼数字、魔鬼字符串”。所以我们应该尽量避免少用#define定义常量，而是用带有类型的、const的常量，并且尽可能的缩小常量的作用域。  </p>
<p>暴露的细节越少，出错的机会也就越小（忘了从哪里看到的=。=）</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>写博客果然比光看书要花时间=。=，书都快看完了，才写到第4节。但是总结一遍，的确印象深刻啊~~  </p>
<p>这次的主题是“<strong>常量</strong>”，非常常用，又非常重要的东西~良好的代码规范、设计，少不了各种<st]]>
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="笔记" scheme="http://tutuge.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="翻译" scheme="http://tutuge.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UITextView编辑时插入自定义表情-简单的图文混编]]></title>
    <link href="http://tutuge.me/2015/03/07/UITextView%E7%BC%96%E8%BE%91%E6%97%B6%E6%8F%92%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E6%83%85-%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BE%E6%96%87%E6%B7%B7%E7%BC%96/"/>
    <id>http://tutuge.me/2015/03/07/UITextView编辑时插入自定义表情-简单的图文混编/</id>
    <published>2015-03-07T03:04:38.000Z</published>
    <updated>2015-03-07T18:10:08.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在iOS开发中，经常需要用UITextView作为编辑文本的输入控件。<br>但是如何在编辑时插入自定义表情呢？就是像发微博时那样？  </p>
<p>本文简单的用<strong>NSTextAttachment</strong>、<strong>NSAttributedString</strong>的特性，实现了</p>
<ul>
<li>在UITextView中编辑文字时插入自定义表情图片</li>
<li>同时可以返回带有表情“<strong>替换符</strong>”的纯文本字符串。</li>
</ul>
<h2 id="示例">示例</h2><p>本文代码工程地址：<a href="https://github.com/zekunyan/UITextViewDIYEmojiExample" target="_blank" rel="external">https://github.com/zekunyan/UITextViewDIYEmojiExample</a></p>
<p>效果图：</p>
<p><img src="http://zorrochen.qiniudn.com/inputEmoji_Sample.gif" alt="image"></p>
<h2 id="背景知识">背景知识</h2><ul>
<li>NSAttributedString及其子类，用于显示富文本。</li>
<li>NSTextAttachment，NSAttributedString的一种样式类，可以在文本中显示图片。</li>
<li>NSTextStorage，UITextView中的实际的文本封装。（见参考中的UITextView文档）</li>
</ul>
<h3 id="表情与其标志">表情与其标志</h3><p>首先需要明确的是，我们的自定义表情一定是有一一对应的“<strong>标志</strong>”的，如“<strong>[/emoji_haha]</strong>”。<br>就是说，为了方便处理，方便在数据库、网络传输中保存、传输带有表情图片的文本，我们必须要为每种表情取特定的“<strong>名字</strong>”，数据库中储存的、网络传输的文本就只包含这些标志名字就行，在显示的时候做对应的替换。</p>
<p>如：</p>
<p><strong>tutuge.me<img src="http://zorrochen.qiniudn.com/blog_uitextview_input_emoji_emoji_1.png" alt="image"></strong></p>
<p>对应的纯文本就是：</p>
<p><strong>tutuge.me[/emoji_1]</strong></p>
<h2 id="插入并显示表情图片">插入并显示表情图片</h2><p>插入表情很简单，直接实例化<strong>NSTextAttachment</strong>类，将需要的表情的UIImage实例赋值给NSTextAttachment的image属性，然后用“<strong>[NSAttributedString attributedStringWithAttachment:]</strong>”方法实例化一个NSAttributedString的对象，插入到UITextView的textStorage对应的位置即可。</p>
<p>如下：</p>
<pre><code>NSTextAttachment *emojiTextAttachment = [NSTextAttachment <span class="keyword">new</span>];

<span class="comment">//设置表情图片</span>
emojiTextAttachment.image = emojiImage;

<span class="comment">//插入表情</span>
[textView.textStorage <span class="string">insertAttributedString:</span>[NSAttributedString <span class="string">attributedStringWithAttachment:</span>emojiTextAttachment]
<span class="label">                                      atIndex:</span>textView.selectedRange.location];
</code></pre><p>这样，就能在UITextView当前光标位置插入表情图片了。</p>
<h2 id="获取带有表情标志的文本字符串">获取带有表情标志的文本字符串</h2><h3 id="难点">难点</h3><p>NSTextAttachment被插入到NSAttributedString中的时候，<strong>就被当成了一个字符处理！！！</strong>。<br>就是说，只从UITextView的text中，是找不回文本里面不同的表情所对应的标志的！  </p>
<h3 id="解决点">解决点</h3><ol>
<li>我们要能遍历出当前文本中所有的表情，也就是NSTextAttachment类。</li>
<li>我们要能知道遍历出的表情，对应的标志是什么。</li>
</ol>
<h3 id="遍历所有的NSTextAttachment类属性">遍历所有的NSTextAttachment类属性</h3><p>遍历，嗯，先看看Apple有没有提供相应的方法，能遍历NSAttributedString（及其子类）的属性的。查阅文档：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAttributedString_Class/index.html#//apple_ref/occ/instm/NSAttributedString" target="_blank" rel="external">NSAttributedString Class Reference</a>，可以找到这么一个方法：“<strong>- enumerateAttribute:inRange:options:usingBlock:</strong>”，其原型如下：</p>
<pre><code>- (<span class="keyword">void</span>)enumerateAttribute:(<span class="built_in">NSString</span> *)attrName
                   inRange:(<span class="built_in">NSRange</span>)enumerationRange
                   options:(NSAttributedStringEnumerationOptions)opts
                usingBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> value,
                                     <span class="built_in">NSRange</span> range,
                                     <span class="built_in">BOOL</span> *stop))block
</code></pre><p>用处：</p>
<pre><code>Executes <span class="operator">the</span> Block <span class="keyword">for</span> <span class="operator">the</span> specified attribute run <span class="operator">in</span> <span class="operator">the</span> specified range.
</code></pre><p>看，就是这个方法~就能遍历出NSTextAttachment对象了~</p>
<h3 id="创建NSTextAttachment的子类">创建NSTextAttachment的子类</h3><p>如何绑定NSTextAttachment所表示的表情和与其对应的标志？创建子类嘛~直接在子类中增加属性，保存标志不就行了。<br>如下：</p>
<pre><code><span class="variable">@interface</span> <span class="attribute">EmojiTextAttachment </span>: NSTextAttachment
<span class="variable">@property</span>(strong, nonatomic) NSString *emojiTag;
<span class="variable">@end</span>
</code></pre><p>所以，这个时候，插入表情的代码应该就是下面这样：</p>
<pre><code>EmojiTextAttachment *emojiTextAttachment = [EmojiTextAttachment <span class="keyword">new</span>];

<span class="comment">//保存表情标志</span>
emojiTextAttachment.emojiTag = emojiTag;

<span class="comment">//设置表情图片</span>
emojiTextAttachment.image = emojiImage;

<span class="comment">//插入表情</span>
[textView.textStorage <span class="string">insertAttributedString:</span>[NSAttributedString <span class="string">attributedStringWithAttachment:</span>emojiTextAttachment]
<span class="label">                                      atIndex:</span>textView.selectedRange.location];
</code></pre><h3 id="创建NSAttributedString的Category">创建NSAttributedString的Category</h3><p>最后，就是将这个遍历表情、拼接最终文本字符串的方法设置成NSAttributedString的自定义Category方法，以方便直接调用。<br>当然，这里面有些细节的处理，如替换表情标志时的字符串偏移量计算等，看代码吧。  </p>
<p>如下：</p>
<pre><code><span class="comment">//NSAttributedString+EmojiExtension.h</span>

<span class="class"><span class="keyword">@interface</span> <span class="title">NSAttributedString</span> (<span class="title">EmojiExtension</span>)</span>
- (<span class="built_in">NSString</span> *)getPlainString;
<span class="keyword">@end</span>


<span class="comment">//NSAttributedString+EmojiExtension.m</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">NSAttributedString</span> (<span class="title">EmojiExtension</span>)</span>

- (<span class="built_in">NSString</span> *)getPlainString {

    <span class="comment">//最终纯文本</span>
    <span class="built_in">NSMutableString</span> *plainString = [<span class="built_in">NSMutableString</span> stringWithString:<span class="keyword">self</span><span class="variable">.string</span>];

    <span class="comment">//替换下标的偏移量</span>
    __block NSUInteger base = <span class="number">0</span>;

    <span class="comment">//遍历</span>
    [<span class="keyword">self</span> enumerateAttribute:NSAttachmentAttributeName inRange:NSMakeRange(<span class="number">0</span>, <span class="keyword">self</span><span class="variable">.length</span>)
                     options:<span class="number">0</span>
                  usingBlock:^(<span class="keyword">id</span> value, <span class="built_in">NSRange</span> range, <span class="built_in">BOOL</span> *stop) {

                      <span class="comment">//检查类型是否是自定义NSTextAttachment类</span>
                      <span class="keyword">if</span> (value &amp;&amp; [value isKindOfClass:[EmojiTextAttachment class]]) {
                          <span class="comment">//替换</span>
                          [plainString replaceCharactersInRange:NSMakeRange(range<span class="variable">.location</span> + base, range<span class="variable">.length</span>)
                                                     withString:((EmojiTextAttachment *) value)<span class="variable">.emojiTag</span>];

                       <span class="comment">//增加偏移量                          </span>
                          base += ((EmojiTextAttachment *) value)<span class="variable">.emojiTag</span><span class="variable">.length</span> - <span class="number">1</span>;
                      }
                  }];

    <span class="keyword">return</span> plainString;
}

<span class="keyword">@end</span>
</code></pre><h3 id="使用">使用</h3><p>直接调用getPlainString方法即可。</p>
<h2 id="总结">总结</h2><p>其实本文也是来源于最近的项目需求，在网上一直找不到比较好的解决方案，就自己摸索出来一个。至于复杂的图文混合编辑，当然还是Core Text来的强大（自己也在学习中）~</p>
<p>如果有更好地办法，一定要告诉我啊~~~</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITextView_Class/#//apple_ref/occ/instp/UITextView/textStorage" target="_blank" rel="external">UITextView Class Reference</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAttributedString_Class/index.html#//apple_ref/occ/instm/NSAttributedString/enumerateAttribute:inRange:options:usingBlock:" target="_blank" rel="external">NSAttributedString Class Reference</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>在iOS开发中，经常需要用UITextView作为编辑文本的输入控件。<br>但是如何在编辑时插入自定义表情呢？就是像发微博时那样？  </p>
<p>本文简单的用<strong>NSTextAttachment</strong>、<s]]>
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于评论不见了=。=]]></title>
    <link href="http://tutuge.me/2015/03/06/%E5%85%B3%E4%BA%8E%E8%AF%84%E8%AE%BA%E4%B8%8D%E8%A7%81%E4%BA%86/"/>
    <id>http://tutuge.me/2015/03/06/关于评论不见了/</id>
    <published>2015-03-06T01:09:32.000Z</published>
    <updated>2015-03-06T01:18:56.000Z</updated>
    <content type="html"><![CDATA[<p>前天升级了一次Hexo，原来的主题说啥也用不了了=。=（前端知识不足，正在补~）导致只能换主题，多说的评论就这样不见了。。。原来有留言的各位筒子，没看到，不好意思啊=。=</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前天升级了一次Hexo，原来的主题说啥也用不了了=。=（前端知识不足，正在补~）导致只能换主题，多说的评论就这样不见了。。。原来有留言的各位筒子，没看到，不好意思啊=。=</p>
]]>
    </summary>
    
      <category term="杂烩" scheme="http://tutuge.me/tags/%E6%9D%82%E7%83%A9/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Entity和Model的不同-关于代码的数据层]]></title>
    <link href="http://tutuge.me/2015/03/01/Entity%E5%92%8CModel%E7%9A%84%E4%B8%8D%E5%90%8C-%E5%85%B3%E4%BA%8E%E4%BB%A3%E7%A0%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%B1%82/"/>
    <id>http://tutuge.me/2015/03/01/Entity和Model的不同-关于代码的数据层/</id>
    <published>2015-03-01T15:03:10.000Z</published>
    <updated>2015-03-01T17:01:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>经常都能在一些博客、文档中看到“<strong>Model</strong>”、“<strong>Entity</strong>”的字样。如<strong>MVC</strong>模式中的“<strong>M就是Model</strong>”，“<strong>MVVM对应的Model-View-ViewModel</strong>”，数据库抽象层里面的“<strong>Model</strong>“等。  </p>
<p>它们的区别到底是什么？  </p>
<p>其实没有真正官方的对Entity和Model的定义，在此我只是说说我自己的理解。</p>
<h2 id="什么是Entity">什么是<strong>Entity</strong></h2><p>先看看这个单词是什么意思：<br><a href="http://www.iciba.com/entity" target="_blank" rel="external">爱词霸</a>：n: 实体，实际存在物，本质。</p>
<p>在代码中，我们经常会遇到一些具有“<strong>现实</strong>”意义的“<strong>个体</strong>”，如一个用户，一首歌曲，一条评论等等，它们都是在逻辑上完整的一个整体，都具有相似的结构，但是却因为“<strong>属性</strong>”的不同而不同。</p>
<p>看看一个典型的Entity类：</p>
<pre><code><span class="comment">//Java </span>

<span class="comment">//Entity类定义</span>
<span class="class"><span class="keyword">class</span> <span class="title">UserEntity</span> </span>{
    <span class="keyword">public</span> String name;
    <span class="keyword">public</span> <span class="keyword">int</span> age;
    <span class="keyword">public</span> String address;
}

<span class="comment">//Entity对象</span>
UserEntity john = <span class="keyword">new</span> UserEntity();
john.name = <span class="string">"John"</span>;
john.age = <span class="number">20</span>;
john.address = <span class="string">"China Hubei Wuhan"</span>;

UserEntity tom = <span class="keyword">new</span> UserEntity();
tom.name = <span class="string">"Tom"</span>;
tom.age = <span class="number">30</span>;
tom.address = <span class="string">"USA Californian"</span>;
</code></pre><p>所以：</p>
<ul>
<li>Entity类，或者说<strong>实体类</strong>，代表了一种“个体”，类中的属性（就是各种变量）则是这个“个体”的具体体现。如UserEntity类，里面有name、age属性，就是说Entity类“<strong>描述</strong>”了某种个体。</li>
<li>Entity类的具体对象，代表了一个具体的实体，一般来说，在代码当中，一个具体的Entity类对象所代表的实体应当是唯一的。</li>
<li>往往Entity类的定义跟数据库中的表定义是一一对应的。</li>
<li>而Entity的具体对象往往对应数据库中的一行数据。</li>
<li>Entity是代码中操作数据的“<strong>最小单元</strong>”。</li>
</ul>
<h2 id="什么是Model">什么是Model</h2><h3 id="各种用法">各种用法</h3><p>其实很多时候，Model有如下几种用法：</p>
<ol>
<li>当成Entity用，完全不具备其他业务逻辑代码。</li>
<li>当成<strong>数据库接口层</strong>，就是将数据库的读写，增删改查都封装在了Model中，往往就会有如“<strong>getUserByID</strong>”这样的方法。</li>
<li>当成纯粹的业务处理类。</li>
</ol>
<p>所以仁者见仁，智者见智，其实都可以。</p>
<p>在此说说我的认识。</p>
<h3 id="我的认识">我的认识</h3><p>先看看Model单词的意思:<br><a href="http://www.iciba.com/model" target="_blank" rel="external">爱词霸</a>：n: 模型；模式；典型。</p>
<p>既然是模型，而不是“数据”，所以我觉得，<strong>Model应该是利用Entity实体，来组合、处理、整合更上层、更抽象数据的类</strong>。</p>
<p>还是基于上面的“<strong>UserEntity</strong>”，看看下面的代码：</p>
<pre><code>class UserListModel {
    private UserEntity[] users;

    //构造函数，初始化用户列表等。

    UserEntity getUserByName(String name) {
        //查找<span class="keyword">...</span>
    }

    void transformUserAddressFormat {
        //转化地址格式
    }
}
</code></pre><p>就是说，Entity还是原本的概念，只不过Model是基于Entity的更高层的数据抽象与处理。</p>
<h2 id="总结">总结</h2><p>说实话，Entity、Model，它们的职责到底是什么，真的不好说明白，大家也就做个参考吧=。=</p>
<h2 id="参考">参考</h2><ul>
<li><a href="http://stackoverflow.com/questions/3029952/ddd-and-mvc-difference-between-model-and-entity" target="_blank" rel="external">DDD and MVC: Difference between ‘Model’ and ‘Entity’</a></li>
<li><a href="http://whatis.techtarget.com/definition/entity" target="_blank" rel="external">Whatis.com Entity</a></li>
<li><a href="http://blogsh.de/2011/09/08/models-vs-entities" target="_blank" rel="external">Models vs. Entities</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>经常都能在一些博客、文档中看到“<strong>Model</strong>”、“<strong>Entity</strong>”的字样。如<strong>MVC</strong>模式中的“<strong>M就是Model</stron]]>
    </summary>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一次审核被拒的经历-关于iCloud到底应该备份什么数据]]></title>
    <link href="http://tutuge.me/2015/02/28/%E4%B8%80%E6%AC%A1%E5%AE%A1%E6%A0%B8%E8%A2%AB%E6%8B%92%E7%9A%84%E7%BB%8F%E5%8E%86-%E5%85%B3%E4%BA%8EiCloud%E5%88%B0%E5%BA%95%E5%BA%94%E8%AF%A5%E5%A4%87%E4%BB%BD%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE/"/>
    <id>http://tutuge.me/2015/02/28/一次审核被拒的经历-关于iCloud到底应该备份什么数据/</id>
    <published>2015-02-28T10:18:11.000Z</published>
    <updated>2015-02-28T14:50:12.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>项目最近一次审核被拒了=。=<br>仔细看了一下后，发现是没有遵守“<strong>iOS Data Storage Guidelines</strong>”。<br>在此总结一下。</p>
<h2 id="被拒原因">被拒原因</h2><p>先看看被拒的反馈信息：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apps must follow the iOS <span class="built_in">Data</span> Storage Guidelines <span class="literal">or</span> they will be rejected</span><br><span class="line"></span><br><span class="line"><span class="keyword">On</span> launch <span class="literal">and</span> content download, your app stores <span class="number">12.14</span> MB, which does <span class="literal">not</span> comply <span class="keyword">with</span> the iOS <span class="built_in">Data</span> Storage Guidelines<span class="built_in">.</span></span><br></pre></td></tr></table></figure>
<p>大致意思就是App下载东西以后，在iCloud里面查看此App需要备份的体积变大了。  </p>
<p>再根据 <a href="https://developer.apple.com/icloud/documentation/data-storage/index.html" target="_blank" rel="external"><strong>iOS Data Storage Guidelines</strong></a>的说明，得出几点重要信息：</p>
<ul>
<li>只有<strong>用户创建的，并且不能被App重现的文档、数据</strong>，才应该被保存在“<strong><application_home>/Documents</application_home></strong>”路径下。</li>
<li>可以重新产生、下载的数据可以放在“<strong><application_home>/Library/Caches</application_home></strong>”目录下，如用于缓存的数据库文件。</li>
<li>纯粹用于缓存的数据可以放在“<strong><application_home>/tmp</application_home></strong>”目录下。</li>
<li>可以通过对NSURL加参数，来保证特定的文件夹及其内容不被iCloud备份，也不会被清除，如Document文件夹。</li>
</ul>
<p>所以可以初步得出被拒的原因是因为App中下载的文件也被包含在iCloud备份当中了，而Apple审核人员觉得这些文件不应该被备份。</p>
<h3 id="真正应该备份的数据">真正应该备份的数据</h3><p>所以，真正需要备份的文件是<strong>用户创建的，不能通过程序重新产生的</strong>，如记事本应用中用户创建的文本数据，绘画应用中用户画的画等。</p>
<h2 id="解决当中遇到的坑">解决当中遇到的坑</h2><p>既然知道了原因，那就好办了。</p>
<p>根据<strong>iOS Data Storage Guidelines</strong>的简短说明，乍一看，<strong><application_home>/Library/Caches</application_home></strong>是存放可以重新产生、下载的数据。</p>
<p>但是有个“陷阱”在这。</p>
<h3 id="系统可能清空的目录">系统可能清空的目录</h3><p>根据官方文档“<a href="https://developer.apple.com/library/mac/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple_ref/doc/uid/TP40010672-CH2-SW1" target="_blank" rel="external"><strong>File System Programming Guide</strong></a>”可以整理出一下两个系统可能会清除的目录：（在储存空间不够时）</p>
<ol>
<li><strong> Library/Caches/ </strong></li>
<li><strong> tmp/ </strong></li>
</ol>
<p>所以，像App下载的歌曲等资源文件是不能放在上面两个目录中的。</p>
<h2 id="解决：">解决：</h2><p>所以，为了保险起见，最靠谱的还是放在<strong><application_home>/Documents</application_home></strong>中，并且通过设置，不让iCloud备份。</p>
<p>Apple已经提供了相应的函数，如下（iOS 5.1及以后的版本）：</p>
<pre><code>- (BOOL)addSkipBackupAttributeToItemAtURL:(NSURL *)URL
{
    <span class="built_in">assert</span>(<span class="string">[[NSFileManager defaultManager] fileExistsAtPath: [URL path]]</span>);

    NSError *<span class="built_in">error</span> = <span class="keyword">nil</span>;
    BOOL success = [URL setResourceValue: [NSNumber numberWithBool: YES]
                                  forKey: NSURLIsExcludedFromBackupKey <span class="built_in">error</span>: &amp;<span class="built_in">error</span>];
    <span class="keyword">if</span>(!success){
        NSLog(@<span class="string">"Error excluding %@ from backup %@"</span>, [URL lastPathComponent], <span class="built_in">error</span>);
    }
    <span class="keyword">return</span> success;
}
</code></pre><h3 id="特性">特性</h3><ul>
<li><strong><application_home>/Documents</application_home></strong>根目录也可以通过上面的函数设置成不备份。（如应用AVPlayer）</li>
<li>设置是递归的，所以其所有子目录和文件都不用再设置一次，都会自动不被备份。（测试有效，但是不确定=。=，参考：<a href="http://stackoverflow.com/questions/14376883/is-nsurlisexcludedfrombackupkey-recursive" target="_blank" rel="external">is-nsurlisexcludedfrombackupkey-recursive</a>）</li>
</ul>
<h2 id="总结">总结</h2><p>多看官方说明=。=</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/icloud/documentation/data-storage/index.html" target="_blank" rel="external">iOS Data Storage Guidelines</a></li>
<li><a href="https://developer.apple.com/library/ios/qa/qa1719/_index.html" target="_blank" rel="external">How do I prevent files from being backed up to iCloud and iTunes?</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple_ref/doc/uid/TP40010672-CH2-SW4" target="_blank" rel="external">File System Programming Guide</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>项目最近一次审核被拒了=。=<br>仔细看了一下后，发现是没有遵守“<strong>iOS Data Storage Guidelines</strong>”。<br>在此总结一下。</p>
<h2 id="被拒原因">被拒原因</h2]]>
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="审核" scheme="http://tutuge.me/tags/%E5%AE%A1%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Block类型变量-缓存Http请求与回调]]></title>
    <link href="http://tutuge.me/2015/02/19/Block%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F-%E7%BC%93%E5%AD%98Http%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%9B%9E%E8%B0%83/"/>
    <id>http://tutuge.me/2015/02/19/Block类型变量-缓存Http请求与回调/</id>
    <published>2015-02-18T19:18:36.000Z</published>
    <updated>2015-02-19T09:53:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>Objective-C中的Blocks实在是太好用了，有了它，我们就可以将“代码块”封装起来，当成变量使用、传递，所以，在Objective-C中，iOS中，许多的回调是用Block来完成的。</p>
<h2 id="问题">问题</h2><p>我自己在之前的项目中，就遇到过一个问题。因为项目的需要，手机端所有的跟服务器的通信都需要“加密”，在经过一番调研后，我们使用的是类似OAuth机制（至于什么是OAuth，各位Google一下就明白了，大部分的公共API都用到了这种机制）。</p>
<h3 id="缓存Http请求后的回调代码块">缓存Http请求后的回调代码块</h3><p>既然是OAuth机制，就是说我们每次向服务器发起的请求，除了跟业务相关的参数，还需要带上AccessToken、UserToken这类的授权参数，而AccessToken在本次请求中是否会过期，在结果返回前是不知道的，所以，为了更好地用户体验，不至于让用户在某个时刻的操作，因为授权过期了而“没有响应”，我们的每次Http请求都必须缓存起来。</p>
<p>这里的缓存可不是单单指缓存请求的参数、URL，更重要的是缓存Http请求成功或者失败时的“<strong>回调代码块</strong>”。</p>
<h2 id="实现">实现</h2><h3 id="AFNetworking的Get方法">AFNetworking的Get方法</h3><p>在iOS的项目中，AFNetworking应该算是使用的最多的网络库了，它的Get请求的方法接口如下：</p>
<pre><code><span class="pp">- <span class="params">(<span class="variable">AFHTTPRequestOperation</span> *)</span>GET:<span class="params">(<span class="variable">NSString</span> *)</span>URLString
                     parameters:<span class="params">(id)</span>parameters
                        success:<span class="params">(void (^)</span><span class="params">(<span class="variable">AFHTTPRequestOperation</span> *operation, id response<span class="variable">Object</span>)</span>)success
                        failure:<span class="params">(void (^)</span><span class="params">(<span class="variable">AFHTTPRequestOperation</span> *operation, <span class="variable">NSError</span> *error)</span>)failure</span>
</code></pre><p>只有四个参数，分别是Url、参数、成功的回调Block，失败的回调Block，看，这里，回调的代码块就被封装到了Block里面，并当成参数传入。</p>
<h3 id="再次封装">再次封装</h3><p>介于AFNetworking只提供了最基本的Get、Post、Put这些方法，所以，我们往往根据业务的接口做了封装，如先定义了请求的类型枚举：</p>
<pre><code>//Http type, for<span class="instruction"> execute
</span>typedef<span class="function"> NS_ENUM(</span>NSUInteger, HTTP_REQUEST_TYPE<span class="function">)</span> {
    ICG_GET = 0,
    ICG_POST
};
</code></pre><p>然后定义了统一的请求入口与回调参数Block：</p>
<pre><code><span class="comment">//请求成功后的回调</span>
typedef <span class="typename">void</span> (^http_success)(id result);
<span class="comment">//请求失败后的回调</span>
typedef <span class="typename">void</span> (^http_fail)();

<span class="comment">//统一的请求入口</span>
+ (<span class="typename">void</span>)<span class="string">executeWithType:</span>(HTTP_REQUEST_TYPE)type <span class="string">api:</span>(NSString *)api
<span class="label">            parameters:</span>(NSDictionary *)parameters <span class="string">success:</span>                (http_success)success <span class="string">fail:</span>(http_fail)fail {    

    <span class="comment">//为每个请求增加AccessToken、UserToken等公共参数</span>
    <span class="comment">//...</span>

    <span class="comment">//缓存Http请求</span>
    <span class="comment">//...</span>

    <span class="comment">//根据type区分具体是哪一种Http请求。</span>
    <span class="keyword">switch</span> (type) {
        <span class="keyword">case</span> <span class="string">ICG_GET:</span>
            [HttpUtil <span class="string">get:</span>url <span class="string">parameters:</span>paras <span class="string">success:</span>success <span class="string">fail:</span>fail];
            <span class="keyword">break</span>;    
        <span class="keyword">case</span> <span class="string">ICG_POST:</span>
            [HttpUtil <span class="string">post:</span>url <span class="string">parameters:</span>paras <span class="string">success:</span>success <span class="string">fail:</span>fail];
            <span class="keyword">break</span>;    
<span class="label">        default:</span>
            <span class="keyword">break</span>;
    }
}
</code></pre><h3 id="再次封装的好处">再次封装的好处</h3><p>为什么要再次做封装，将基本的Http请求统一入口？道理很简单，就是为了能方便的对每次请求增加额外的处理，并且对上层调用透明。如:</p>
<ul>
<li>统一为每个请求增加Log。</li>
<li>统一为每个请求增加如AccessToken这些额外的参数。</li>
<li>方便对Http请求做缓存！</li>
</ul>
<h3 id="缓存Http请求的数据结构">缓存Http请求的数据结构</h3><p>既然我们已经有了统一的请求入口，为了缓存，所需要做的就是将能代表一次请求的所有参数缓存起来就行了，如URL、请求参数等，如下数据结构：</p>
<pre><code><span class="variable">@interface</span> <span class="attribute">RequestHolder </span>: NSObject

<span class="comment">//URL地址</span>
<span class="variable">@property</span>(strong, nonatomic) NSString *url;
<span class="comment">//请求参数</span>
<span class="variable">@property</span>(strong, nonatomic) NSMutableDictionary *paras;
<span class="comment">//请求类型，如Get、Post</span>
<span class="variable">@property</span>(assign, nonatomic) HTTP_REQUEST_TYPE type;
<span class="comment">//请求成功回调</span>
<span class="variable">@property</span>(copy) http_success success;
<span class="comment">//请求失败回调</span>
<span class="variable">@property</span>(copy) http_fail fail;
<span class="variable">@end</span>
</code></pre><p>这几个参数，就可以完整的“代表、重现”一次具体的Http请求。</p>
<h3 id="如何缓存">如何缓存</h3><p>只要App开启，Http请求就会不停地产生，会有源源不断的请求，难道我们把每次请求都缓存起来？</p>
<p>全部都缓存肯定是不行的，所以我们需要一个缓存策略。</p>
<p>一个App中，所有的Http请求的路径，也就是Url，不包括参数，应该是数量固定的，如“/user, /comment”，并且，一个请求往往对应的操作、功能也是唯一的，所以，完全可以以请求的<strong>Url</strong>为<strong>Key</strong>，以本次请求的“<strong>RequestHolder</strong>”为<strong>Value</strong>，用Objective-C中的NSDictionary来缓存Http请求。</p>
<p>所以，缓存请求的方法大致如下：</p>
<pre><code><span class="comment">//缓存Http请求</span>

- (<span class="keyword">void</span>)cacheHttpRequest:(HTTP_REQUEST_TYPE)<span class="class"><span class="keyword">type</span> <span class="title">url</span>:</span>(NSString *)url
                parameters:(NSMutableDictionary *)parameters success:(http_success)success fail:(http_fail)fail {

    <span class="comment">//创建缓存数据结构，保存本次请求的参数、回调</span>
    ICGRequestHolder *requestHolder = [ICGRequestHolder <span class="keyword">new</span>];
    requestHolder.url = url;
    requestHolder.paras = parameters;
    requestHolder.success = [success copy];
    requestHolder.fail = [fail copy];
    requestHolder.<span class="keyword">type</span> = <span class="class"><span class="keyword">type</span>;</span>

    <span class="comment">//保存本次请求</span>
    [_operationQueue addOperationWithBlock:^{
        _cachedRequests[url] = requestHolder;
    }];
}
</code></pre><p>这样，就能完整的缓存Http请求了。</p>
<h3 id="从缓存中恢复Http请求">从缓存中恢复Http请求</h3><p>恢复请求很简单，直接遍历所有缓存的请求，再次发起Http请求即可，就不再贴代码了。</p>
<h3 id="删除成功的Http请求">删除成功的Http请求</h3><p>缓存的目的是在请求失败时，如AccessToken超时时，我们可以在重新获取AccessToken后重现上次失败的请求，所以，一旦请求成功时，我们还需要将成功的请求删除，当然，也是利用Url，如下：</p>
<pre><code>- (<span class="typename">void</span>)<span class="string">removeRequestForKey:</span>(NSString *)url {
    <span class="comment">//放入队列执行</span>
    [_operationQueue <span class="string">addOperationWithBlock:</span>^{
        <span class="comment">//删除Url对应的请求</span>
        [_cachedRequests <span class="string">removeObjectForKey:</span>url];
    }];
}
</code></pre><h2 id="总结">总结</h2><p>本文只是简单地利用Objective-C中的Block特性，实现了Http请求的缓存。目的不是介绍Block，是为了分享我自己在项目中运用Block的例子，如果读者有更好的方法，欢迎留言啊~~</p>
<h2 id="参考、推荐阅读">参考、推荐阅读</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html" target="_blank" rel="external">Working with Blocks</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>Objective-C中的Blocks实在是太好用了，有了它，我们就可以将“代码块”封装起来，当成变量使用、传递，所以，在Objective-C中，iOS中，许多的回调是用Block来完成的。</p>
<h2 id="问题">问题</h]]>
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[提升UITableView性能-复杂页面的优化]]></title>
    <link href="http://tutuge.me/2015/02/19/%E6%8F%90%E5%8D%87UITableView%E6%80%A7%E8%83%BD-%E5%A4%8D%E6%9D%82%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://tutuge.me/2015/02/19/提升UITableView性能-复杂页面的优化/</id>
    <published>2015-02-18T17:28:41.000Z</published>
    <updated>2015-03-06T03:19:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>随着App的用户界面的内容越来越丰富，再强的手机可能都无法同时渲染复杂的UI界面和保证流畅的体验。所以，我们这些程序猿=。=在写代码的时候就要注意，如何尽可能提高用户的操作流畅性。</p>
<p>之前的做的项目，<a href="https://itunes.apple.com/us/app/qing-ju-yin-le-quan-guo-zui/id913235479?l=zh&amp;ls=1&amp;mt=8" target="_blank" rel="external">青桔音乐iOS客户端</a>里面的首页就是一个类似微信朋友圈的“动态”页面，大致如下：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_ios_speed_up_uitableview_1_1.png?imageView2/0/h/300" alt="image"></p>
<p>如果是你，你会怎么实现这个页面呢？</p>
<p>这还用问，当然是用UITableView+自定义的UITableViewCell。</p>
<p>UITableView是可以滑动的，为了不让用户在滑动中感到有卡顿，该如何优化？下面，我就写一下我自己在做项目时的“经验”~</p>
<h2 id="优化">优化</h2><p>主要分为以下几点：</p>
<ul>
<li>只定义一种Cell。</li>
<li>提前计算并缓存每个Cell的高度。</li>
<li>提前创建真正显示的、需要加工的数据并缓存。</li>
<li>缓存View！</li>
<li>其它。</li>
</ul>
<h3 id="只定义一种Cell">只定义一种Cell</h3><p>乍一看，这个界面至少有3种样式的Cell，为什么只定义一种呢？</p>
<h4 id="分析结构">分析结构</h4><p>仔细分析一下，页面中每个Cell的内容都有头像、标题、正文、评论、其它（歌曲、图片、歌手）。所以，从整体上看，每个Cell的结构是一致的！</p>
<h4 id="重用=大致固定数量的Cell">重用=大致固定数量的Cell</h4><p>并且，凡是认真研究过UITableView的人应该都知道，Apple已经为我们提供了Cell的重用，如用“<strong>registerNib:forCellReuseIdentifier</strong>”方法注册自定义Cell的Nib，然后在“<strong>cellForRowAtIndexPath</strong>”的时候用“<strong>dequeueReusableCellWithIdentifier</strong>”获取可以重用的Cell，所以，无论UITableView要显示内容有多少，真正创建出的Cell可能只有5、6个。</p>
<p>所以，我们完全可以只创建一种Cell，虽然这样一个Cell的“体积”可能会很大，但是介于Cell的数量不会很多，所以完全可以接受。</p>
<h5 id="只定义一种Cell的好处"><strong>只定义一种Cell的好处</strong></h5><ul>
<li>减少代码量，减少Nib文件的数量，统一一个Nib文件定义Cell，容易修改、维护。</li>
<li>基于Cell的重用，真正运行时铺满屏幕所需的Cell数量大致是固定的，设为<strong>N</strong>个。所以如果如果只有一种Cell，那就是只有<strong>N</strong>个Cell的实例；但是如果有<strong>M</strong>种Cell，那么运行时最多可能会是“<strong>M x N = MN</strong>”个Cell的实例，虽然可能并不会占用太多内存，但是能少点不是更好吗。</li>
</ul>
<h4 id="善用hidden隐藏（显示）Subview">善用hidden隐藏（显示）Subview</h4><p>既然只定义一种Cell，那该如何显示不同类型的内容呢？<br>答案就是，把所有不同类型的view都定义好，放在cell里面，通过hidden显示、隐藏，来显示不同类型的内容。如下图定义Cell：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_ios_speed_up_uitableview_1_2.jpg?imageView2/0/h/400" alt="image"></p>
<p>图中的Subview1、Subview2、Subview3就是不同类型Cell的不同之处，所以我们在“<strong>cellForRowAtIndexPath</strong>”函数中，设置Cell的样式、内容时，就可以通过显示、隐藏这三个子view来显示。</p>
<p>毕竟，在用户快速滑动中，只是单纯的显示、隐藏subview比实时创建要快得多。</p>
<h3 id="提前计算并缓存每个Cell的高度">提前计算并缓存每个Cell的高度</h3><p>开发过Android，用过Android的ListView以后，对UITableView需要提前计算Cell的高度很不适应。=。= </p>
<p>首先要确定的是，在iOS中，系统会先调用“<strong>tableView:heightForRowAtIndexPath:</strong>”获取每个Cell即将显示的高度，从而确定整个UITableView的布局。然后才调用“<strong>tableView:cellForRowAtIndexPath</strong>”获取每个Cell，我们也是在这里填充、设置Cell的。</p>
<p><strong>所以，既然高度总会被用到，那就早早的在获取数据时就计算好吧！</strong></p>
<h4 id="在Model（Entity）中计算并保存Cell的高度">在Model（Entity）中计算并保存Cell的高度</h4><p>其实，在Model（Entity）中保存UI的参数是很奇怪的=。=（最好放在ViewModel中，就是MVVM模式的），我们的Entity可能就是下面的样子：</p>
<pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">DataEntity</span> : <span class="title">NSObject</span></span>

<span class="comment">//原始数据</span>
<span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *content;
<span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *title;

<span class="comment">//Cell 高度</span>
<span class="keyword">@property</span>(<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> cellHeight;

<span class="comment">//计算高度</span>
- (<span class="keyword">void</span>)calculateCellHeight;

<span class="keyword">@end</span>
</code></pre><p>这样，就不用在“<strong>tableView:heightForRowAtIndexPath:</strong>”中每次都计算了。</p>
<h3 id="提前创建真正显示的、需要加工的数据并缓存">提前创建真正显示的、需要加工的数据并缓存</h3><p>Cell中显示的内容，很多时候可能并不是直接从服务器拿到的数据，而是经过“加工”的数据。如本文中的“动态”也，每个Cell的标题、正文都有可点击的连接Link、表情图片等富文本内容，而我们一般用NSAttributeString类来显示。</p>
<p>既然每次都会用到，倒不如在获取到数据的时候就创建、加工好这些内容，等到需要现实的时候，直接拿来用不就行了。</p>
<p>所以，我们的Entity类可能变成下面这个样子: </p>
<pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">DataEntity</span> : <span class="title">NSObject</span></span>

<span class="comment">//原始数据</span>
<span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *content;
<span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *title;

<span class="comment">//Cell 高度</span>
<span class="keyword">@property</span>(<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> cellHeight;

<span class="comment">//真正显示的内容</span>
<span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) NSAttributedString *showTitle;
<span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) NSAttributedString *showContent;

<span class="comment">//计算高度</span>
- (<span class="keyword">void</span>)calculateCellHeight;

<span class="comment">//创建、加工真正显示的内容</span>
- (<span class="keyword">void</span>)setupShowTitileAndContent;

<span class="keyword">@end</span>
</code></pre><p>这样，在“<strong>tableView:cellForRowAtIndexPath</strong>”中，我们直接拿showTitle、showContent来显示就好，不用再创建。</p>
<h3 id="缓存View!">缓存View!</h3><p>什么？缓存View？！</p>
<p>是的，当Cell中的部分View是非常独立的，并且不便于重用的，而且“体积”非常小，在内存可控的前提下，我们完全可以将这些view缓存起来！</p>
<p>方法当然也是将缓存的view放在Entity中~。</p>
<h3 id="其它">其它</h3><p>当然，还有其他的优化方法，简单说一说：</p>
<ul>
<li>尽量设置Cell的view为opaque，避免GPU对Cell下面的内容也进行绘制。</li>
<li>避免大量的图片缩放、颜色渐变等。</li>
<li>避免同步的从网络、文件获取数据（这个是必须的=。=）</li>
<li>用shadowPath创建阴影。</li>
<li>尽量减少subview的数量，如多用drawRect绘制元素，替代用view显示。</li>
<li>尽量显示“<strong>大小刚好合适</strong>”的图片资源。</li>
</ul>
<h2 id="总结">总结</h2><p>总的来说，就是：</p>
<p><strong>缓存一切可以缓存的！就是“用空间替换时间”！</strong></p>
<p><strong>在UITableView的Delegate、DataSource方法中，减少任何不必要的操作</strong></p>
<h2 id="参考，推荐阅读">参考，推荐阅读</h2><ul>
<li><a href="http://www.raywenderlich.com/31166/25-ios-app-performance-tips-tricks#tableviews" target="_blank" rel="external">25 iOS App Performance Tips &amp; Tricks</a></li>
<li><a href="http://stackoverflow.com/questions/1352479/tricks-for-improving-iphone-uitableview-scrolling-performance" target="_blank" rel="external">Tricks for improving iPhone UITableView scrolling performance?</a></li>
<li><a href="http://stackoverflow.com/questions/6172158/how-can-i-speed-up-a-uitableview" target="_blank" rel="external">How can I speed up a UITableView?</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>随着App的用户界面的内容越来越丰富，再强的手机可能都无法同时渲染复杂的UI界面和保证流畅的体验。所以，我们这些程序猿=。=在写代码的时候就要注意，如何尽可能提高用户的操作流畅性。</p>
<p>之前的做的项目，<a href="htt]]>
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NSString的Copy与内存分配]]></title>
    <link href="http://tutuge.me/2015/02/18/NSString%E7%9A%84Copy%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>http://tutuge.me/2015/02/18/NSString的Copy与内存分配/</id>
    <published>2015-02-18T09:00:47.000Z</published>
    <updated>2015-02-18T12:04:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>不管是用什么语言开发，字符串应该算是用的最多的了。在Objective-C中，字符串类是NSString，以及其子类NSMutableString等。所以，对于字符串类，编程语言、编译器等往往会做特殊处理。下面我就说说我自己在项目中发现的NSString的“奇怪”的地方。</p>
<h2 id="字符串常量，copy，mutableCopy">字符串常量，copy，mutableCopy</h2><h3 id="Example">Example</h3><p>先看看如下面的代码，猜猜会输出什么：</p>
<pre><code><span class="built_in">NSString</span> *str1 = <span class="string">@"abc"</span>;
<span class="built_in">NSString</span> *str2 = <span class="string">@"abc"</span>;
<span class="built_in">NSString</span> *str3 = [[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@"abc"</span>];
<span class="built_in">NSString</span> *str4 = [str1 <span class="keyword">copy</span>];
<span class="built_in">NSString</span> *str5 = [str1 mutableCopy];

<span class="comment">//输出内存中的地址</span>
<span class="built_in">NSLog</span>(<span class="string">@"str1: %p"</span>, str1);
<span class="built_in">NSLog</span>(<span class="string">@"str2: %p"</span>, str2);
<span class="built_in">NSLog</span>(<span class="string">@"str3: %p"</span>, str3);
<span class="built_in">NSLog</span>(<span class="string">@"str4: %p"</span>, str4);
<span class="built_in">NSLog</span>(<span class="string">@"str5: %p"</span>, str5);
</code></pre><p>直接给出结果：</p>
<pre><code><span class="comment">//地址值由运行时决定，不唯一</span>
<span class="string">str1:</span> <span class="number">0x10cd12040</span>
<span class="string">str2:</span> <span class="number">0x10cd12040</span>
<span class="string">str3:</span> <span class="number">0x10cd12040</span>
<span class="string">str4:</span> <span class="number">0x10cd12040</span>
<span class="string">str5:</span> <span class="number">0x7f874b508350</span> <span class="comment">//mutable copy</span>
</code></pre><p>看，是不是很“神奇”。</p>
<h3 id="简单解释">简单解释</h3><p>NSString是“不可变（immutable）”的类型，这个是关键。<br>代码中的“@”开头的字符串，其实就是一个字符串常量，运行时会检测这个字符串是否已经存在，存在的话，就直接将这个字符串的地址赋给变量；不存在的话，则创建，再赋值。</p>
<p><strong>第一行</strong>: “abc”字符串不存在，创建，取得字符串地址“0x10cd12040”，赋给str1. </p>
<p><strong>第二行</strong>: “abc”字符串已经存在，直接将地址“0x10cd12040”赋给str2.  </p>
<p><strong>第三行</strong>: （记住，NSString是不可变的）alloc并不会分配新的内存，直接将字符串地址“0x10cd12040”赋给str3.  </p>
<p><strong>第四行</strong>: copy，既然是不可变的，也就没有必要分配新内存，直接将地址“0x10cd12040”赋给str4.  </p>
<p><strong>第五行</strong>: mutableCopy其实就是创建一个NSMutableString的实例，既然是“可变（mutable）”的类型了，当然要分配新的内存，所以，字符串的地址也变成新的“0x7f874b508350”。</p>
<p>可以这么说，编译器、runtime充分利用了NSString是“<strong>不可变（immutable）</strong>”类型这个特点，只要字符串内容一致，就不会分配新的内存储存，字符串在程序中使用量非常大，这么做无疑可以大大节省内存，提升性能。</p>
<h2 id="Property_和_NSString">Property 和 NSString</h2><p>先来看看一个UserEntity类：</p>
<pre><code><span class="comment">//UserEntity.h</span>

<span class="variable">@interface</span> <span class="attribute">UserEntity </span>: NSObject &lt;NSCopying&gt;
<span class="variable">@property</span>(strong, nonatomic) NSString *name;
<span class="variable">@end</span>
</code></pre><p>只有一个名为name的NSString类型Property。<br>相信大家对这个不陌生吧。一般我们的应用中会有很多Entity类型，每个Entity类里面肯定避免不了有许多NSString的字符串类型。这里的name的属性是：strong和nonatomic，strong表明name要“持有”一份name所指的字符串的引用，nonatomic表示property类型不用加锁。</p>
<p>接着咱们看看下面的代码：</p>
<pre><code>UserEntity *userEntity = [UserEntity <span class="keyword">new</span>];        

<span class="comment">//创建mutable类型的字符串</span>
NSMutableString *showName = [[NSMutableString alloc] <span class="string">initWithString:</span>@<span class="string">"tutuge"</span>];        

<span class="comment">//先保存“tutuge”字符串到userEntity的name</span>
userEntity.name = showName;        

<span class="comment">//修改showName</span>
[showName <span class="string">appendString:</span>@<span class="string">" blog"</span>];        

<span class="comment">//输出userEntity的name属性</span>
NSLog(@<span class="string">"Name: %@"</span>, userEntity.name);
</code></pre><p>猜猜会输出什么？</p>
<pre><code><span class="attribute">Name</span>: <span class="string">tutuge blog</span>
</code></pre><p>看，我们明明是保存的“tutuge”，怎么到后面输出的是“tutuge blog”？</p>
<h3 id="让NSString类型的Property为Copy型">让NSString类型的Property为Copy型</h3><p>因为name的Property属性是strong的，所以赋值后，它跟showName均指向同一个NSMutableString实例，如下：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_ios_nsstring_copy_1_1.jpg" alt="image"></p>
<p>所以改变了showName，当然name输出的值也就变了。<br>这个时候，name的property属性就不能是strong了，应该是copy，如下：</p>
<pre><code><span class="comment">//UserEntity.h</span>

<span class="variable">@interface</span> <span class="attribute">UserEntity </span>: NSObject &lt;NSCopying&gt;
<span class="variable">@property</span>(copy, nonatomic) NSString *name;
<span class="variable">@end</span>
</code></pre><p>这样的话，当“<strong>userEntity.name = showName;</strong>”这句运行后，内存布局如下：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_ios_nsstring_copy_1_2.jpg" alt="image"></p>
<p>这样，就避免了这个问题。</p>
<h2 id="总结">总结</h2><p>很所时候，代码并不是看上去那样“运行”的，多试试，多查阅资料，就能了解其中的奥秘了~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>不管是用什么语言开发，字符串应该算是用的最多的了。在Objective-C中，字符串类是NSString，以及其子类NSMutableString等。所以，对于字符串类，编程语言、编译器等往往会做特殊处理。下面我就说说我自己在项目中发现]]>
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用NSProxy实现消息转发-模块化的网络接口层设计-原创]]></title>
    <link href="http://tutuge.me/2015/02/16/%E5%88%A9%E7%94%A8NSProxy%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82%E8%AE%BE%E8%AE%A1-%E5%8E%9F%E5%88%9B/"/>
    <id>http://tutuge.me/2015/02/16/利用NSProxy实现消息转发-模块化的网络接口层设计-原创/</id>
    <published>2015-02-16T10:52:08.000Z</published>
    <updated>2015-03-05T05:44:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>之前在做项目的时候，所有业务的网络接口方法，全部都写在了一个文件里面，一开始还好，毕竟每个方法的代码也只是十几行，增加、修改也比较容易。但是随着接口的增多，这个文件慢慢居然超过了1000行，里面几十个方法都写在一起，实在是不好维护。  </p>
<p>虽然保持这样也没有什么，多用用Cmd+F就能找到。但是，真是越看越不顺眼😳， 代码一定要有“美感”啊~😝</p>
<p>所以在查阅了大量文章后，终于想出了本文即将说明的办法，越发觉得Objective-C的“消息”机制是多么的赞~😚</p>
<h2 id="Github_示例">Github 示例</h2><p>贴上本文中的示例工程：<a href="https://github.com/zekunyan/HttpProxyExample" target="_blank" rel="external">https://github.com/zekunyan/HttpProxyExample</a></p>
<h2 id="问题">问题</h2><p>先抛出问题。  </p>
<p>一款互联网应用，免不了要跟服务器打交道，在iOS项目中，最有名的网络库应该就是<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a>了。所以，很多人就会利用AFnetworking提供的Get、Post等基本Http请求接口，封装自己的网络接口层代码，我自己在项目中也是这么做的。  </p>
<p>但是，AFNetworking只是提供了Get、Post、Json传输等基本的Http请求方法，所以一旦落实到具体的业务相关的请求上，我们要为每个请求（URL）都写一个单独的接口方法。</p>
<p><strong>那么，问题就来了</strong>  </p>
<p>业务相关的接口那么多，举个例子，什么“通过用户ID获取用户基本信息”、“获取用户的所有评论”等，每个请求都是一个方法，这么多方法该怎么组织呢？全部放在一起？那这个接口类岂不是会非常乱？不放在一起？那岂不是会有很多个网络请求类？(至于要不要统一接口入口，我想这个根据项目来决定吧=。=)</p>
<h2 id="需求">需求</h2><ul>
<li>所有网络接口都从统一的类调用，如HttpProxy。</li>
<li>网络接口的具体实现，按照业务划分到不同的类中，如“<strong>UserHttpHandler</strong>”、“<strong>CommentHttpHandler</strong>”。</li>
</ul>
<p>其实，按照面向对象的原则，就是接口代理类<strong>HttpProxy</strong>拥有若干个按照业务划分的接口（Interface），这些接口的所有方法组成了网络层的不同的Http请求。如下图：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_ios_http_proxy_1_1.jpg" alt="image"></p>
<p>那么，调用的时候，所有接口都用HttpProxy调用，如：</p>
<pre><code><span class="comment">//实际调用的是UserHttpHandler类的方法</span>
<span class="attr_selector">[[HttpProxy sharedInstance]</span> <span class="tag">getUserWithID</span>:@<span class="tag">100</span>];

<span class="comment">//实际调用的是CommentHttpHandler类的方法</span>
<span class="attr_selector">[[HttpProxy sharedInstance]</span> <span class="tag">getCommentsWithDate</span><span class="pseudo">:date</span>];
</code></pre><h2 id="关键">关键</h2><p>根据前面的描述，我们可以得出，关键就是：<strong>消息转发（Message Forward）</strong></p>
<p>Objective-C里面没有我们传统的“方法调用”，取而代之的是“消息”，所有的方法都是通过向对象发送“消息”实现调用的。而这个机制，也就为我们的实现提供了方便。</p>
<p>也就是说：我们要将发给“<strong>HttpProxy</strong>”的消息，让HttpProxy转发给真正能接受这个消息的对象，HttpProxy就是个<strong>代理</strong>。</p>
<p>苹果已经给我们提供了这个“代理”类了-NSProxy。</p>
<h2 id="NSProxy">NSProxy</h2><p>什么是NSProxy：</p>
<ul>
<li>NSProxy没有父类，是顶级类(根类)，跟NSObject同等地位。</li>
<li>NSProxy和NSObject都实现了“<strong>NSObject</strong> Protocol”。</li>
<li>NSProxy设计时就是以“抽象类”设计的，专门为<strong>转发消息</strong>而生。</li>
</ul>
<p>实现要求:</p>
<ol>
<li>继承NSProxy的子类要实现自己的初始化方法，如“init”、“initWith”。</li>
<li>重写“<strong> - forwardInvocation: </strong>”和“<strong> - methodSignatureForSelector: </strong>”方法，完成消息转发。</li>
</ol>
<p>详细内容参考Apple的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSProxy_Class/index.html#//apple_ref/occ/instm/NSProxy/forwardInvocation:" target="_blank" rel="external">文档</a>。</p>
<h2 id="实现">实现</h2><h3 id="定义">定义</h3><p>先不管HttpProxy，咱们看看具体的接口，先举两个例子：</p>
<pre><code><span class="comment">//UserHttpHandler.h</span>
<span class="comment">//用户相关接口</span>
<span class="variable">@protocol</span> UserHttpHandler &lt;NSObject&gt;
- (void)<span class="attribute">getUserWithID</span>:(NSNumber *)userID;
<span class="variable">@end</span>

<span class="comment">//CommentHttpHandler.h</span>
<span class="comment">//评论相关接口</span>
<span class="variable">@protocol</span> CommentHttpHandler &lt;NSObject&gt;
- (void)<span class="attribute">getCommentsWithDate</span>:(NSDate *)date;
<span class="variable">@end</span>
</code></pre><p>好的，接口有了，我们的HttpProxy类应该“实现”了这两个接口。<br>然后，最好是单例类，所以还要有个获取单例的方法。<br>最后，还需要一个向HttpProxy注册具体实现了接口Protocol的方法。</p>
<p>所以，HttpProxy应该是这个样子的：</p>
<pre><code><span class="comment">//HttpProxy.h</span>

<span class="comment">//1. 继承了NSproxy。 2. “实现”了网络接口Protocol</span>
<span class="annotation">@interface</span> <span class="string">HttpProxy :</span> NSProxy &lt;UserHttpHandler, CommentHttpHandler&gt;

<span class="comment">//获取单例</span>
+ (instancetype)sharedInstance;

<span class="comment">//注册具体实现类</span>
- (<span class="typename">void</span>)<span class="string">registerHttpProtocol:</span>(Protocol *)httpProtocol <span class="string">handler:</span>(id)handler;

<span class="annotation">@end</span>
</code></pre><h3 id="找到消息对应的实现类对象">找到消息对应的实现类对象</h3><p>如何在HttpProxy做消息转发时，找到某个消息对应的真正的实现类对象呢？</p>
<p>最好的办法就是保存每个接口方法到其实现类对象的映射，可以用Dictionary保存，关系如下图：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_ios_http_proxy_1_2.jpg" alt="image"></p>
<p>所以，<strong>registerHttpProtocol:handler:</strong>方法的职责就是：</p>
<ol>
<li>遍历Protocol的所有方法（利用Objective-C的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html" target="_blank" rel="external">Runtime功能</a>）。</li>
<li>保存Protocol所有方法到实现类的对象的映射关系。（用方法的字符串表示作为key，实现类对象为value）</li>
</ol>
<p>所以，HttpProxy应该持有一个Dictionary的实例，用于保存映射关系，HttpProxy的实现部分如：</p>
<pre><code><span class="comment">//HttpProxy.m</span>

<span class="variable">@interface</span> HttpProxy ()
<span class="comment">//保存映射关系的字典。</span>
<span class="variable">@property</span>(strong, nonatomic) NSMutableDictionary *selToHandlerMap;
<span class="variable">@end</span>
</code></pre><p>注册方法实现如下：</p>
<pre><code>- (<span class="type">void</span>)registerHttpProtocol:(<span class="type">Protocol</span> *)httpProtocol handler:(id)handler {
    unsigned <span class="type">int</span> numberOfMethods = <span class="number">0</span>;

    //<span class="type">Get</span> all methods <span class="keyword">in</span> protocol
    struct objc_method_description *methods = protocol_copyMethodDescriptionList(
            httpProtocol, <span class="type">YES</span>, <span class="type">YES</span>, &amp;numberOfMethods);

    //<span class="type">Register</span> protocol methods
    <span class="keyword">for</span> (unsigned <span class="type">int</span> i = <span class="number">0</span>; i &lt; numberOfMethods; i++) {
        struct objc_method_description <span class="keyword">method</span> = methods[i];
        [_selToHandlerMap setValue:handler forKey:<span class="type">NSStringFromSelector</span>(<span class="keyword">method</span>.name)];
    }
}
</code></pre><h3 id="实现消息的转发">实现消息的转发</h3><p>我们已经可以注册接口、保存映射关系了，剩下的就是重写NSProxy的两个方法，以实现消息的转发，至于这两个方法具体作用是什么，读者可以自行查阅相关资料。如下：</p>
<pre><code><span class="comment">//HttpProxy.m</span>

<span class="comment">//获取Method signature</span>
- (NSMethodSignature *)<span class="string">methodSignatureForSelector:</span>(SEL)sel {

    <span class="comment">//获取method的字符串表示</span>
    NSString *methodsName = NSStringFromSelector(sel);

    <span class="comment">//查找对应实现类对象</span>
    id handler = [_selToHandlerMap <span class="string">valueForKey:</span>methodsName];

    <span class="comment">//再次检查handler是否可以相应此消息</span>
    <span class="keyword">if</span> (handler != nil &amp;&amp; [handler <span class="string">respondsToSelector:</span>sel]) {
        <span class="keyword">return</span> [handler <span class="string">methodSignatureForSelector:</span>sel];
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> [<span class="keyword">super</span> <span class="string">methodSignatureForSelector:</span>sel];
    }
}

<span class="comment">//转发方法消息</span>
- (<span class="typename">void</span>)<span class="string">forwardInvocation:</span>(NSInvocation *)invocation {
    NSString *methodsName = NSStringFromSelector(invocation.selector);
    id handler = [_selToHandlerMap <span class="string">valueForKey:</span>methodsName];

    <span class="keyword">if</span> (handler != nil &amp;&amp; [handler <span class="string">respondsToSelector:</span>invocation.selector]) {
        [invocation <span class="string">invokeWithTarget:</span>handler];
    } <span class="keyword">else</span> {
        [<span class="keyword">super</span> <span class="string">forwardInvocation:</span>invocation];
    }
}
</code></pre><h2 id="Example">Example</h2><p>看看如何使用HttpProxy：</p>
<pre><code><span class="comment">//初始化，注册Protocol对应的实现类对象</span>
<span class="attr_selector">[[HttpProxy sharedInstance]</span> <span class="tag">registerHttpProtocol</span>:@<span class="tag">protocol</span>(UserHttpHandler) <span class="tag">handler</span>:<span class="attr_selector">[UserHttpHandlerImp new]</span>];
<span class="attr_selector">[[HttpProxy sharedInstance]</span> <span class="tag">registerHttpProtocol</span>:@<span class="tag">protocol</span>(CommentHttpHandler) <span class="tag">handler</span>:<span class="attr_selector">[CommentHttpHandlerImp new]</span>];

<span class="comment">//调用</span>
<span class="attr_selector">[[HttpProxy sharedInstance]</span> <span class="tag">getUserWithID</span>:@<span class="tag">100</span>];
<span class="attr_selector">[[HttpProxy sharedInstance]</span> <span class="tag">getCommentsWithDate</span>:<span class="attr_selector">[NSDate new]</span>];
</code></pre><h2 id="总结">总结</h2><p>所有的代码及示例都提交到Github了，<a href="https://github.com/zekunyan/HttpProxyExample" target="_blank" rel="external">HttpProxyExample</a>。</p>
<p>总的来说，就是利用Objective-C的“消息”机制，继承NSProxy抽象类，实现自己定义的转发机制，将网络接口层的各个方法的实现与声明分离，提升项目代码的可维护性，更加模块化。如下图表示:</p>
<p><img src="http://zorrochen.qiniudn.com/blog_ios_http_proxy_1_3.jpg" alt="image"></p>
<p>以上，就是我自己在项目中，利用NSProxy设计并实现的网络接口层结构。💪</p>
<p>从了解NSProxy、Runtime到设计、实现出这个网络层架构，着实花了点时间，收获真是不少。其实像这种纯代码层次的重构，很多人会觉得“吃力不讨好”😨，但我觉得，正是这样，才能真正让自己提升。</p>
<p>代码是具有美感的！嗯！😝</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSProxy_Class/index.html#//apple_ref/occ/instm/NSProxy" target="_blank" rel="external">NSProxy Class Reference</a></li>
<li><a href="http://objectivetoast.com/2014/05/12/nsproxy-nsobjects-lesser-known-sibling/" target="_blank" rel="external">NSProxy, NSObject’s Lesser-Known Sibling</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html" target="_blank" rel="external">Objective-C Runtime Programming Guide</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>之前在做项目的时候，所有业务的网络接口方法，全部都写在了一个文件里面，一开始还好，毕竟每个方法的代码也只是十几行，增加、修改也比较容易。但是随着接口的增多，这个文件慢慢居然超过了1000行，里面几十个方法都写在一起，实在是不好维护。  ]]>
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Effective-Objective-C-读书笔记-Item-3]]></title>
    <link href="http://tutuge.me/2015/02/14/Effective-Objective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Item-3/"/>
    <id>http://tutuge.me/2015/02/14/Effective-Objective-C-读书笔记-Item-3/</id>
    <published>2015-02-14T08:51:51.000Z</published>
    <updated>2015-02-14T10:30:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>item 3讲的是Objective-C里面的“字面量语法”-“Literal Syntax”，个人觉得非常有用。</p>
<h2 id="Item_3_-_Prefer_Literal_Syntax_over_the_Equivalent_Methods">Item 3 - Prefer Literal Syntax over the Equivalent Methods</h2><p>本节讲了Objective-C中的“字面量语法”，并且建议我们更多的使用这种语法，而不是使用传统的等价的函数方法。</p>
<h2 id="引子">引子</h2><p>当我们使用Objective-C编程的时候，总会经常使用到几种Foundation框架中的基本类，如NSString、NSNumber、NSArray、NSDictionary，或者是它们的子类。例如，当我们想创建一个字符串的时候，会这么写：</p>
<pre><code>NSString *<span class="keyword">str</span> = @<span class="string">"a string"</span>;
</code></pre><p>不知道各位写这句的时候有没有觉得奇怪？为什么不用先“alloc”，再“initWithXXX”这么来创建呢。是的，这里创建字符串，就用到了Objective-C提供的“字面量语法”-“Literal Syntax”，而这种语法的“标志”就是“@”符号。<br>有了字面量语法，我们就不用每次创建一些基本类型的时候，写一大堆alloc、init了。</p>
<h2 id="NSNumber">NSNumber</h2><p>字符串可以用字面量语法创建，数字类NSNumber肯定也可以，如下：</p>
<pre><code>NSNumber <span class="keyword">*</span>intNum = <span class="comment">@1;</span>
NSNumber <span class="keyword">*</span>floatNum = <span class="comment">@1.1f;</span>
NSNumber <span class="keyword">*</span>doubleNum = <span class="comment">@1.1;</span>
NSNumber <span class="keyword">*</span>boolNum = <span class="comment">@YES;</span>
NSNumber <span class="keyword">*</span>charNum = <span class="comment">@'a';</span>

//不用字面量语法
NSNumber <span class="keyword">*</span>intNumber = [[NSNumber alloc] initWithInt:1];
</code></pre><p>看，是不是很方便~</p>
<h2 id="NSArray">NSArray</h2><h3 id="创建">创建</h3><p>数组算是最常用的一种数据结构了，如果没有字面量语法，创建数组可能是这样：</p>
<pre><code><span class="constant">NSArray </span>*numbers = [[<span class="constant">NSArray </span>alloc] <span class="symbol">initWithObjects:</span>
    <span class="variable">@1</span>, <span class="variable">@1</span>.<span class="number">1</span>, <span class="variable">@2</span>.0f, <span class="variable">@YES</span>, <span class="keyword">nil</span>];
</code></pre><p>用字面量语法的话，就是这样：</p>
<pre><code>NSArray <span class="variable">*numbers</span> = <span class="variable">@[</span><span class="variable">@1</span>, <span class="variable">@1</span><span class="number">.1</span>, <span class="variable">@2</span><span class="number">.0</span>f, <span class="variable">@YES</span>];
</code></pre><h3 id="存取值">存取值</h3><p>创建了数组，肯定要从数组里面取值，用NSArray的方法就是这样：</p>
<pre><code><span class="comment">//取</span>
NSNumber <span class="variable">*aNumber</span> = [numbers objectAtIndex:<span class="number">2</span>];
<span class="comment">//存</span>
NSMutableArray <span class="variable">*mutableArray</span> = [[NSMutableArray alloc] initWithArray:
    <span class="variable">@[</span><span class="variable">@1</span>, <span class="variable">@2</span>, <span class="variable">@3</span>]];
[mutableArray replaceObjectAtIndex:<span class="number">1</span> withObject:<span class="variable">@4</span>];
</code></pre><p>跟C语言、Java这些语法很不一样啊，人家都是通过中括号“[]”直接用下标取值就可以。有了字面量同语法，Objective-C也可以这样:</p>
<pre><code><span class="comment">//取</span>
NSNumber <span class="variable">*aNumber</span> = numbers[<span class="number">2</span>];
<span class="comment">//存</span>
NSMutableArray <span class="variable">*mutableArray</span> = [[NSMutableArray alloc] initWithArray:
    <span class="variable">@[</span><span class="variable">@1</span>, <span class="variable">@2</span>, <span class="variable">@3</span>]];
mutableArray[<span class="number">1</span>] = <span class="variable">@4</span>;
</code></pre><h3 id="要注意的地方">要注意的地方</h3><p>传统的通过“initWithObjects”方法创建数组的时候，是根据最后的“nil”判断数组是否结束的，也就是说，用于初始化数组的元素中有“nil”值也不会导致异常（Exception），如下语句：</p>
<pre><code><span class="built_in">NSNumber</span> *number1 = @<span class="number">1</span>;
<span class="built_in">NSNumber</span> *number2 = <span class="literal">nil</span>; <span class="comment">//空指针</span>
<span class="built_in">NSNumber</span> *number3 = @<span class="number">3</span>;

<span class="comment">//创建</span>
<span class="built_in">NSArray</span> *numbers = [[<span class="built_in">NSArray</span> alloc] initWithObjects:
    number1, number2, number3, <span class="literal">nil</span>];

<span class="comment">//输出为1，因为number2，创建到number2就截止了</span>
<span class="built_in">NSLog</span>(<span class="string">@"numbers count: %d"</span>, numbers<span class="variable">.count</span>);
</code></pre><p>但是，如果用字面量语法创建，就是出问题：</p>
<pre><code>NSNumber <span class="keyword">*</span>number1 = <span class="comment">@1;</span>
NSNumber <span class="keyword">*</span>number2 = nil;
NSNumber <span class="keyword">*</span>number3 = <span class="comment">@3;</span>

//创建出现异常！！！
NSArray <span class="keyword">*</span>numbers = <span class="comment">@[number1, number2, number3];</span>

NSLog(<span class="comment">@"numbers count: %d", numbers.count);</span>
</code></pre><p>因为字面量语法只是单纯的将中括号中的元素全部加到数组中，但是，Objective-C中的数组是不可以存放nil值的，所以程序会运行时抛出异常。    </p>
<h2 id="NSDictionary">NSDictionary</h2><h3 id="创建-1">创建</h3><p>如果不用字面量语法创建字典，传统的创建函数简直令人匪夷所思：</p>
<pre><code><span class="comment">// number1-&gt;@1</span>
<span class="comment">// number2-&gt;@2</span>
<span class="built_in">NSDictionary</span> *dict = [[<span class="built_in">NSDictionary</span> alloc] initWithObjectsAndKeys:
    @<span class="number">1</span>, <span class="string">@"number1"</span>, @<span class="number">2</span>, <span class="string">@"number2"</span>, <span class="literal">nil</span>];
</code></pre><p>是不是很奇怪，<strong>value在前面，key在后面</strong></p>
<p>所以，还是用新的语法吧：</p>
<pre><code>NSDictionary *dict = @{@<span class="string">"number1"</span> : <span class="localvars">@1</span>, @<span class="string">"number2"</span> : <span class="localvars">@2</span>}<span class="comment">;</span>
</code></pre><p>这样才符合“常识”嘛，key在前，value在后面，跟JSON的定义一样。  </p>
<h3 id="存取值-1">存取值</h3><p>取值的语法跟NSArray的语法很想，只不过是将下标数字变成了key：</p>
<pre><code><span class="comment">//传统</span>
NSNumber *number1 = [dict <span class="string">objectForKey:</span>@<span class="string">"number1"</span>];
[dict <span class="string">setValue:</span>@<span class="number">5</span> <span class="string">forKey:</span>@<span class="string">"number1"</span>];

<span class="comment">//字面量语法</span>
NSNumber *number2 = dict[@<span class="string">"number1"</span>];
dict[@<span class="string">"number1"</span>] = @<span class="number">6</span>;
</code></pre><h3 id="注意">注意</h3><p>需要注意的地方，跟创建数组一样，NSDictionary的value不能为nil值，否则会抛出异常。</p>
<h2 id="总结">总结</h2><p>总的来说，使用字面量语法可以让代码更加清晰、简单，毕竟，更少的代码，有时候意味着更少的错误。      </p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>item 3讲的是Objective-C里面的“字面量语法”-“Literal Syntax”，个人觉得非常有用。</p>
<h2 id="Item_3_-_Prefer_Literal_Syntax_over_the_Equivale]]>
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="笔记" scheme="http://tutuge.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="翻译" scheme="http://tutuge.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Effective-Objective-C-读书笔记-Item-2]]></title>
    <link href="http://tutuge.me/2015/02/06/Effective-Objective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Item-2/"/>
    <id>http://tutuge.me/2015/02/06/Effective-Objective-C-读书笔记-Item-2/</id>
    <published>2015-02-06T08:43:46.000Z</published>
    <updated>2015-03-05T05:41:18.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>第二弹来了。</p>
<h2 id="Item_2_-_Minimize_Importing_Headers_in_Headers">Item 2 - Minimize Importing Headers in Headers</h2><p>这一节讲的是尽量在一个头文件中减少其它头文件的引入。</p>
<h2 id="头文件">头文件</h2><p>Objective-C和C语言、C++很像，都将类的实现与声明分开，用.h后缀名文件表示声明文件，用.m文件实现类。当要用到这个类的时候，只需要引入头文件即可，至于编译器、运行时是如何知道头文件里面的类对应的实现在哪里，在这了不做说明。一下用例子说明，先看看下面的类：</p>
<pre><code><span class="comment">//Wheel.h</span>
<span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span>

<span class="comment">//车轮类</span>
<span class="class"><span class="keyword">@interface</span> <span class="title">Wheel</span> : <span class="title">NSObject</span></span>
<span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *manufacturer;
<span class="keyword">@property</span>(<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) NSUInteger radius;
<span class="keyword">@end</span>
</code></pre><p>第二个类 </p>
<pre><code><span class="comment">//Engine.h</span>
<span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span>

<span class="comment">//发动机类</span>
<span class="class"><span class="keyword">@interface</span> <span class="title">Engine</span> : <span class="title">NSObject</span></span>
<span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *manufacturer;
<span class="keyword">@property</span>(<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) NSUInteger power;
<span class="keyword">@end</span>
</code></pre><p>然后就是车类Car：</p>
<pre><code><span class="comment">//Car.h</span>
<span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span>

<span class="comment">//汽车类，只有一个轮子，不要奇怪=。=</span>
<span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span>
<span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) Wheel *wheel;
<span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) Engine *engine;
<span class="keyword">@end</span>
</code></pre><p>注意到少了什么东西没有？<br>是的，写过C语言、C++的童鞋一下就能发现，Car类没有引入Engine和Wheel的头文件，肯定会编译出错的，因为编译器不知道Engine、Wheel类是啥。<br>那好，我们加上下面两行：</p>
<pre><code><span class="id">#import</span> <span class="string">"Wheel.h"</span>
<span class="id">#import</span> <span class="string">"Engine.h"</span>
</code></pre><p>嗯。这样就不会出错了。但是这样真的好吗？Objective-C给我们提供了@class关键字，就是来解决这个问题的。</p>
<h2 id="前置声明（forward_declaration）">前置声明（forward declaration）</h2><p>何为前置声明？看看下面的Car类的头文件例子。</p>
<pre><code><span class="comment">//Car.h</span>
<span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span>

<span class="comment">//前置声明</span>
<span class="class"><span class="keyword">@class</span> <span class="title">Wheel</span>;</span>
<span class="class"><span class="keyword">@class</span> <span class="title">Engine</span>;</span>

<span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span>
<span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) Wheel *wheel;
<span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) Engine *engine;
<span class="keyword">@end</span>
</code></pre><p>@class就是类的前置声明（forward declaration），就是告诉编译器“嗨，不用找了，Wheel类和Engine类是肯定存在的，用到的时候再找”。有了前置声明，我们就不用显式的引入Wheel类和Engine类了。</p>
<p>当然，在Car类的实现文件.m文件中，我们还是要显式的引入Wheel和Engine类的，因为在这里我们要具体用到这两个类了，当然要知道类的细节。</p>
<h3 id="为何不要import？">为何不要import？</h3><p>为什么不直接import呢？因为如果直接用import引入Wheel和Engine的声明，那么任何import引入了Car类的文件，也同时会引入Wheel、Engine类的声明，而且最终我们可能并不一定会直接跟Wheel、Engine类打交道，这样不就引入了“没有用”的类了吗？而且这样做很可能造成文件引入成“环”。 </p>
<p>虽然import可以避免重复声明造成编译出错，传统的C语言、C++在声明的时候也可以通过如下方式避免重复声明：</p>
<pre><code><span class="comment">#ifndef _WHEEL_H_</span>
<span class="comment">#define _WHEEL_H_</span>

//声明内容<span class="keyword">...</span>

<span class="comment">#endif</span>
</code></pre><p>但是既然Objective-C有@class这种前置声明的办法，为何不用呢。</p>
<h2 id="必须用import的时候">必须用import的时候</h2><p>当然，@class这样的前置声明并不能解决一切头文件引入的问题，如下这样的类，就必须要用import：</p>
<pre><code><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span>

<span class="comment">//Car 的声明</span>
<span class="preprocessor">#import <span class="title">"Car.h"</span></span>

<span class="comment">//Driver protocol的定义</span>
<span class="preprocessor">#import <span class="title">"Driver.h"</span></span>

<span class="class"><span class="keyword">@interface</span> <span class="title">BigCar</span> : <span class="title">Car</span> &lt;<span class="title">Driver</span>&gt;</span>
<span class="keyword">@end</span>
</code></pre><p>是的，当类需要被继承、定义的protocol需要实现的时候，就需要import相关的头文件了（protocol的实现如果跟类的使用者没有关联，可以定义在类的实现文件中的“扩展category”中）,当然，还有@protocol这样的protocol的前置声明，怎么用就留给读者自己查阅相关资料了。</p>
<h2 id="总结">总结</h2><p>大费周章的讲了这么多，其实目的就是一个：尽量少在头文件里面引入其他头文件。</p>
<p>最终的目的就是<strong>只暴露最少的细节</strong>。</p>
<p>写代码有段时间了，一直都在琢磨这句话，希望读者也能好好体会~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>第二弹来了。</p>
<h2 id="Item_2_-_Minimize_Importing_Headers_in_Headers">Item 2 - Minimize Importing Headers in Headers</h2>]]>
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="笔记" scheme="http://tutuge.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="翻译" scheme="http://tutuge.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Effective-Objective-C-读书笔记-Item-1]]></title>
    <link href="http://tutuge.me/2015/02/05/Effective-Objective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Item-1/"/>
    <id>http://tutuge.me/2015/02/05/Effective-Objective-C-读书笔记-Item-1/</id>
    <published>2015-02-04T17:17:08.000Z</published>
    <updated>2015-02-05T14:09:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>一直都在做项目，没什么时间作总结，感觉很不是滋味。现在放假了，嗯，终于有时间了~~哈哈（天生程序猿一枚好不好=。=）<br>最近开始读英文版的Effective Objective-C 2.0，觉得不错，就总结些东西，分享给各位读者吧。</p>
<h2 id="Item_1_-_Familiarize_Yourself_with_Objective-C’s_Roots">Item 1 - Familiarize Yourself with Objective-C’s Roots</h2><p>第一章的目的，就是让大家熟悉Objective-C，自然，标题的意思也就是“了解Objective-C的基本概念”，不多说，开写。</p>
<h2 id="消息与运行时">消息与运行时</h2><p>总的来说，Objective-C跟C++、Java这些面向对象的语言是非常相似的，但是还是有许多不同的地方。如果你是第一次看到Objective-C的语法，一定觉得非常奇怪，因为Objective-C使用的是基于消息（Message）的框架，而不是传统的方法、函数调用。如下：</p>
<pre><code><span class="comment">//Objective-C</span>
Person *person = [Person <span class="keyword">new</span>];
[person <span class="string">setName:</span>@<span class="string">"tutuge"</span> <span class="string">age:</span><span class="number">24</span>];

<span class="comment">//Java</span>
Person person = <span class="keyword">new</span> Person();
person.setNameAndAge(<span class="string">"tutuge"</span>, <span class="number">24</span>);

<span class="comment">//C++</span>
Person *person = <span class="keyword">new</span> Person;
person-&gt;setNameAndAge(<span class="string">"tutuge"</span>, <span class="number">24</span>);
</code></pre><p>很奇怪是不是，各种中括号。但是我觉得，Objective—C这么设计就是为了时刻提醒你，“我是基于消息机制的！”。消息，的确是Objective-C与Java、C++这种语言最大的不同，而且，这种不同远不止在语法上面。简单来说如下两点：</p>
<ul>
<li><strong>基于消息的调用：</strong> 所有的函数调用都是在“运行时”决定的。</li>
<li><strong>基于方法的调用：</strong> 所有的函数调用都是在“编译时”决定的，就是编译器编译时决定的。</li>
</ul>
<p>其实，连被调方法的对象类型，都是在运行时决定的。所以说，Objective-C的运行时系统，担负了绝大部分的工作。这么设计的优点，举个例子，就是当运行时系统升级时，原有的代码不用重新编译即可“享受”升级带来的好处。</p>
<h2 id="C的超集">C的超集</h2><p>Objective-C是C语言的超集，所以C语言所具有的一切特性，Objective-C都可以兼容，充分理解C语言的内存模型，对理解Objective-C很有帮助。如下：</p>
<pre><code>NSString *<span class="keyword">str</span> = @<span class="string">"a string"</span>;
</code></pre><p>这一行代码跟C语言没有什么不同，（忽略@符号=。=），原理跟C语言也是一致的，就是str指针是NSString类型的指针，指向了一块存着字符串“a string”的内存区域。不同的是，在Objective-C里，所有的对象只可以声明为指针类型，所以如下代码是不合理的：</p>
<pre><code>NSString <span class="keyword">str</span>;
</code></pre><p>为了更充分的理解，咱们看看如下例子：</p>
<pre><code>NSString <span class="keyword">*</span>str1 = <span class="comment">@"a string";</span>
NSString <span class="keyword">*</span>str2 = str1;
</code></pre><p>熟悉C语言的朋友应该知道这是怎么回事，内存当中只有一块区域储存着“a string”这个字符串，str1、str2都是指向着这个区域的字符串指针。如下图：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_effective_objective_c_item_1_1.jpg" alt="image"></p>
<ul>
<li>str1、str2都在栈内存上分配的，就是字符串（NSString）类型的指针。</li>
<li>“a string”字符串实际储存在堆内存上。</li>
<li>str1、str2均指向同一块内存区域。</li>
</ul>
<p>此处的栈内存、堆内存跟C语言中的概念也是一样的，不同的是，在Objective-C中，我们不用手动去malloc、free内存，Objective-C使用内存计数计数帮我们管理内存。</p>
<h2 id="结构体，基本类型">结构体，基本类型</h2><p>在Objective-C中，并不是所有的变量都是指针类型的，像int、float、double这些依旧是传统的“栈上分配”的，当然，还有结构体struct、枚举enum、联合union等。如：</p>
<pre><code><span class="title">CGPoint</span> point = CGPointMake(<span class="number">10</span>, <span class="number">10</span>);
<span class="title">CGRect</span> frame = CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">10</span>);
</code></pre><p>这的CGPoint、CGRect都是结构体，但是都是直接在栈上分配内存的，以减少过度使用Objective-C类型的类（减少运行时的压力），各位读者使用的时候要注意。</p>
<h2 id="总结">总结</h2><p>零散的说了一些Objective-C的特点，远远不足以讲明白Objective-C，我这只是根据Effective Objective-C这本书给个引子，还是推荐Apple的官方教程、文档，要想掌握扎实，还是要一步一步来~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>一直都在做项目，没什么时间作总结，感觉很不是滋味。现在放假了，嗯，终于有时间了~~哈哈（天生程序猿一枚好不好=。=）<br>最近开始读英文版的Effective Objective-C 2.0，觉得不错，就总结些东西，分享给各位读者吧。]]>
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="笔记" scheme="http://tutuge.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="翻译" scheme="http://tutuge.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS项目的目录结构-原创]]></title>
    <link href="http://tutuge.me/2015/02/01/iOS%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84-%E5%8E%9F%E5%88%9B/"/>
    <id>http://tutuge.me/2015/02/01/iOS项目的目录结构-原创/</id>
    <published>2015-01-31T18:27:21.000Z</published>
    <updated>2015-02-03T17:01:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>这段时间一直在做iOS的项目（<a href="https://itunes.apple.com/cn/app/qing-ju-yin-le-quan-guo-zui/id913235479?mt=8" target="_blank" rel="external">青桔音乐App</a>），随着代码量的上升，逐渐意识到项目的整体目录结构划分是多么重要，清晰的目录结构，能够更好的应对新的需求，更容易重构。虽然一直都是一个人在做=。=，但是还是深深地体会到目录结构的重要性。</p>
<h2 id="例子">例子</h2><p>说再多都不如来个例子实在，如下：(VC指的是viewController)</p>
<pre><code>|---General
    |---AppDelegate
    |---Application
    |---Constant
    |---UI
        |---View
        |---VC
        |---Common
    <span class="keyword">...</span>
|---Entity
    |---BaseEntity
    <span class="keyword">...</span>
|---Http
    |---Api
    |---Util
    |---CodeHandler
    |---ErrorHandler
    |---RequestHandler
    <span class="keyword">...</span>
|---DB
    |---DBHelper
    |---DBService
    <span class="keyword">...</span>
|---Util
    |---StringUtil
    |---NumberUtil
    |---TimeUtil
    <span class="keyword">...</span>
|---Service
    |---AccountService
    |---ShareService
    <span class="keyword">...</span>
|---Lib
    |---Umeng
    |---QQSDK
    |---SVProgressHUD
    <span class="keyword">...</span>
|---Module
    |---Login
        |---View
        |---VC
        <span class="keyword">...</span>
    |---Comment
    |---Feeds
    <span class="keyword">...</span>
</code></pre><p>乍一看好多，别被吓到=。=，容我细细讲解。</p>
<h2 id="详细讲解">详细讲解</h2><h3 id="General">General</h3><p>General好理解，放的就是如AppDelegate之类的、项目中最普通的、最常用的组件。</p>
<p><strong>AppDelegate</strong>:<br>App的Delegate类实现，这个必须有，就不用说了吧。  </p>
<p><strong>Application</strong>:<br>如果自定义实现了Application类，就放在这里。  </p>
<p><strong>Constant</strong>:<br>顾名思义，常量，项目用到的所有公共常量，如enum枚举类型的、Notification的Tag，常用的颜色、字符串等等等，都可以按照自己的需求划分不同的Group，放到Constant里面。  </p>
<p><strong>UI</strong>:<br>项目中自定义的UIView、UIViewController子类，和自定义的对UI的扩展，如Category之类的代码，就对应放在UI下的View、VC和Common中。</p>
<p>如还有其他的通用组件，也不妨放到这里，做统一的管理。</p>
<hr>
<h3 id="Entity">Entity</h3><p>Entity，也有人喜欢叫Model（关于Entity和Model的区别，推荐看看<a href="http://blogsh.de/2011/09/08/models-vs-entities/" target="_blank" rel="external">这篇文章</a>，个人觉得研究研究Entity和Model概念的区别还是很有好处的），就是程序中的“实体”，如一个用户、一条评论、一首歌等等，简单来说就是一个独立“个体”的集合、打包，具体的自己查查吧，网上一大堆的，感觉跟JavaBean的概念比较像。</p>
<p>通常来说，每个Entity类都比较简单，只包含若干个属性。但是有时候可能要做统一的处理，如，在从服务器取回的JSON数据解包成具体的Entity类，并且执行一系列初始化操作等等，所以可能要对所有的Entity类做统一处理。所以说，可以定制相应的BaseEntity基类，利用模板方法等办法，定制统一的初始化流程（好像扯远了=。=，这个后面会详细写篇东西分享给大家），BaseEntity就是放这些基类的东西的。</p>
<hr>
<h3 id="Http">Http</h3><p>这个Group里面放跟网络请求相关的东西，详细如下：</p>
<p><strong>Api</strong>:<br>互联网应用少不了跟服务器打交道的各种网络接口，所以我在项目中把所有的API对应的相对URL地址、参数注释要求等等都放在了这里，好统一管理。</p>
<p><strong>Util</strong>:<br>定义最基本的网络请求，如GET、POST、PUT等请求的基本封装，获取图片的基本封装。<br>一般来说就是定制统一的基本请求接口，对上层提供一致、稳定的服务，真正的网络请求，可以自己用iOS原生的Api写，也可以用AFNetworking等第三方库做封装，图片也可以灵活的用AFNetworking、SDWebImage这些优秀的库实现。还有就是，可以方便的统一对请求做处理，如错误处理、Http的Code、状态处理等等。还可以统一的增加请求参数，如统一为每个请求都增加用户的ID、token什么的。</p>
<p><strong>CodeHandler</strong><br>大部分的API设计都会有相应的状态码、Code，为了方便扩展，可以把这些处理Code的类单独放在这里。</p>
<p><strong>ErrorHandler</strong><br>这个就少不了了，对Http的错误进行单独处理，加Log什么的。</p>
<p><strong>RequestHandler</strong><br>这个Group里面放的是真正实现接口的类，如什么UserHttpHandler、CommentHttpHandler之类的，就是具体实现了接口调用、处理返回数据、回调的类。</p>
<p>Http里面的各个Group的类其实都是相互关联的，设计的时候可以定制统一的接口（Protocol），然后创建类实现（conform）这些接口，也就是面向接口的编程，以最大限度的减少接口层的各个职能之间的耦合，方便扩展。</p>
<hr>
<h3 id="DB">DB</h3><p>介于iOS的SQLite不是那么好用，所以非常有必要为操作数据库的类建立单独的地盘=。=  </p>
<p><strong>DBHelper</strong>:<br>放基础的操作数据库的类，如简单的查找、插入、更新、事务更新等等操作，为负载的数据库业务逻辑封装底层接口。比如对流行的FMDB进行封装等等。</p>
<p><strong>DBService</strong>:<br>这里放具体的数据库业务实现类，至于为什么叫“Service”，因为我也想不出什么好的名字了=。= 按照自己的业务逻辑组织即可。</p>
<hr>
<h3 id="Util">Util</h3><p>放常用的工具类的地方。如字符串操作的类StringUtil、时间计算格式化类TimeUtil等，按具体需求而定，这个就不用多说了吧。</p>
<hr>
<h3 id="Service">Service</h3><p>项目的需求多了，业务逻辑的代码就会越来越多，总不能都放在view controller里面吧。一些多处用到的，或者非常独立的业务代码，完全可以抽离出来，实现为单独的、跟界面无关的业务类。因为做的事很杂，所以干脆就叫Service了。<br><strong>AccountService</strong>、<strong>ShareService</strong>就是这种类。而且大部分的Service都应该是单例类，如<strong>AccountService</strong>类可能维护着程序运行期间的账户信息，<strong>ShareService</strong>对程序的分享功能做了统一处理等等，具体怎么用就随各位了。</p>
<hr>
<h3 id="Lib">Lib</h3><p>Lib，放各种第三方库，因项目需要修改过的第三方组件等，像什么友盟、QQSDK之类的就可以放这。当然，一些不会做改动的库最好还是用CocoaoPod做统一管理。</p>
<hr>
<h3 id="Module">Module</h3><p>终于讲到了最重要的地方。<br>iOS工程中最多的文件往往就是各种View、ViewController类，以前总是看到有人只创建两个Group，一个叫Views，另一个叫ViewControllers，然后所有的Views、ViewController都往里面塞，然后随着需求的增加，这两个Group也臃肿不堪。。。  </p>
<p><strong>办法总是有的。就是为工程划分模块-Module</strong><br>如何划分Module？我认为，可以按照以下两点建立：  </p>
<ol>
<li>以页面跳转分支划分。  </li>
<li>以功能划分。  </li>
</ol>
<p><strong>以页面跳转分支划分</strong><br>就是按照应用的页面设计与业务逻辑，从最顶级开始，一级一级页面往下跳转，找出其中的独立分支，归为一个Module模块。<br>举例来说，应用主界面有4个Tab页，就先分出四个Module，然后一级一级往下跳转，遇到分支就建立新的Module，如此递归的建立，就能大致划分出各个Module。当然，这么做是最粗糙的，还要根据情况，将不同的分支Module合并成一个Module，简化代码的组成。我在这只是提供个划分Module的方法，具体怎么设计就看各位读者了=。=</p>
<p><strong>以功能划分</strong><br>这个好理解，无非就是根据前期项目的功能模块划分工程的代码Module组成。如什么用户设置Module、评论Module、登录Module等等。</p>
<p>总的来数，就是要用Module将工程的代码分类管理，每个Module具有大致相同的结构，如都可能有本Module用到的View、ViewController，自定义的类Class等等，就是说，按照职能对代码划分，避免将所有的类都堆在一起，也好应对新的需求。</p>
<h2 id="总结">总结</h2><p>啰啰嗦嗦说了一大堆，想必各位都看烦了吧=。=刚开始写博客，写到一个地方，又会引出另一块，写着写着容易写偏了。<br>写之前我也大致搜了一下，发现网上相关的资料好少，但是实际的经验告诉我，项目工程的目录结构非常重要，无论是对开发还是对后期的维护，所以想着应该写篇东西，分享我自己的经验给大家，有啥问题，多提意见啊~~~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>这段时间一直在做iOS的项目（<a href="https://itunes.apple.com/cn/app/qing-ju-yin-le-quan-guo-zui/id913235479?mt=8" target="_blank" ]]>
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android开源库-LinkTextView-原创]]></title>
    <link href="http://tutuge.me/2014/11/02/LinkTextView-Android%E5%BC%80%E6%BA%90%E5%BA%93-%E5%8E%9F%E5%88%9B/"/>
    <id>http://tutuge.me/2014/11/02/LinkTextView-Android开源库-原创/</id>
    <published>2014-11-01T18:34:46.000Z</published>
    <updated>2015-02-03T17:00:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>近来因为项目的缘故，仔细研究了一下如何在Android的TextView里面绑定可以点击的链接，并且定制链接的颜色，包括正常状态、按下去时的文字、背景的颜色，当然，还有点击后的回调。</p>
<p>为了以后方便自己，也为了方便更多的人，就把这些封装成了一个简单的开源库，也算是我自己的<strong><em>第一个开源库</em></strong>吧。</p>
<h2 id="LinkTextView">LinkTextView</h2><p>名称：<a href="https://github.com/zekunyan/LinkTextView" target="_blank" rel="external">LinkTextView</a>。喜欢的话就Star一下吧。</p>
<h3 id="Example">Example</h3><p><img src="http://zorrochen.qiniudn.com/LinkTextView_Sample.gif" alt="image"></p>
<h3 id="功能：">功能：<br></h3><ol>
<li>可以方便的对TextView里面的文字增加可点击链接，并且绑定回调。</li>
<li>可以为每个链接<strong>单独</strong>设置<strong>文字</strong>、链接<strong>背景</strong>的<strong>正常</strong>、<strong>按下</strong>状态下的颜色。</li>
<li>可以为每个链接绑定任意类型的“附件”对象，作为点击链接时的回调参数。</li>
</ol>
<h2 id="讲解">讲解</h2><p>下面分重点讲解一下。</p>
<h3 id="1-_为文字增加可点击链接，绑定回调。">1. 为文字增加可点击链接，绑定回调。</h3><p>为文字增加链接，已经是老生常谈了，真是一搜一大把，不过在这里还是简单讲一下。</p>
<p>用过TextView应该都知道这个接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setText</span> <span class="params">(CharSequence text)</span></span></span><br></pre></td></tr></table></figure></p>
<p>其中CharSequence接口的子接口里面有Spannable，而由这个接口派生出来的类SpannableString，就是我们可以对TextView里面的文字做附加效果的原因。如改变颜色、增加超链接等，有兴趣的各位可以去仔细查查。下面简单的说说怎么加可点击的链接。</p>
<p><strong>首先创建SpannableString</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpannableString text = <span class="keyword">new</span> SpannableString(<span class="string">"LinkTextView dadada"</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>绑定ClickableSpan回调</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ClickableSpan clickableSpan = <span class="keyword">new</span> ClickableSpan() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//点击了链接，做你想干的事吧=。=</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">text.setSpan(clickableSpan, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>最后再setText</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textView.setText(text);</span><br></pre></td></tr></table></figure></p>
<p>看，绑定可以点击的链接就是这么简单。</p>
<h3 id="2-_改变正常、按下时的文字、链接背景颜色。">2. 改变正常、按下时的文字、链接背景颜色。</h3><p>往往系统默认的链接颜色是不能满足我们的需求的，所以最好能对链接的文字、背景的按下、松开时的颜色做定制。</p>
<p><strong><em>但是好坑=。=，Google居然没有为ClickableSpan增加按下时的回调</em></strong></p>
<p>那就只好自己造轮子了。</p>
<h4 id="首先">首先</h4><p>必须要能获取到链接按下时的回调，应该是onTouch什么的，于是，就查到了类：LinkMovementMethod。<br>在TextView中可以用方法：public final void setMovementMethod (MovementMethod movement)设定监听，而LinkMovementMethod类里面就可以监听到链接的onTouch！</p>
<p><strong>LinkMovementMethod的onTouch就是介个样子的</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span>	 <span class="title">onTouchEvent</span><span class="params">(TextView textView, Spannable spannable, MotionEvent event)</span></span></span><br></pre></td></tr></table></figure></p>
<p>于是，我们可以通过event来判断是按下还是移动等等操作。<br>但是问题是，这里的spannable是整个TextView全部的文字，所以，只能通过event里面的x、y坐标，找到具体点击的是哪个链接。这里，要感谢stack overflow上的大神的<a href="http://stackoverflow.com/questions/20856105/change-the-text-color-of-a-clickablespan-when-pressed" target="_blank" rel="external">帖子</a>。</p>
<p>具体的找点击链接的方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TouchableSpan <span class="title">getPressedSpan</span><span class="params">(TextView textView, Spannable spannable, MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取点击的x、y坐标</span></span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">    <span class="comment">//减去Padding</span></span><br><span class="line">    x -= textView.getTotalPaddingLeft();</span><br><span class="line">    y -= textView.getTotalPaddingTop();</span><br><span class="line">    <span class="comment">//加上滚动的偏移</span></span><br><span class="line">    x += textView.getScrollX();</span><br><span class="line">    y += textView.getScrollY();</span><br><span class="line">    <span class="comment">//获取第几行、以及偏移</span></span><br><span class="line">    Layout layout = textView.getLayout();</span><br><span class="line">    <span class="keyword">int</span> line = layout.getLineForVertical(y);</span><br><span class="line">    <span class="keyword">int</span> off = layout.getOffsetForHorizontal(line, x);</span><br><span class="line">    <span class="comment">//获取真正点击的链接</span></span><br><span class="line">    TouchableSpan[] link = spannable.getSpans(off, off, TouchableSpan.class);</span><br><span class="line">    TouchableSpan touchedSpan = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (link.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        touchedSpan = link[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> touchedSpan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到此，我们已经能获取到链接的点击状态，并且捕捉到具体点击的ClickableSpan。</p>
<h4 id="接着">接着</h4><p>就是改变链接的文字、背景颜色。</p>
<p>ClickableSpan的方法里面，除了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View widget)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>还有就是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDrawState</span><span class="params">(TextPaint textPaint)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>很明显，就是更新文字渲染效果的。我们用如下两个方法，就能实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span> <span class="params">(<span class="keyword">int</span> color)</span></span>;</span><br><span class="line">bgColor属性</span><br></pre></td></tr></table></figure></p>
<h4 id="最后">最后</h4><p>到目前为止，我们已经可以捕捉到链接的点击状态，能获取到真正的点击的链接，还有能刷新链接的颜色了，相信聪明的你一定能自己琢磨出来，怎么样实现文章开头的效果。=v=</p>
<h4 id="本文参考">本文参考</h4><ol>
<li>Android官方文档。</li>
<li>StackOverFlow的：<a href="http://stackoverflow.com/questions/20856105/change-the-text-color-of-a-clickablespan-when-pressed" target="_blank" rel="external">Change the text color of a ClickableSpan when pressed。</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>近来因为项目的缘故，仔细研究了一下如何在Android的TextView里面绑定可以点击的链接，并且定制链接的颜色，包括正常状态、按下去时的文字、背景的颜色，当然，还有点击后的回调。</p>
<p>为了以后方便自己，也为了方便更多的人，]]>
    </summary>
    
      <category term="Android" scheme="http://tutuge.me/tags/Android/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="开源" scheme="http://tutuge.me/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第一篇Blog]]></title>
    <link href="http://tutuge.me/2014/11/01/%E7%AC%AC%E4%B8%80%E7%AF%87Blog/"/>
    <id>http://tutuge.me/2014/11/01/第一篇Blog/</id>
    <published>2014-10-31T16:13:15.000Z</published>
    <updated>2015-02-13T15:46:42.000Z</updated>
    <content type="html"><![CDATA[<p>拖了很久，终于开始写博客了。<br>一直觉得自己的知识储备不够，一直都在学习，一直都在积累。（其实就是懒好吗=。=）</p>
<p>说点啥呢，想到啥就说啥吧~</p>
<p>从小就喜欢模型、乐高积木，喜欢拆东西，印象最深的就是把家里的高级录音机拆了，装不回去，塞到了床底下。。。</p>
<p>上了学之后，又开始捣鼓四驱车，自己做马达，绕线圈，家里零件一大堆，串联一堆电池，组装遥控车，唯一的遗憾，就是没有做成遥控飞机（没钱=、=）。</p>
<p>接着，家里有了电脑！！！这要感谢老爹，当时花了一万多，液晶显示器，刚上市的奔腾4啊！</p>
<p>于是，我又开始拆电脑。。。换显卡、超频，跑分，再超频，再跑分，3DMark就是俺的祖宗啊~</p>
<p>终于，走上了<strong>编程</strong>这条“<strong>不归路</strong>”，义无反顾，一直到了现在。</p>
<p>用Dev-C++折腾C语言，数据结构、算法，接着又是C++，Window API，QT（这个真觉得不错），MFC（软件课设），Java，Python，Android（上线了几个小应用，拿了Google全国大学生Android应用开发大赛华中地区三等奖），iOS（上线应用，青桔音乐），Linux，还有各种MySQL、MongoDB等数据库的纠结，看各种博客。。。</p>
<p>每天看的很多，想的也不少，但是终究不够精通，路还很长啊~</p>
<p>当然，最感谢的就是我的女朋友~陈因素~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>拖了很久，终于开始写博客了。<br>一直觉得自己的知识储备不够，一直都在学习，一直都在积累。（其实就是懒好吗=。=）</p>
<p>说点啥呢，想到啥就说啥吧~</p>
<p>从小就喜欢模型、乐高积木，喜欢拆东西，印象最深的就是把家里的高级录音机拆了，装不回去，塞到了床底下。]]>
    </summary>
    
      <category term="杂烩" scheme="http://tutuge.me/tags/%E6%9D%82%E7%83%A9/"/>
    
  </entry>
  
</feed>