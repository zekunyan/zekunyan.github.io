<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[土土哥的技术Blog]]></title>
  <subtitle><![CDATA[iOS,Android程序猿一枚,喜欢Mac、Linux、各种开源技术，各种语言]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://tutuge.me/"/>
  <updated>2015-07-25T11:31:34.000Z</updated>
  <id>http://tutuge.me/</id>
  
  <author>
    <name><![CDATA[燕泽堃]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[解决iOS项目的版本兼容问题-结合宏、Category和Runtime]]></title>
    <link href="http://tutuge.me/2015/07/25/compatibility-with-macro-category-and-runtime/"/>
    <id>http://tutuge.me/2015/07/25/compatibility-with-macro-category-and-runtime/</id>
    <published>2015-07-24T16:39:03.000Z</published>
    <updated>2015-07-25T11:31:34.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>最近，在做项目时，因为某种原因，突然要“适配”iOS6（也是醉了。。。），保证极少数的iOS6用户可以“用上”新的版本。哪怕界面上有瑕疵，只要功能正常就行。于是就只好花几天时间对iOS6进行紧急适配（心中一万头驼羊奔跑而过。。。）  </p>
<p>本文总结了一些常规的，和“非常规”的iOS项目向老版本兼容的办法，结合了<strong>宏定义</strong>、<strong>Category</strong>和<strong>Runtime</strong>，大家看着消遣一下就好哈~</p>
<a id="more"></a>
<h2 id="重点概念">重点概念</h2><p>首先强调一些概念。</p>
<h3 id="Deployment_Target_和_Base_SDK">Deployment Target 和 Base SDK</h3><p><strong>Deployment Target</strong><br>指的是你的APP能支持的最低系统版本，如要支持iOS6以上，就设置成iOS6即可。</p>
<p><strong>Base SDK</strong><br>指的是用来编译APP的SDK（Software Development Kit）的版本，一般保持当前XCode支持的最新的就好，如iOS8.4。SDK其实就是包含了所有的你要用到的头文件、链接库的集合，你的APP里面用的各种类、函数，能编译、链接成最后的安装包，就要靠它，苹果每次升级系统，新推出的各种API，也是在SDK里面。所以一般Base SDK肯定是大于等于Deployment Target的版本。</p>
<p><strong>区分</strong><br>既然Base SDK的版本大于等于Deployment Target的版本，那么就要小心了，因为<strong>“只要用到的类、方法，在当前的Base SDK版本里面存在，就可以<em>编译通过</em>！但是一旦运行APP的手机的系统版本低于这些类、方法的最低版本要求，APP就会Crash！”</strong>  </p>
<p>所以并不是说，能编译通过的，就一定能<em>运行成功</em>！还要在<em>运行时检查</em>！简单来说，就是如下图：</p>
<p><img src="http://7nj2iz.com1.z0.glb.clouddn.com/blog_compatibility-with-macro-category-and-runtime_1.png" alt="image"></p>
<h3 id="宏只在编译时生效！">宏只在编译时生效！</h3><p>宏定义只是纯粹的文本替换，只在编译时起作用。如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">if</span> __IPHONE_OS_VERSION_MIN_REQUIRED &gt;= 70000</span></span><br><span class="line">    NSLog(@<span class="string">"Tutuge"</span>);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>被宏定义包起来的代码是否会执行，在编译时就决定好了，无论你是用什么系统运行，宏定义再也没有什么卵用=。=</p>
<h2 id="编译时检查SDK版本，运行时检查系统版本">编译时检查SDK版本，运行时检查系统版本</h2><p>这个是最基本的适配手段。  </p>
<p>用到的宏如下：</p>
<ol>
<li><strong>__IPHONE_OS_VERSION_MAX_ALLOWED</strong>: 值等于Base SDK，即用于检查SDK版本的。</li>
<li><strong>__IPHONE_OS_VERSION_MIN_REQUIRED</strong>: 值等于Deployment Target，检查支持的最小系统版本。</li>
</ol>
<p>运行时检查系统版本：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([UIDevice currentDevice].systemVersion.floatValue &gt; <span class="number">8.0f</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假如我们现在想用iOS8新的<strong>UIAlertController</strong>来显示提示框，应该如下判断：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译时判断：检查SDK版本</span></span><br><span class="line"><span class="preprocessor">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt; 80000</span></span><br><span class="line">    <span class="comment">// 运行时判断：检查当前系统版本</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">UIDevice</span> currentDevice]<span class="variable">.systemVersion</span><span class="variable">.floatValue</span> &gt; <span class="number">8.0</span>f) &#123;</span><br><span class="line">        <span class="built_in">UIAlertController</span> *alertController =</span><br><span class="line">        [<span class="built_in">UIAlertController</span> alertControllerWithTitle:<span class="string">@"Tutuge"</span></span><br><span class="line">                                            message:<span class="string">@"Compatibility"</span></span><br><span class="line">                                     preferredStyle:<span class="built_in">UIAlertControllerStyleAlert</span>];</span><br><span class="line">        [alertController addAction:[<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@"Cancel"</span></span><br><span class="line">                                                            style:<span class="built_in">UIAlertActionStyleCancel</span></span><br><span class="line">                                                          handler:^(<span class="built_in">UIAlertAction</span> *action) &#123;</span><br><span class="line">                                                              <span class="built_in">NSLog</span>(<span class="string">@"Cancel"</span>);</span><br><span class="line">                                                          &#125;]];</span><br><span class="line">        [<span class="keyword">self</span> presentViewController:alertController animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 用旧的代替</span></span><br><span class="line">        <span class="built_in">UIAlertView</span> *alertView = [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"Tutuge"</span></span><br><span class="line">                                                            message:<span class="string">@"Compatibility"</span></span><br><span class="line">                                                           delegate:<span class="literal">nil</span></span><br><span class="line">                                                  cancelButtonTitle:<span class="string">@"Cancel"</span></span><br><span class="line">                                                  otherButtonTitles:<span class="literal">nil</span>];</span><br><span class="line">        [alertView show];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="preprocessor">#else</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="preprocessor">#endif</span></span><br></pre></td></tr></table></figure></p>
<p>总的来说就是编译时、运行时的判断均不能少。</p>
<h2 id="Weakly_Linked_-_运行时检查类、方法是否可用">Weakly Linked - 运行时检查类、方法是否可用</h2><p>除了用宏、系统版本检测，还可以用<strong>Weakly Linked</strong>特性做运行时的检查。</p>
<p>对于iOS4.2以上的，有<strong>NS_CLASS_AVAILABLE</strong>标示的类，可以如下判断是否可用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">if</span> __IPHONE_OS_VERSION_MAX_ALLOWED &gt; 80000</span></span><br><span class="line">    <span class="comment">// Weakly Linked判断</span></span><br><span class="line">    <span class="keyword">if</span> ([UIAlertController <span class="keyword">class</span>]) &#123;</span><br><span class="line">        <span class="comment">// 使用UIAlertController...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用旧的方案...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>也可以如下判断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class <span class="class"><span class="keyword">class</span> </span>= NSClassFromString (@<span class="string">"UIAlertController"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="class"><span class="keyword">class</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用UIAlertController...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 使用旧的方案...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于方法，如下判断:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">if</span> ([UITableViewCell <span class="attribute">instancesRespondToSelector</span>:<span class="variable">@selector</span> (<span class="attribute">setSeparatorInset</span>:)]) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="tag">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于用哪种方法，统一一下即可。</p>
<h2 id="用Method_Swizzling做兼容">用Method Swizzling做兼容</h2><p>有关Runtime、Method Swizzling的资料很多，各位自行阅读哈~</p>
<p>有时候，不同版本之间，同一个类、View控件的默认属性可能都会变化，如UILabel的背景色在iOS6上，默认是白色，而iOS6以后是透明的！如果在每个用到UILabel的地方，都手动设置一次背景色，代价太大。这个时候就需要Runtime的“黑魔法”上场。</p>
<p>就以设置UILabel的默认背景色透明为例，就是在UILabel初始化时，如initWithFrame之前，先设置好透明背景色，简单的示例如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Category</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UILabel</span> (<span class="title">TTGCompatibility</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先判断系统版本，尽量减少Runtime的作用范围</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">UIDevice</span> currentDevice]<span class="variable">.systemVersion</span><span class="variable">.floatValue</span> &lt; <span class="number">7.0</span>f) &#123;</span><br><span class="line">        <span class="comment">// Method Swizzling</span></span><br><span class="line">        <span class="comment">// initWithFrame</span></span><br><span class="line">        Method oriMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(initWithFrame:));</span><br><span class="line">        Method newMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(compatible_initWithFrame:));</span><br><span class="line">        method_exchangeImplementations(oriMethod, newMethod);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// initWithCoder...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initWithFrame</span></span><br><span class="line">- (<span class="keyword">id</span>)compatible_initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</span><br><span class="line">    <span class="keyword">id</span> newSelf = [<span class="keyword">self</span> compatible_initWithFrame:frame];</span><br><span class="line">    <span class="comment">// 设置透明背景色</span></span><br><span class="line">    ((<span class="built_in">UILabel</span> *)newSelf)<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">    <span class="keyword">return</span> newSelf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initWithCoder...</span></span><br></pre></td></tr></table></figure>
<h2 id="运行时添加“Dummy”方法，减少代码改动">运行时添加“Dummy”方法，减少代码改动</h2><p>Dummy，意思是“假的、假动作、假人”，在这里指的是为旧版本不存在的方法提供一个“假的”替代方法，防止因新API找不到而导致的Crash。</p>
<p>以UITableViewCell的<strong>“setSeparatorInset:”</strong>方法为例，在iOS6中，压根就不存在separatorInset，但是现有的代码里面大量的调用了这个方法，怎么办？难道一个一个的去加上判断条件？代价太大。 </p>
<p>这个时候就可以用Runtime的手段，在运行时添加一个Dummy方法，去“<strong>代替接收</strong>”setSeparatorInset消息，防止在iOS6上的Crash。</p>
<p>代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UITableViewCell</span> (<span class="title">TTGCompatibility</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line"><span class="comment">// 编译时判断SDK</span></span><br><span class="line"><span class="preprocessor">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt; __IPHONE_7_0</span></span><br><span class="line">    <span class="comment">// 运行时判断系统版本</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">UIDevice</span> currentDevice]<span class="variable">.systemVersion</span><span class="variable">.floatValue</span> &lt; <span class="number">7.0</span>f) &#123;</span><br><span class="line">        Method newMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(compatible_setSeparatorInset:));</span><br><span class="line">        <span class="comment">// 增加Dummy方法</span></span><br><span class="line">        class_addMethod(</span><br><span class="line">                <span class="keyword">self</span>,</span><br><span class="line">                <span class="keyword">@selector</span>(setSeparatorInset:),</span><br><span class="line">                method_getImplementation(newMethod),</span><br><span class="line">                method_getTypeEncoding(newMethod));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setSeparatorInset: 的Dummy方法</span></span><br><span class="line">- (<span class="keyword">void</span>)compatible_setSeparatorInset:(<span class="built_in">UIEdgeInsets</span>) inset &#123;</span><br><span class="line">    <span class="comment">// 空方法都可以，只是为了接收setSeparatorInset:消息。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2><p>在适配旧版本时，除了基本的宏定义、[UIDevice currentDevice].systemVersion判断，适当的用Runtime，可以大大减少对现有代码的“干涉”，多种方法相结合才是最好的。</p>
<p>嗯，还在用iOS6的用户，升个级呗=。=</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/cross_development/Introduction/Introduction.html#//apple_ref/doc/uid/10000163-BCICHGIE" target="_blank" rel="external">SDK Compatibility Guide</a></li>
<li><a href="http://git.devzeng.com/blog/ios-multiple-version-compatible.html" target="_blank" rel="external">iOS开发之多系统版本兼容</a></li>
<li><a href="http://stackoverflow.com/questions/3057325/weak-linking-check-if-a-class-exists-and-use-that-class" target="_blank" rel="external">Weak Linking - check if a class exists and use that class</a></li>
<li><a href="http://stackoverflow.com/questions/19789958/xcode-preprocessor-macro-to-check-if-base-sdk-ios-7-0" target="_blank" rel="external">Xcode preprocessor macro to check if Base SDK &gt;= iOS 7.0</a></li>
<li><a href="http://xuzhongzhou.net/post/ios-sdk-compatibility-guide.html" target="_blank" rel="external">iOS SDK 兼容性指南</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>最近，在做项目时，因为某种原因，突然要“适配”iOS6（也是醉了。。。），保证极少数的iOS6用户可以“用上”新的版本。哪怕界面上有瑕疵，只要功能正常就行。于是就只好花几天时间对iOS6进行紧急适配（心中一万头驼羊奔跑而过。。。）  </p>
<p>本文总结了一些常规的，和“非常规”的iOS项目向老版本兼容的办法，结合了<strong>宏定义</strong>、<strong>Category</strong>和<strong>Runtime</strong>，大家看着消遣一下就好哈~</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用Runtime的手段填充任意NSObject对象的nil属性]]></title>
    <link href="http://tutuge.me/2015/07/08/fill-nil-property-of-object/"/>
    <id>http://tutuge.me/2015/07/08/fill-nil-property-of-object/</id>
    <published>2015-07-08T15:23:23.000Z</published>
    <updated>2015-07-11T10:23:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>好久没有写东西了，忙啊。<br>前段时间参加了一下我们华科联创的HackDay（本人在读研=。=，目前在阿里实习），作品是一款<strong>实时在线对战游戏 - 波波攒</strong>，（介绍请看<a href="http://www.zhihu.com/question/24402279" target="_blank" rel="external">知乎</a>）<br>从iOS游戏客户端（用的<strong>SpriteKit</strong>）到后台（<strong>PHP CI + Node + SocketIO + MySQL</strong>）全是自己一个人倒腾出来的，做了一把真正的全栈工程师，爽啊~<br>后面会完善整个游戏，增加角色、优化啥的，过上一段时间会上线的哈~</p>
<p><strong>回到正文</strong>，本文主要介绍了怎么用Runtime的手段遍历任意NSObject对象的所有property，检查其值是否是nil，是的话根据其类型为其填充一个默认值。<br>Runtime毕竟是个“危险”的技术，本文的代码只是个初步的尝试。</p>
<a id="more"></a>
<h2 id="初衷">初衷</h2><p>在做项目的过程中，总是会写一大堆if、else语句去检查对象的Property是否是nil，如从服务器返回的JSON中缺少属性，导致Entity的某些值为空；或者创建的对象没有对所有属性做初始化等等。写多了觉得好烦啊=。=<br>所以想到本文的方法，嗯，程序员总是懒的。</p>
<h2 id="解决步骤">解决步骤</h2><ol>
<li>遍历一个对象的所有属性（默认不包括父类属性）。</li>
<li>判断属性是否是nil。</li>
<li>为nil的属性，获取它的类型。</li>
<li>根据类型设置初始值（如NSString可以设为空字符串；NSNumber可以设为@0）</li>
</ol>
<h2 id="Runtime">Runtime</h2><p>OC是一门“动态”、“基于消息”的语言，而Runtime就是利用OC的动态特性，在运行时对程序做出“调整”的技术。有关Runtime的官方文档、网上的资料很多，大家自学哈~</p>
<p>本文主要用了如下几个Runtime的函数：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类的所有Property</span></span><br><span class="line"><span class="number">1</span>. objc_property_t *<span class="function"><span class="title">class_copyPropertyList</span><span class="params">(Class cls, unsigned int *outCount)</span></span></span><br><span class="line"><span class="comment">// 获取一个Property的变量名</span></span><br><span class="line"><span class="number">2</span>. const char *<span class="function"><span class="title">property_getName</span><span class="params">(objc_property_t property)</span></span></span><br><span class="line"><span class="comment">// 获取一个Property的详细类型表达字符串</span></span><br><span class="line"><span class="number">3</span>. const char *<span class="function"><span class="title">property_getAttributes</span><span class="params">(objc_property_t property)</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="示例">示例</h2><p>不好一块一块拆开说，直接上代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 解析Property的Attributed字符串，参考Stackoverflow</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *getPropertyType(objc_property_t property) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *attributes = property_getAttributes(property);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, attributes);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1</span> + strlen(attributes)];</span><br><span class="line">    strcpy(buffer, attributes);</span><br><span class="line">    <span class="keyword">char</span> *state = buffer, *attribute;</span><br><span class="line">    <span class="keyword">while</span> ((attribute = strsep(&amp;state, <span class="string">","</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 非对象类型</span></span><br><span class="line">        <span class="keyword">if</span> (attribute[<span class="number">0</span>] == <span class="string">'T'</span> &amp;&amp; attribute[<span class="number">1</span>] != <span class="string">'@'</span>) &#123;</span><br><span class="line">            <span class="comment">// 利用NSData复制一份字符串</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">const</span> <span class="keyword">char</span> *) [[<span class="built_in">NSData</span> dataWithBytes:(attribute + <span class="number">1</span>) length:strlen(attribute) - <span class="number">1</span>] bytes];</span><br><span class="line">        <span class="comment">// 纯id类型</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (attribute[<span class="number">0</span>] == <span class="string">'T'</span> &amp;&amp; attribute[<span class="number">1</span>] == <span class="string">'@'</span> &amp;&amp; strlen(attribute) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"id"</span>;</span><br><span class="line">        <span class="comment">// 对象类型</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (attribute[<span class="number">0</span>] == <span class="string">'T'</span> &amp;&amp; attribute[<span class="number">1</span>] == <span class="string">'@'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">const</span> <span class="keyword">char</span> *) [[<span class="built_in">NSData</span> dataWithBytes:(attribute + <span class="number">3</span>) length:strlen(attribute) - <span class="number">4</span>] bytes];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 给对象的属性设置默认值</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">void</span> checkEntity(<span class="built_in">NSObject</span> *object) &#123;</span><br><span class="line">    <span class="comment">// 不同类型的字符串表示，目前只是简单检查字符串、数字、数组</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *CLASS_NAME_<span class="built_in">NSSTRING</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *CLASS_NAME_<span class="built_in">NSNUMBER</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *CLASS_NAME_<span class="built_in">NSARRAY</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化类型常量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// "NSString"</span></span><br><span class="line">        CLASS_NAME_<span class="built_in">NSSTRING</span> =  <span class="built_in">NSStringFromClass</span>([<span class="built_in">NSString</span> class])<span class="variable">.UTF8String</span>;</span><br><span class="line">        <span class="comment">// "NSNumber</span></span><br><span class="line">        CLASS_NAME_<span class="built_in">NSNUMBER</span> = <span class="built_in">NSStringFromClass</span>([<span class="built_in">NSNumber</span> class])<span class="variable">.UTF8String</span>;</span><br><span class="line">        <span class="comment">// "NSArray"</span></span><br><span class="line">        CLASS_NAME_<span class="built_in">NSARRAY</span> = <span class="built_in">NSStringFromClass</span>([<span class="built_in">NSArray</span> class])<span class="variable">.UTF8String</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@try</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount, i;</span><br><span class="line">        <span class="comment">// 包含所有Property的数组</span></span><br><span class="line">        objc_property_t *properties = class_copyPropertyList([object class], &amp;outCount);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历每个Property</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">            <span class="comment">// 取出对应Property</span></span><br><span class="line">            objc_property_t property = properties[i];</span><br><span class="line">            <span class="comment">// 获取Property对应的变量名</span></span><br><span class="line">            <span class="built_in">NSString</span> *propertyName = [<span class="built_in">NSString</span> stringWithUTF8String:property_getName(property)];</span><br><span class="line">            <span class="comment">// 获取Property的类型名</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *propertyTypeName = getPropertyType(property);</span><br><span class="line">            <span class="comment">// 获取Property的值</span></span><br><span class="line">            <span class="keyword">id</span> propertyValue = [object valueForKey:propertyName];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 值为空，才设置默认值</span></span><br><span class="line">            <span class="keyword">if</span> (!propertyValue) &#123;</span><br><span class="line">                <span class="comment">// NSString</span></span><br><span class="line">                <span class="keyword">if</span> (strncmp(CLASS_NAME_<span class="built_in">NSSTRING</span>, propertyTypeName, strlen(CLASS_NAME_<span class="built_in">NSSTRING</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    [object setValue:<span class="string">@""</span> forKey:propertyName];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// NSNumber</span></span><br><span class="line">                <span class="keyword">if</span> (strncmp(CLASS_NAME_<span class="built_in">NSNUMBER</span>, propertyTypeName, strlen(CLASS_NAME_<span class="built_in">NSNUMBER</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    [object setValue:@<span class="number">0</span> forKey:propertyName];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// NSArray</span></span><br><span class="line">                <span class="keyword">if</span> (strncmp(CLASS_NAME_<span class="built_in">NSARRAY</span>, propertyTypeName, strlen(CLASS_NAME_<span class="built_in">NSARRAY</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    [object setValue:@[] forKey:propertyName];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 别忘了释放数组</span></span><br><span class="line">        free(properties);</span><br><span class="line">    &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Check Entity Exception: %@"</span>, [exception description]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="重点_-_解析property_getAttributes函数的结果">重点 - 解析property_getAttributes函数的结果</h2><p>在整个处理过程中，property_getAttributes函数是关键，因为我们要首先确定Property的类型，才能根据类型赋初值，但是property_getAttributes函数返回的字符串比较“晦涩难懂”：</p>
<p>如下定义的Property：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSNumber</span> *number;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSArray</span> *array;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> i;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> f;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">char</span> *cStr;</span><br></pre></td></tr></table></figure></p>
<p>依次通过property_getAttributes获取的结果是：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T@<span class="string">"NSString"</span>,<span class="keyword">C</span>,<span class="keyword">N</span>,V_name</span><br><span class="line">T@<span class="string">"NSNumber"</span>,&amp;,<span class="keyword">N</span>,V_number</span><br><span class="line">T@<span class="string">"NSArray"</span>,&amp;,<span class="keyword">N</span>,V_array</span><br><span class="line">Tq,<span class="keyword">N</span>,V_i</span><br><span class="line">Td,<span class="keyword">N</span>,V_f</span><br><span class="line">T*,<span class="keyword">N</span>,V_cStr</span><br></pre></td></tr></table></figure></p>
<p>参考<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101" target="_blank" rel="external"> Declared Properties of Objective-C Runtime Programming Guide</a><br>我们大概可以知道，T表示Type，后面跟着@表示Cocoa对象类型，后面的表示Property的属性，如Copy、strong等，然后就是变量名。<br>所以getPropertyType函数的工作就是纯粹的解析字符串，获取T@后面的类型名。</p>
<h2 id="效果">效果</h2><p>例如我们有如下对象：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">UserEntity </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (copy, nonatomic) NSString *name;</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) NSNumber *number;</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) NSArray *array;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p>设置默认值：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UserEntity *userEntity = [UserEntity new];</span><br><span class="line"><span class="comment">// 检查属性，设置默认值。</span></span><br><span class="line">checkEntity(userEntity);</span><br><span class="line"><span class="comment">// 使用...</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"name: %@"</span>, userEntity<span class="variable">.name</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"number: %@"</span>, userEntity<span class="variable">.number</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"array: %@"</span>, userEntity<span class="variable">.array</span>);</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2015</span>-<span class="number">07</span>-<span class="number">11</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">25.918</span> <span class="type">Common</span>[<span class="number">6939</span>:<span class="number">270543</span>] <span class="keyword">name</span>: </span><br><span class="line"><span class="number">2015</span>-<span class="number">07</span>-<span class="number">11</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">25.918</span> <span class="type">Common</span>[<span class="number">6939</span>:<span class="number">270543</span>] <span class="keyword">number</span>: <span class="number">0</span></span><br><span class="line"><span class="number">2015</span>-<span class="number">07</span>-<span class="number">11</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">25.918</span> <span class="type">Common</span>[<span class="number">6939</span>:<span class="number">270543</span>] array: (</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>这样，一个对象的所有Property都有了初值。</p>
<h2 id="总结">总结</h2><p>上面的例子只是个粗略的版本，只是检查了字符串、数字、数组，其实完全可以扩展出很多功能，如针对不同的类型，根据对象的类型，设置不同的默认初值等，靠读者你了~</p>
<p>Runtime是个好东西，但是别乱用啊=。=</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html" target="_blank" rel="external">Objective-C Runtime Reference</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101" target="_blank" rel="external">Objective-C Runtime Programming Guide - Declared Properties</a></li>
<li><a href="http://stackoverflow.com/questions/754824/get-an-object-properties-list-in-objective-c" target="_blank" rel="external">Get an object properties list in Objective-C</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>好久没有写东西了，忙啊。<br>前段时间参加了一下我们华科联创的HackDay（本人在读研=。=，目前在阿里实习），作品是一款<strong>实时在线对战游戏 - 波波攒</strong>，（介绍请看<a href="http://www.zhihu.com/question/24402279">知乎</a>）<br>从iOS游戏客户端（用的<strong>SpriteKit</strong>）到后台（<strong>PHP CI + Node + SocketIO + MySQL</strong>）全是自己一个人倒腾出来的，做了一把真正的全栈工程师，爽啊~<br>后面会完善整个游戏，增加角色、优化啥的，过上一段时间会上线的哈~</p>
<p><strong>回到正文</strong>，本文主要介绍了怎么用Runtime的手段遍历任意NSObject对象的所有property，检查其值是否是nil，是的话根据其类型为其填充一个默认值。<br>Runtime毕竟是个“危险”的技术，本文的代码只是个初步的尝试。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[有趣的Autolayout示例-Masonry实现]]></title>
    <link href="http://tutuge.me/2015/05/23/autolayout-example-with-masonry/"/>
    <id>http://tutuge.me/2015/05/23/autolayout-example-with-masonry/</id>
    <published>2015-05-23T11:59:22.000Z</published>
    <updated>2015-05-25T07:42:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>好久没有写Blog了，这段时间有点忙啊=。=<br>本文举了3个比较有“特点”的Autolayout例子，源于微博上好友的提问，感觉比较有意思，也比较有代表性，就写了出来，分享给大家~<br>至于为什么用Masonry，那是因为它好用啊！（被问到过有关Masonry的问题，就索性用它来实现吧=。=）。</p>
<h3 id="效果图">效果图</h3><p><img src="http://zorrochen.qiniudn.com/blog_autolayout_example_with_masonry_1.gif" alt="image"></p>
<h3 id="Github地址">Github地址</h3><p><a href="https://github.com/zekunyan/AutolayoutExampleWithMasonry" target="_blank" rel="external">https://github.com/zekunyan/AutolayoutExampleWithMasonry</a></p>
<a id="more"></a>
<h3 id="关于例子工程结构">关于例子工程结构</h3><p>实现的时候采用的是用StoryBoard拖拽约束+Masonry手写代码相结合的方式实现。最关键的地方是用Masonry，为了更好地突出重点。其它的无关紧要的空间约束，直接就拖拽了。</p>
<h2 id="关于Autolayout">关于Autolayout</h2><p>刚开始学习Autolayout的时候，什么“Leading Edges”、“Horizontal Centers”，好多啊，感觉一下子适应不来，有时候面对一个界面布局上的需求，可能都无从下手。</p>
<p>总的来说，我觉得Autolayout的关键就是“<strong>Constraint（约束）</strong>”。其实就是一下两点：</p>
<ol>
<li>从显式设置frame的属性，到利用约束控制View的大小、位置。</li>
<li>思考如何布局时，重点从单个的View，到整体所有View之间的相互关系。</li>
</ol>
<p>既然没有了具体设置View的frame属性，也就是说，系统会在运行时，通过我们设定的“约束”，计算出每个View的frame，再去绘制屏幕内容。</p>
<p>也就是说，我们设置的Constraint，要能体现出View的<strong>位置（x、y坐标）</strong>、<strong>大小（宽高）</strong>。无论是用IB拖拽约束，还是手写代码，只要从这个角度去思考，很多问题就都能解决。</p>
<p>有关Autolayout的知识，网上有很多，在这里就不详细列出了，但是有个公式倒是可以贴出来：</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewA-<span class="keyword">attribute</span> = viewB-<span class="keyword">attribute</span> * multiplier + <span class="keyword">constant</span></span><br></pre></td></tr></table></figure>
<h2 id="关于Masonry">关于Masonry</h2><p>好用！</p>
<h2 id="Case_1:_并排两个label，宽度由内容决定。父级View宽度不够时，优先显示左边label的内容">Case 1: 并排两个label，宽度由内容决定。父级View宽度不够时，优先显示左边label的内容</h2><p>遇到这种跟内容压缩、优先级有关的布局，就不得不提Autolayout中的两个重要的属性“<strong>Content Compression Resistance</strong>”和“<strong>Content Hugging</strong>”。</p>
<h3 id="Content_Compression_Resistance_=_不许挤我！">Content Compression Resistance = 不许挤我！</h3><p>对，这个属性说白了就是“不许挤我”=。=<br>这个属性的优先级（Priority）越高，越不“容易”被压缩。也就是说，当整体的空间装不小所有的View的时候，Content Compression Resistance优先级越高的，现实的内容越完整。</p>
<h3 id="Content_Hugging_=_抱紧！">Content Hugging = 抱紧！</h3><p>这个属性的优先级越高，整个View就要越“抱紧”View里面的内容。也就是View的大小不会随着父级View的扩大而扩大。</p>
<h3 id="分析">分析</h3><p>根据要求，可以将约束分为两个部分：</p>
<ol>
<li>整体空间足够时，两个label的宽度由内容决定，也就是说，label的“Content Hugging”优先级很高，而且没有固定的Width属性。</li>
<li>整体空间不够时，左边的label更不容易被压缩，也就是“Content Compression Resistance”优先级更高。</li>
</ol>
<p>重点：</p>
<ol>
<li>label不设置具体的宽度（width）属性，宽度由内容决定。</li>
<li>显示的优先级由“Content Compression Resistance”属性的高低决定。</li>
</ol>
<h3 id="约束示例图">约束示例图</h3><p><img src="http://zorrochen.qiniudn.com/blog_autolayout_example_with_masonry_2.png" alt="image"></p>
<h3 id="关键代码">关键代码</h3><p>关键的代码如下：（label1是左边的label，label2是右边的）</p>
<h4 id="设置位置">设置位置</h4><pre><code><span class="comment">// label1: 位于左上角</span>
[_label1 mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) {
    <span class="built_in">make</span>.top.equalTo(_contentView1.mas_top).with.offset(<span class="number">5</span>);
    <span class="built_in">make</span>.left.equalTo(_contentView1.mas_left).with.offset(<span class="number">2</span>);

    <span class="comment">// 40高度</span>
    <span class="built_in">make</span>.height.equalTo(@<span class="number">40</span>);
}];

<span class="comment">// label2: 位于右上角</span>
[_label2 mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) {
    <span class="comment">//左边贴着label1，间隔2</span>
    <span class="built_in">make</span>.left.equalTo(_label1.mas_right).with.offset(<span class="number">2</span>);

    <span class="comment">//上边贴着父view，间隔5</span>
    <span class="built_in">make</span>.top.equalTo(_contentView1.mas_top).with.offset(<span class="number">5</span>);

    <span class="comment">//右边的间隔保持大于等于2，注意是lessThanOrEqual</span>
    <span class="comment">//这里的“lessThanOrEqualTo”放在从左往右的X轴上考虑会更好理解。</span>
    <span class="comment">//即：label2的右边界的X坐标值“小于等于”containView的右边界的X坐标值。</span>
    <span class="built_in">make</span>.right.lessThanOrEqualTo(_contentView1.mas_right).with.offset(-<span class="number">2</span>);

    <span class="comment">//只设置高度40</span>
    <span class="built_in">make</span>.height.equalTo(@<span class="number">40</span>);
}];
</code></pre><h4 id="设置内容约束">设置内容约束</h4><pre><code><span class="comment">//设置label1的content hugging 为1000</span>
<span class="attr_selector">[_label1 setContentHuggingPriority:UILayoutPriorityRequired
                           forAxis:UILayoutConstraintAxisHorizontal]</span>;

<span class="comment">//设置label1的content compression 为1000</span>
<span class="attr_selector">[_label1 setContentCompressionResistancePriority:UILayoutPriorityRequired
                                         forAxis:UILayoutConstraintAxisHorizontal]</span>;

<span class="comment">//设置右边的label2的content hugging 为1000</span>
<span class="attr_selector">[_label2 setContentHuggingPriority:UILayoutPriorityRequired
                           forAxis:UILayoutConstraintAxisHorizontal]</span>;

<span class="comment">//设置右边的label2的content compression 为250</span>
<span class="attr_selector">[_label2 setContentCompressionResistancePriority:UILayoutPriorityDefaultLow
                                         forAxis:UILayoutConstraintAxisHorizontal]</span>;
</code></pre><h3 id="小节">小节</h3><p>灵活运用“Content Compression Resistance”和“Content Hugging”属性。</p>
<h2 id="Case_2:_四个ImageView整体居中，可以任意显示、隐藏">Case 2: 四个ImageView整体居中，可以任意显示、隐藏</h2><p>先看看示例的截图：<br><img src="http://zorrochen.qiniudn.com/blog_autolayout_example_with_masonry_3.png" alt="image"></p>
<p>下面的四个Switch控件分别控制上面对应位置的图片是否显示。</p>
<h3 id="分析-1">分析</h3><ol>
<li>首先就是整体居中，为了实现这个，最简单的办法就是将四个图片“装进”一个<strong>容器View</strong>里面，然后让这个容器View在整个页面中居中即可。这样就不用控制每个图片的居中效果了。</li>
<li>然后就是显示与隐藏。在这里我直接控制图片ImageView的宽度，宽度为0的时候不就“隐藏”了吗。</li>
</ol>
<h3 id="约束示例图-1">约束示例图</h3><p><img src="http://zorrochen.qiniudn.com/blog_autolayout_example_with_masonry_4.png" alt="image"></p>
<p><strong>解释</strong></p>
<p>之所以这么设置，主要目的有以下几点：</p>
<ol>
<li>尽量减少无效的约束，保证约束不多也不少。</li>
<li>内部的每个imageView约束其实都只有四个：left、centerY、width和height，这样有个好处，就是可以写个函数，专门为View一次性添加这几个约束，大大减少代码量。</li>
<li>最右边的imageView还要单独设置跟容器View的右边约束，是为了不用设置容器View的width，保证容器View是刚好包含内部的View的，这样整体才是居中的。</li>
</ol>
<h3 id="关键代码-1">关键代码</h3><p>先看看设置每个imageView约束的函数：</p>
<pre><code>/<span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span>  设置view的宽高、左边约束，垂直中心约束
<span class="keyword">*</span>
<span class="keyword">*</span>  <span class="comment">@param view    要设置的view</span>
<span class="keyword">*</span>  <span class="comment">@param size    CGSize</span>
<span class="keyword">*</span>  <span class="comment">@param left    左边对齐的约束</span>
<span class="keyword">*</span>  <span class="comment">@param centerY 垂直中心对齐的约束</span>
<span class="keyword">*</span>
<span class="keyword">*</span>  <span class="comment">@return 返回宽约束，用于显示、隐藏单个view</span>
<span class="keyword">*</span>/
- (MASConstraint <span class="keyword">*</span>)setView:(UIView <span class="keyword">*</span>)view size:(CGSize)size left:(MASViewAttribute <span class="keyword">*</span>)left centerY:(MASViewAttribute <span class="keyword">*</span>)centerY {

    __block MASConstraint <span class="keyword">*</span>widthConstraint;

    [view mas_makeConstraints:^(MASConstraintMaker <span class="keyword">*</span>make) {
        //宽高固定
        widthConstraint = make.width.equalTo(<span class="comment">@(size.width));</span>
        make.height.equalTo(<span class="comment">@(size.height));</span>
        //左边约束
        make.left.equalTo(left);
        //垂直中心对齐
        make.centerY.equalTo(centerY);
    }];

    return widthConstraint;
}
</code></pre><p>接着就是设置容器View的代码：</p>
<pre><code><span class="comment">//containerView 就是 容器View</span>

[_containerView mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) {
    <span class="comment">//只设置高度，宽度由子View决定</span>
    <span class="built_in">make</span>.height.equalTo(@(IMAGE_SIZE));
    <span class="comment">//水平居中</span>
    <span class="built_in">make</span>.centerX.equalTo(self.view.mas_centerX);
    <span class="comment">//距离父View顶部200点</span>
    <span class="built_in">make</span>.top.equalTo(self.view.mas_top).offset(<span class="number">200</span>);
}];
</code></pre><p>最后是内部imageView的约束：</p>
<pre><code><span class="comment">//分别设置每个imageView的宽高、左边、垂直中心约束，注意约束的对象</span>
<span class="comment">//每个View的左边约束和左边的View的右边相等=。=，有点绕口...</span>

UIImageView *imageView1 = _imageViews[<span class="number">0</span>];
MASConstraint *width = [self <span class="string">setView:</span>imageView1 <span class="string">size:</span>imageViewSize <span class="string">left:</span>_containerView.mas_left <span class="string">centerY:</span>_containerView.mas_centerY];
[_widthConstraints <span class="string">addObject:</span>width];

UIImageView *imageView2 = _imageViews[<span class="number">1</span>];
width = [self <span class="string">setView:</span>imageView2 <span class="string">size:</span>imageViewSize <span class="string">left:</span>imageView1.mas_right <span class="string">centerY:</span>_containerView.mas_centerY];
[_widthConstraints <span class="string">addObject:</span>width];

UIImageView *imageView3 = _imageViews[<span class="number">2</span>];
width = [self <span class="string">setView:</span>imageView3 <span class="string">size:</span>imageViewSize <span class="string">left:</span>imageView2.mas_right <span class="string">centerY:</span>_containerView.mas_centerY];
[_widthConstraints <span class="string">addObject:</span>width];

UIImageView *imageView4 = _imageViews[<span class="number">3</span>];
width = [self <span class="string">setView:</span>imageView4 <span class="string">size:</span>imageViewSize <span class="string">left:</span>imageView3.mas_right <span class="string">centerY:</span>_containerView.mas_centerY];
[_widthConstraints <span class="string">addObject:</span>width];

<span class="comment">//最后设置最右边的imageView的右边与父view的最有对齐</span>
[imageView4 <span class="string">mas_makeConstraints:</span>^(MASConstraintMaker *make) {
    make.right.equalTo(_containerView.mas_right);
}];
</code></pre><p>控制ImageView显示、隐藏的时候，直接让其宽度等于0就行：</p>
<pre><code>- (<span class="keyword">IBAction</span>)showOrHideImage:(<span class="built_in">UISwitch</span> *)sender {
    <span class="built_in">NSUInteger</span> index = (<span class="built_in">NSUInteger</span>) sender<span class="variable">.tag</span>;
    MASConstraint *width = _widthConstraints[index];

    <span class="keyword">if</span> (sender<span class="variable">.on</span>) {
        width<span class="variable">.equalTo</span>(@(IMAGE_SIZE));
    } <span class="keyword">else</span> {
        width<span class="variable">.equalTo</span>(@<span class="number">0</span>);
    }
}
</code></pre><h3 id="小节-1">小节</h3><p>有时候用个“容器View”管理内部的View，往往会起到事半功倍的效果。而且在组织约束的时候，尽量的将约束统一起来，这样可以用一个函数去设置，减少代码量。</p>
<h2 id="Case_3:_子View的宽度始终是父级View的一半（或者任意百分比）">Case 3: 子View的宽度始终是父级View的一半（或者任意百分比）</h2><p>其实这个很简单=。= 再看看这个公式：</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewA-<span class="keyword">attribute</span> = viewB-<span class="keyword">attribute</span> * multiplier + <span class="keyword">constant</span></span><br></pre></td></tr></table></figure>
<p>这个是Autolayout里面一个约束的不同属性的基本组合关系，替换成宽度的话，就是下面这样：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子<span class="keyword">View</span>的宽度 = 父级<span class="keyword">View</span>宽度 * 系数 + 常数；</span><br></pre></td></tr></table></figure>
<p>在Masonry里面，其实有个函数“<strong>multipliedBy</strong>”，就是用来设置multipler属性的（跟原本的NSLayoutConstraint的对应）。</p>
<h3 id="关键代码-2">关键代码</h3><p>如下：</p>
<pre><code><span class="collection">[subView mas_makeConstraints:^<span class="list">(<span class="keyword">MASConstraintMaker</span> *make)</span> <span class="collection">{
    //上下左贴边
    make.left.equalTo<span class="list">(<span class="keyword">_containerView.mas_left</span>)</span><span class="comment">;</span>
    make.top.equalTo<span class="list">(<span class="keyword">_containerView.mas_top</span>)</span><span class="comment">;</span>
    make.bottom.equalTo<span class="list">(<span class="keyword">_containerView.mas_bottom</span>)</span><span class="comment">;</span>

    //宽度为父view的宽度的一半
    make.width.equalTo<span class="list">(<span class="keyword">_containerView.mas_width</span>)</span>.multipliedBy<span class="list">(<span class="number">0.5</span>)</span><span class="comment">;</span>
}</span>]</span><span class="comment">;</span>
</code></pre><p>接着，只要控制父级View的宽度，子View的宽度就会随着变化了。</p>
<h3 id="小节-2">小节</h3><p>multipliedBy在Masonry的Github主页里面没有=。=<br>所以要养成读头文件的习惯~</p>
<h2 id="总结">总结</h2><p>有关Autolayout的东西还有好多没有写，什么动画啊、动态修改约束之类的，本文也算是个引子吧，任重而道远~  </p>
<p>能看到这的朋友，也算是很有耐心了，哈哈~~</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://github.com/SnapKit/Masonry" target="_blank" rel="external">SnapKit/Masonry</a></li>
<li><a href="http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/" target="_blank" rel="external">Masonry介绍与使用实践(快速上手Autolayout)</a></li>
<li><a href="http://www.vienta.me/2014/12/07/AutoLayout-忘掉Frame-拥抱Constraint（I）/" target="_blank" rel="external">AutoLayout:忘掉Frame,拥抱Constraint</a></li>
<li><a href="https://www.zybuluo.com/MicroCai/note/73867#autolayout-基础" target="_blank" rel="external">Autolayout 基础</a></li>
<li><a href="http://codingobjc.com/blog/2015/01/28/autolayoutzhong-de-content-compression-resistancehe-content-huggingdao-di-shi-shi-yao-yi-si/" target="_blank" rel="external">对Auto Layout中的Content Compression Resistance和Content Hugging的总结</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/Introduction/Introduction.html" target="_blank" rel="external">Auto Layout Guide</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>好久没有写Blog了，这段时间有点忙啊=。=<br>本文举了3个比较有“特点”的Autolayout例子，源于微博上好友的提问，感觉比较有意思，也比较有代表性，就写了出来，分享给大家~<br>至于为什么用Masonry，那是因为它好用啊！（被问到过有关Masonry的问题，就索性用它来实现吧=。=）。</p>
<h3 id="效果图">效果图</h3><p><img src="http://zorrochen.qiniudn.com/blog_autolayout_example_with_masonry_1.gif" alt="image"></p>
<h3 id="Github地址">Github地址</h3><p><a href="https://github.com/zekunyan/AutolayoutExampleWithMasonry">https://github.com/zekunyan/AutolayoutExampleWithMasonry</a></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UITextView编辑时插入自定义表情-续-自定义表情图片的大小]]></title>
    <link href="http://tutuge.me/2015/04/21/resizable-nstextattachment/"/>
    <id>http://tutuge.me/2015/04/21/resizable-nstextattachment/</id>
    <published>2015-04-21T12:26:17.000Z</published>
    <updated>2015-04-21T13:09:03.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文是基于<a href="http://tutuge.me/2015/03/07/UITextView编辑时插入自定义表情-简单的图文混编/" target="_blank" rel="external">UITextView编辑时插入自定义表情-简单的图文混编</a>写的，主要实现了在UITextView插入表情图片时，自定义表情大小的功能。</p>
<h4 id="Github">Github</h4><p>本文代码工程地址：<a href="https://github.com/zekunyan/UITextViewDIYEmojiExample" target="_blank" rel="external">https://github.com/zekunyan/UITextViewDIYEmojiExample</a></p>
<h4 id="Gif示例图">Gif示例图</h4><p><img src="http://zorrochen.qiniudn.com/blog_resizable_nstextattachment_1.gif" alt="image"></p>
<a id="more"></a>
<h2 id="关键点">关键点</h2><p>首先要明确我们要什么，很简单，就是<strong>指定NSTextAttachment在被绘制时的大小</strong>。  </p>
<p>所以，按照这个思路，就可以去找找NSTextAttachment类的相关方法，看能不能通过继承或其他的方式改变大小。</p>
<p>幸运的是，NSTextAttachment实现了“<strong>NSTextAttachmentContainer</strong>”这个Protocol，而这个Protocol里面有如下方法：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(<span class="variable">CGRect</span>)</span>attachmentBoundsForTextContainer:<span class="params">(<span class="variable">NSTextContainer</span> *)</span>textContainer</span><br><span class="line">                      proposedLineFragment:<span class="params">(<span class="variable">CGRect</span>)</span>lineFrag</span><br><span class="line">                             glyphPosition:<span class="params">(<span class="variable">CGPoint</span>)</span>position</span><br><span class="line">                            characterIndex:<span class="params">(<span class="variable">NSUInteger</span>)</span>charIndex</span></span><br></pre></td></tr></table></figure>
<p>再看看其解释：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Returns <span class="operator">the</span> layout bounds <span class="operator">of</span> <span class="operator">the</span> <span class="keyword">text</span> attachment <span class="built_in">to</span> <span class="operator">the</span> layout manager. (required)</span><br></pre></td></tr></table></figure></p>
<p>也就是说，在绘制NSTextAttachment的内容的时候，内容的“Bounds”是通过这个方法获得的。所以，可以重写这个方法，来达到我们的目的。</p>
<h2 id="继续扩展NSTextAttachment类">继续扩展NSTextAttachment类</h2><h3 id="保存自定义Size">保存自定义Size</h3><p>根据之前的定义，我们在自定义的类“EmojiTextAttachment”中再加一个保存大小的属性，如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EmojiTextAttachment类定义</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">EmojiTextAttachment </span>: NSTextAttachment</span><br><span class="line"><span class="comment">//表情的字符串表示，见前文</span></span><br><span class="line"><span class="variable">@property</span>(strong, nonatomic) NSString *emojiTag;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增：保存当前表情图片的大小</span></span><br><span class="line"><span class="variable">@property</span>(assign, nonatomic) CGFloat emojiSize;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>有了“<strong>emojiSize</strong>”这个属性，我们就可以在自由的指定每个NSTextAttachment的大小。</p>
<h3 id="重写">重写</h3><p>接下来就是重写方法，不多说，见代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EmojiTextAttachment实现</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EmojiTextAttachment</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重点！重写NSTextAttachmentContainer Protocol的方法</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)attachmentBoundsForTextContainer:(<span class="built_in">NSTextContainer</span> *)textContainer proposedLineFragment:(<span class="built_in">CGRect</span>)lineFrag glyphPosition:(<span class="built_in">CGPoint</span>)position characterIndex:(<span class="built_in">NSUInteger</span>)charIndex &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据emojiSize计算新的大小</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> scaleImageSizeToWidth:_emojiSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算新的图片大小</span></span><br><span class="line"><span class="comment">//这里不涉及对图片实际数据的压缩，所以不用异步处理~</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGRect</span>)scaleImageSizeToWidth:(<span class="built_in">CGFloat</span>)width &#123;</span><br><span class="line">    <span class="comment">//缩放系数</span></span><br><span class="line">    <span class="built_in">CGFloat</span> factor = <span class="number">1.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取原本图片大小</span></span><br><span class="line">    <span class="built_in">CGSize</span> oriSize = [<span class="keyword">self</span><span class="variable">.image</span> size];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算缩放系数</span></span><br><span class="line">    factor = (<span class="built_in">CGFloat</span>) (width / oriSize<span class="variable">.width</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建新的Size</span></span><br><span class="line">    <span class="built_in">CGRect</span> newSize = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, oriSize<span class="variable">.width</span> * factor, oriSize<span class="variable">.height</span> * factor);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newSize;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="使用">使用</h2><p>增加了emojiSize属性后，我们就可以在创建表情，甚至创建后，自由的调整每个NSTextAttachment的大小。</p>
<h2 id="总结">总结</h2><p>一共只增加了十几行代码，但是效果还是不错哒~</p>
<p>求问：如何加载、显示Gif。。。=。=</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/NSTextAttachment_Class_TextKit/index.html#//apple_ref/occ/instp/NSTextAttachment/fileType" target="_blank" rel="external">NSTextAttachment</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/NSTextAttachmentContainer_Protocol/index.html#//apple_ref/occ/intfm/NSTextAttachmentContainer/attachmentBoundsForTextContainer:proposedLineFragment:glyphPosition:characterIndex:" target="_blank" rel="external">NSTextAttachmentContainer</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文是基于<a href="http://tutuge.me/2015/03/07/UITextView编辑时插入自定义表情-简单的图文混编/">UITextView编辑时插入自定义表情-简单的图文混编</a>写的，主要实现了在UITextView插入表情图片时，自定义表情大小的功能。</p>
<h4 id="Github">Github</h4><p>本文代码工程地址：<a href="https://github.com/zekunyan/UITextViewDIYEmojiExample">https://github.com/zekunyan/UITextViewDIYEmojiExample</a></p>
<h4 id="Gif示例图">Gif示例图</h4><p><img src="http://zorrochen.qiniudn.com/blog_resizable_nstextattachment_1.gif" alt="image"></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RPC框架Thrift例子-PHP调用C++后端程序]]></title>
    <link href="http://tutuge.me/2015/04/19/thrift-example-cpp-and-php/"/>
    <id>http://tutuge.me/2015/04/19/thrift-example-cpp-and-php/</id>
    <published>2015-04-19T09:04:56.000Z</published>
    <updated>2015-04-19T09:06:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>前段时间用了一下Facebook的开源RPC框架Thrift，做PHP客户端调用C++后端程序，真心觉得Thrift不错！</p>
<p>本文项目地址：<a href="https://github.com/zekunyan/ThriftDemo_PHP_CPP" target="_blank" rel="external">https://github.com/zekunyan/ThriftDemo_PHP_CPP</a></p>
<p>先看看本文的例子示意图：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_thrift_example_cpp_and_php_1.jpg" alt="image"></p>
<p><strong>流程</strong></p>
<ol>
<li>PHP客户端发起请求，请求参数是“Request”类型，里面有studentID参数。</li>
<li>CPP服务端收到请求返回数据，返回类型为“Response”，里面包含了student的信息，此处只是简单的示例。</li>
</ol>
<a id="more"></a>
<h2 id="定义">定义</h2><h3 id="什么是RPC">什么是RPC</h3><p>远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。 — 维基百科 - <a href="http://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8" target="_blank" rel="external">远程过程调用</a></p>
<p>通俗点讲，就是跨计算机、跨网络调用。</p>
<h3 id="什么是Thrift">什么是Thrift</h3><p>Apache Thrift 是Facebook实现的一种高效的、支持多种编程语言的远程服务调用(RPC)的框架。它采用接口描述语言定义并创建服务，支持可扩展的跨语言服务开发，所包含的代码生成引擎可以在多种语言中，如 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, Smalltalk 等创建高效的、无缝的服务，其传输数据采用二进制格式，相对 XML 和 JSON 体积更小，对于高并发、大数据量和多语言的环境更有优势。 — <a href="https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/" target="_blank" rel="external">Apache Thrift - 可伸缩的跨语言服务开发框架</a></p>
<h2 id="开发流程">开发流程</h2><ol>
<li>配置环境。C++的如CMake、make、g++；PHP的如php、php-fpm、Apache（Nginx）。</li>
<li>根据需求，编写thrift接口定义文件（IDL定义文件）。</li>
<li>使用thrift程序，为不同的语言生成代码。</li>
<li>根据需求，修改生成的代码（主要是Server端），编写实际的业务逻辑。</li>
<li>编译、部署。</li>
</ol>
<h2 id="Thrift的接口定义文件">Thrift的接口定义文件</h2><p>在利用Thrift开发的过程中，重点就是编写接口定义文件。<br>一般来说，接口定义文件决定了RPC过程中的通信数据结构、通信接口定义等。</p>
<p>总的来说，thrift的接口定义语法类似于C语言，包含了struct、enum、map、list等基础数据结构，同时支持大部分基本数据类型，如32位整型“i32”等。</p>
<p>详细的接口定义请参考：</p>
<ul>
<li><a href="http://thrift.apache.org/docs/idl" target="_blank" rel="external">Thrift interface description language</a></li>
<li><a href="https://git-wip-us.apache.org/repos/asf?p=thrift.git;a=blob_plain;f=tutorial/tutorial.thrift" target="_blank" rel="external">example.thrift</a></li>
</ul>
<p>看看本例子中的定义文件“TTG.thrift”：</p>
<figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cpp TTG</span><br><span class="line"><span class="keyword">namespace</span> php TTG</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ResponseState</span> </span>&#123;</span><br><span class="line">    StateOk = <span class="number">0</span>,</span><br><span class="line">    StateError = <span class="number">1</span>,</span><br><span class="line">    StateEmpty = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="built_in">i32</span> studentID = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="built_in">i32</span> studentID = <span class="number">0</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="built_in">string</span> name,</span><br><span class="line">    <span class="number">3</span>: list&lt;<span class="keyword">string</span>&gt; infos,</span><br><span class="line">    <span class="number">4</span>: ResponseState state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">TTGService</span> </span>&#123;</span><br><span class="line">    Response getStudentInfo(<span class="number">1</span>: Request request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>先定义命名空间，尽量减少命名冲突。</li>
<li>Request类型：PHP客户端请求的数据类型。</li>
<li>Response类型：CPP服务端返回的数据类型。</li>
<li>ResponseState枚举：定义返回的状态。</li>
<li>TTGService：服务接口定义。</li>
</ol>
<h2 id="生成对应语言的代码！">生成对应语言的代码！</h2><p>是的，生成代码！这是我觉得Thrift框架最“神奇”的地方。我们只需要执行几条命令，就可以根据接口定义文件“生成”对应语言的代码。然后我们只需要将对应的业务逻辑加入到生成的代码中即可。</p>
<p>如生成CPP服务端的代码：</p>
<pre><code>thrift <span class="comment">--gen cpp TTG.thrift</span>
</code></pre><p>然后就会生成如下代码。    </p>
<pre><code>TTGService<span class="class">.cpp</span>
TTGService<span class="class">.h</span>
TTGService_server<span class="class">.skeleton</span><span class="class">.cpp</span>
TTG_constants<span class="class">.cpp</span>
TTG_constants<span class="class">.h</span>
TTG_types<span class="class">.cpp</span>
TTG_types.h
</code></pre><h2 id="根据需要修改生成的代码">根据需要修改生成的代码</h2><p>生成CPP、PHP端的代码以后，我们就可以根据需要修改、添加业务代码。</p>
<h3 id="CPP服务端">CPP服务端</h3><p>在生成CPP的代码时，会生成一个“TTGService_server.skeleton.cpp”文件，这个就是我们的CPP服务端的代码“架子”。其中重点如下：</p>
<pre><code><span class="comment">//实现调用的接口</span>
<span class="keyword">class</span> TTGServiceHandler : <span class="keyword">virtual</span> <span class="keyword">public</span> TTGServiceIf {
 <span class="keyword">public</span>:
  TTGServiceHandler() {
    <span class="comment">// Your initialization goes here</span>
  }

  <span class="comment">//接口实现部分，实现getStudentInfo这个接口的具体细节，如根据request创建、返回对应的response</span>
  <span class="function"><span class="keyword">void</span> <span class="title">getStudentInfo</span><span class="params">(Response&amp; _return, <span class="keyword">const</span> Request&amp; request)</span> </span>{
    <span class="comment">// Your implementation goes here</span>
    <span class="built_in">printf</span>(<span class="string">"getStudentInfo\n"</span>);
  }

};
<span class="comment">//...</span>
</code></pre><p>我们将其改成：</p>
<pre><code>void getStudentInfo(Response &amp;_<span class="keyword">return</span>, <span class="keyword">const</span> Request &amp;request) {
    <span class="comment">// 输出请求参数</span>
    cout&lt;&lt;<span class="string">"Request: "</span>&lt;&lt;request.studentID&lt;&lt;endl;

    <span class="comment">// 创建返回数据</span>
    Response *response = new Response();

    <span class="comment">//填充数据</span>
    response-&gt;studentID = request.studentID;
    response-&gt;name = <span class="string">"tutuge"</span>;
    response-&gt;infos.push_back(<span class="string">"Info 1"</span>);
    response-&gt;infos.push_back(<span class="string">"Info 2"</span>);
    response-&gt;state = ResponseState::StateOk;

    <span class="comment">//返回</span>
    _<span class="keyword">return</span> = *response;
}
</code></pre><p>至此，CPP服务端的编写就完成了，接下来我们只需要编译、链接，执行最终生成的可执行文件即可。</p>
<h3 id="PHP客户端">PHP客户端</h3><p>PHP客户端的编写比较简单，直接参考代码吧：<a href="https://github.com/zekunyan/ThriftDemo_PHP_CPP/blob/master/PHP/client.php" target="_blank" rel="external">https://github.com/zekunyan/ThriftDemo_PHP_CPP/blob/master/PHP/client.php</a></p>
<h2 id="编译、链接，运行">编译、链接，运行</h2><p>用CMake，或者直接编写makefile均可，保证Thrift装好就行了。</p>
<p>直接运行最后生成的可执行文件TTG.run即可。</p>
<p>从浏览器，或者直接运行client.php，即可看到如下输出：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object(TTG\Response)[<span class="number">9</span>]  <span class="keyword">public</span> <span class="string">'studentID'</span> =&gt; int <span class="number">100</span>  <span class="keyword">public</span> <span class="string">'name'</span> =&gt; string <span class="string">'tutuge'</span> (length=<span class="number">6</span>)  <span class="keyword">public</span> <span class="string">'infos'</span> =&gt;     <span class="keyword">array</span> (size=<span class="number">2</span>)      <span class="number">0</span> =&gt; string <span class="string">'Info 1'</span> (length=<span class="number">6</span>)      <span class="number">1</span> =&gt; string <span class="string">'Info 2'</span> (length=<span class="number">6</span>)  <span class="keyword">public</span> <span class="string">'state'</span> =&gt; int <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2><p>Thrift是个好东西！就是文档好少=。=</p>
<h2 id="参考">参考</h2><ul>
<li><a href="http://thrift.apache.org/" target="_blank" rel="external">Apache Thrift</a></li>
<li><a href="http://thrift.apache.org/tutorial/php" target="_blank" rel="external">Thrift PHP Tutorial</a></li>
<li><a href="http://thrift.apache.org/tutorial/cpp" target="_blank" rel="external">Thrift C++ Tutorial</a></li>
<li><a href="http://en.wikipedia.org/wiki/Apache_Thrift" target="_blank" rel="external">Apache Thrift</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/" target="_blank" rel="external">Apache Thrift - 可伸缩的跨语言服务开发框架</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>前段时间用了一下Facebook的开源RPC框架Thrift，做PHP客户端调用C++后端程序，真心觉得Thrift不错！</p>
<p>本文项目地址：<a href="https://github.com/zekunyan/ThriftDemo_PHP_CPP">https://github.com/zekunyan/ThriftDemo_PHP_CPP</a></p>
<p>先看看本文的例子示意图：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_thrift_example_cpp_and_php_1.jpg" alt="image"></p>
<p><strong>流程</strong></p>
<ol>
<li>PHP客户端发起请求，请求参数是“Request”类型，里面有studentID参数。</li>
<li>CPP服务端收到请求返回数据，返回类型为“Response”，里面包含了student的信息，此处只是简单的示例。</li>
</ol>]]>
    
    </summary>
    
      <category term="C++" scheme="http://tutuge.me/tags/C/"/>
    
      <category term="PHP" scheme="http://tutuge.me/tags/PHP/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GCD使用经验与技巧浅谈]]></title>
    <link href="http://tutuge.me/2015/04/03/something-about-gcd/"/>
    <id>http://tutuge.me/2015/04/03/something-about-gcd/</id>
    <published>2015-04-03T13:59:56.000Z</published>
    <updated>2015-05-06T15:38:18.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>GCD(Grand Central Dispatch)可以说是Mac、iOS开发中的一大“利器”，本文就总结一些有关使用GCD的经验与技巧。</p>
<h2 id="dispatch_once_t必须是全局或static变量">dispatch_once_t必须是全局或static变量</h2><p>这一条算是“老生常谈”了，但我认为还是有必要强调一次，毕竟非全局或非static的dispatch_once_t变量在使用时会导致非常不好排查的bug，正确的如下：</p>
<pre><code><span class="comment">//静态变量，保证只有一份实例，才能确保只执行一次</span>
<span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;
<span class="built_in">dispatch_once</span>(&amp;onceToken, ^{
   <span class="comment">//单例代码 </span>
});
</code></pre><p>其实就是保证<strong>dispatch_once_t</strong>只有一份实例。</p>
<a id="more"></a>
<h2 id="dispatch_queue_create的第二个参数">dispatch_queue_create的第二个参数</h2><p><strong>dispatch_queue_create</strong>，创建队列用的，它的参数只有两个，原型如下：</p>
<pre><code><span class="function">dispatch_queue_t <span class="title">dispatch_queue_create</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *label, dispatch_queue_attr_t attr )</span></span>;
</code></pre><p>在网上的大部分教程里（甚至Apple自己的文档里），都是这么创建串行队列的：</p>
<pre><code>dispatch_queue_t <span class="built_in">queue</span> <span class="subst">=</span> dispatch_queue_create(<span class="string">"com.example.MyQueue"</span>, <span class="built_in">NULL</span>);
</code></pre><p>看，第二个参数传的是“<strong>NULL</strong>”。  但是dispatch_queue_attr_t类型是有已经定义好的常量的，所以我认为，为了更加的清晰、严谨，最好如下创建队列：</p>
<pre><code><span class="comment">//串行队列</span>
dispatch_queue_t <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.example.MyQueue"</span>, DISPATCH_QUEUE_SERIAL);

<span class="comment">//并行队列</span>
dispatch_queue_t <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.example.MyQueue"</span>, DISPATCH_QUEUE_CONCURRENT);
</code></pre><p>常量就是为了使代码更加“易懂”，更加清晰，既然有，为啥不用呢~</p>
<h2 id="dispatch_after是延迟提交，不是延迟运行">dispatch_after是<strong>延迟提交</strong>，不是<strong>延迟运行</strong></h2><p>先看看官方文档的说明：</p>
<pre><code>Enqueue <span class="operator">a</span> block <span class="keyword">for</span> execution <span class="keyword">at</span> <span class="operator">the</span> specified <span class="built_in">time</span>.
</code></pre><p><strong>Enqueue</strong>，就是入队，指的就是将一个Block在特定的延时以后，加入到指定的队列中，<strong>不是在特定的时间后立即运行！</strong>。</p>
<p>看看如下代码示例：</p>
<pre><code><span class="comment">//创建串行队列</span>
<span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"me.tutuge.test.gcd"</span>, DISPATCH_QUEUE_SERIAL);

<span class="comment">//立即打印一条信息        </span>
<span class="built_in">NSLog</span>(<span class="string">@"Begin add block..."</span>);        

<span class="comment">//提交一个block</span>
<span class="built_in">dispatch_async</span>(queue, ^{
    <span class="comment">//Sleep 10秒</span>
    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">10</span>];
    <span class="built_in">NSLog</span>(<span class="string">@"First block done..."</span>);
});        

<span class="comment">//5 秒以后提交block</span>
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">5</span> * <span class="built_in">NSEC_PER_SEC</span>)), queue, ^{
    <span class="built_in">NSLog</span>(<span class="string">@"After..."</span>);
});
</code></pre><p>结果如下：</p>
<pre><code>2015<span class="tag">-03-31</span> 20<span class="pseudo">:57</span><span class="pseudo">:27</span><span class="class">.122</span> <span class="tag">GCDTest</span><span class="attr_selector">[45633:1812016]</span> <span class="tag">Begin</span> <span class="tag">add</span> <span class="tag">block</span>...
2015<span class="tag">-03-31</span> 20<span class="pseudo">:57</span><span class="pseudo">:37</span><span class="class">.127</span> <span class="tag">GCDTest</span><span class="attr_selector">[45633:1812041]</span> <span class="tag">First</span> <span class="tag">block</span> <span class="tag">done</span>...
2015<span class="tag">-03-31</span> 20<span class="pseudo">:57</span><span class="pseudo">:37</span><span class="class">.127</span> <span class="tag">GCDTest</span><span class="attr_selector">[45633:1812041]</span> <span class="tag">After</span>...
</code></pre><p>从结果也验证了，dispatch_after只是延时提交block，并不是延时后立即执行。所以想用dispatch_after精确控制运行状态的朋友可要注意了~</p>
<h2 id="正确创建dispatch_time_t">正确创建dispatch_time_t</h2><p>用dispatch_after的时候就会用到dispatch_time_t变量，但是如何创建合适的时间呢？答案就是用<strong>dispatch_time</strong>函数，其原型如下：</p>
<pre><code><span class="function">dispatch_time_t <span class="title">dispatch_time</span> <span class="params">( dispatch_time_t when, <span class="keyword">int64_t</span> delta )</span></span>;
</code></pre><p>第一个参数一般是<strong>DISPATCH_TIME_NOW</strong>，表示从现在开始。<br>那么第二个参数就是真正的延时的具体时间。</p>
<p>这里要特别注意的是，<strong>delta</strong>参数是“<strong>纳秒！</strong>”，就是说，延时1秒的话，delta应该是“1000000000”=。=，太长了，所以理所当然系统提供了常量，如下：</p>
<pre><code><span class="hexcolor">#def</span>ine NSEC_PER_SEC <span class="number">1000000000</span>ull
<span class="hexcolor">#def</span>ine USEC_PER_SEC <span class="number">1000000</span>ull
<span class="hexcolor">#def</span>ine NSEC_PER_USEC <span class="number">1000</span>ull
</code></pre><p>关键词解释：</p>
<ul>
<li>NSEC：纳秒。</li>
<li>USEC：微妙。</li>
<li>SEC：秒</li>
<li>PER：每</li>
</ul>
<p>所以：</p>
<ol>
<li>NSEC_PER_SEC，每秒有多少纳秒。</li>
<li>USEC_PER_SEC，每秒有多少毫秒。（注意是指在纳秒的基础上）</li>
<li>NSEC_PER_USEC，每毫秒有多少纳秒。</li>
</ol>
<p>所以，延时<strong>1秒</strong>可以写成如下几种：</p>
<pre><code>dispatch_time<span class="list">(<span class="keyword">DISPATCH_TIME_NOW</span>, <span class="number">1</span> <span class="variable">* NSEC_PER_SEC);
dispatch_time(DISPATCH_TIME_NOW, 1000 *</span> USEC_PER_SEC)</span><span class="comment">;</span>
dispatch_time<span class="list">(<span class="keyword">DISPATCH_TIME_NOW</span>, USEC_PER_SEC <span class="variable">* NSEC_PER_USEC);</span></span>
</code></pre><p>最后一个“<strong>USEC_PER_SEC * NSEC_PER_USEC</strong>”，翻译过来就是“<strong>每秒的毫秒数乘以每毫秒的纳秒数</strong>”，也就是“<strong>每秒的纳秒数</strong>”，所以，延时500毫秒之类的，也就不难了吧~</p>
<h2 id="dispatch_suspend_!=_立即停止队列的运行">dispatch_suspend != 立即停止队列的运行</h2><p><strong>dispatch_suspend</strong>，<strong>dispatch_resume</strong>提供了“挂起、恢复”队列的功能，简单来说，就是可以暂停、恢复队列上的任务。但是这里的“<strong>挂起</strong>”，并不能保证可以<strong>立即</strong>停止队列上正在运行的block，看如下例子：</p>
<pre><code><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"me.tutuge.test.gcd"</span>, DISPATCH_QUEUE_SERIAL);

<span class="comment">//提交第一个block，延时5秒打印。</span>
<span class="built_in">dispatch_async</span>(queue, ^{
    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];
    <span class="built_in">NSLog</span>(<span class="string">@"After 5 seconds..."</span>);
});

<span class="comment">//提交第二个block，也是延时5秒打印</span>
<span class="built_in">dispatch_async</span>(queue, ^{
    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];
    <span class="built_in">NSLog</span>(<span class="string">@"After 5 seconds again..."</span>);
});

<span class="comment">//延时一秒</span>
<span class="built_in">NSLog</span>(<span class="string">@"sleep 1 second..."</span>);
[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];

<span class="comment">//挂起队列                        </span>
<span class="built_in">NSLog</span>(<span class="string">@"suspend..."</span>);
dispatch_suspend(queue);

<span class="comment">//延时10秒                </span>
<span class="built_in">NSLog</span>(<span class="string">@"sleep 10 second..."</span>);
[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">10</span>];

<span class="comment">//恢复队列            </span>
<span class="built_in">NSLog</span>(<span class="string">@"resume..."</span>);
dispatch_resume(queue);
</code></pre><p>运行结果如下：</p>
<pre><code>2015<span class="tag">-04-01</span> 00<span class="pseudo">:32</span><span class="pseudo">:09</span><span class="class">.903</span> <span class="tag">GCDTest</span><span class="attr_selector">[47201:1883834]</span> <span class="tag">sleep</span> 1 <span class="tag">second</span>...
2015<span class="tag">-04-01</span> 00<span class="pseudo">:32</span><span class="pseudo">:10</span><span class="class">.910</span> <span class="tag">GCDTest</span><span class="attr_selector">[47201:1883834]</span> <span class="tag">suspend</span>...
2015<span class="tag">-04-01</span> 00<span class="pseudo">:32</span><span class="pseudo">:10</span><span class="class">.910</span> <span class="tag">GCDTest</span><span class="attr_selector">[47201:1883834]</span> <span class="tag">sleep</span> 10 <span class="tag">second</span>...
2015<span class="tag">-04-01</span> 00<span class="pseudo">:32</span><span class="pseudo">:14</span><span class="class">.908</span> <span class="tag">GCDTest</span><span class="attr_selector">[47201:1883856]</span> <span class="tag">After</span> 5 <span class="tag">seconds</span>...
2015<span class="tag">-04-01</span> 00<span class="pseudo">:32</span><span class="pseudo">:20</span><span class="class">.911</span> <span class="tag">GCDTest</span><span class="attr_selector">[47201:1883834]</span> <span class="tag">resume</span>...
2015<span class="tag">-04-01</span> 00<span class="pseudo">:32</span><span class="pseudo">:25</span><span class="class">.912</span> <span class="tag">GCDTest</span><span class="attr_selector">[47201:1883856]</span> <span class="tag">After</span> 5 <span class="tag">seconds</span> <span class="tag">again</span>...    
</code></pre><p>可知，在dispatch_suspend挂起队列后，第一个block<strong>还是在运行</strong>，并且正常输出。<br>结合文档，我们可以得知，dispatch_suspend并不会立即暂停正在运行的block，而是在当前block执行完成后，暂停后续的block执行。</p>
<p>所以下次想暂停正在队列上运行的block时，还是不要用dispatch_suspend了吧~</p>
<h2 id="“同步”的dispatch_apply">“同步”的dispatch_apply</h2><p>dispatch_apply的作用是在一个队列（串行或并行）上“运行”多次block，其实就是简化了用循环去向队列依次添加block任务。但是我个人觉得这个函数就是个“坑”，先看看如下代码运行结果：</p>
<pre><code><span class="comment">//创建异步串行队列</span>
<span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"me.tutuge.test.gcd"</span>, DISPATCH_QUEUE_SERIAL);

<span class="comment">//运行block3次</span>
dispatch_apply(<span class="number">3</span>, queue, ^(size_t i) {
    <span class="built_in">NSLog</span>(<span class="string">@"apply loop: %zu"</span>, i);
});

<span class="comment">//打印信息</span>
<span class="built_in">NSLog</span>(<span class="string">@"After apply"</span>);
</code></pre><p>运行的结果是：</p>
<pre><code>2015<span class="tag">-04-01</span> 00<span class="pseudo">:55</span><span class="pseudo">:40</span><span class="class">.854</span> <span class="tag">GCDTest</span><span class="attr_selector">[47402:1893289]</span> <span class="tag">apply</span> <span class="rule"><span class="attribute">loop</span>:<span class="value"> <span class="number">0</span>
<span class="number">2015</span>-<span class="number">04</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">55</span>:<span class="number">40.856</span> GCDTest[<span class="number">47402</span>:<span class="number">1893289</span>] apply loop: <span class="number">1</span>
<span class="number">2015</span>-<span class="number">04</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">55</span>:<span class="number">40.856</span> GCDTest[<span class="number">47402</span>:<span class="number">1893289</span>] apply loop: <span class="number">2</span>
<span class="number">2015</span>-<span class="number">04</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">55</span>:<span class="number">40.856</span> GCDTest[<span class="number">47402</span>:<span class="number">1893289</span>] After apply</span></span>
</code></pre><p>看，明明是提交到异步的队列去运行，但是“After apply”居然在apply后打印，也就是说，dispatch_apply将外面的线程（main线程）<strong>“阻塞”</strong>了！</p>
<p>查看官方文档，dispatch_apply确实会“等待”其所有的循环运行完毕才往下执行=。=，看来要小心使用了。</p>
<h2 id="避免死锁！">避免死锁！</h2><h4 id="dispatch_sync导致的死锁">dispatch_sync导致的死锁</h4><p>涉及到多线程的时候，不可避免的就会有“死锁”这个问题，在使用GCD时，往往一不小心，就可能造成死锁，看看下面的“<strong>死锁</strong>”例子：</p>
<pre><code><span class="comment">//在main线程使用“同步”方法提交Block，必定会死锁。</span>
<span class="function">dispatch_sync</span>(<span class="function">dispatch_get_main_queue</span>(), ^{
    <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"I am block..."</span>);</span>
});
</code></pre><p>你可能会说，这么低级的错误，我怎么会犯，那么，看看下面的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)update<span class="built_in">UI1</span> &#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Update ui 1"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//死锁！</span></span><br><span class="line">        [<span class="keyword">self</span> update<span class="built_in">UI2</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)update<span class="built_in">UI2</span> &#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Update ui 2"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在你不注意的时候，嵌套调用可能就会造成死锁！所以为了“世界和平”=。=，我们还是少用<strong>dispatch_sync</strong>吧。</p>
<h4 id="dispatch_apply导致的死锁！">dispatch_apply导致的死锁！</h4><p>啥，dispatch_apply导致的死锁？。。。是的，前一节讲到，dispatch_apply会<strong>等</strong>循环执行完成，这不就差不多是<strong>阻塞</strong>了吗。看如下例子：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create<span class="list">(<span class="string">"me.tutuge.test.gcd"</span>, DISPATCH_QUEUE_SERIAL)</span><span class="comment">;</span></span><br><span class="line">       </span><br><span class="line">dispatch_apply<span class="list">(<span class="number">3</span>, queue, ^<span class="list">(<span class="keyword">size_t</span> i)</span> &#123;</span><br><span class="line">	NSLog<span class="list">(@<span class="string">"apply loop: %zu"</span>, i)</span><span class="comment">;</span></span><br><span class="line">   </span><br><span class="line">    //再来一个dispatch_apply！死锁！      </span><br><span class="line">	dispatch_apply<span class="list">(<span class="number">3</span>, queue, ^<span class="list">(<span class="keyword">size_t</span> j)</span> &#123;</span><br><span class="line">		NSLog<span class="list">(@<span class="string">"apply loop inside %zu"</span>, j)</span><span class="comment">;</span></span><br><span class="line">	&#125;)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这端代码只会输出“apply loop: 1”。。。就没有然后了=。=</p>
<p>所以，一定要避免dispatch_apply的<strong>嵌套调用</strong>。</p>
<h2 id="灵活使用dispatch_group">灵活使用dispatch_group</h2><p>很多时候我们需要等待一系列任务（block）执行完成，然后再做一些收尾的工作。如果是有序的任务，可以分步骤完成的，直接使用串行队列就行。但是如果是一系列<strong>并行</strong>执行的任务呢？这个时候，就需要dispatch_group帮忙了~总的来说，dispatch_group的使用分如下几步：</p>
<ol>
<li>创建dispatch_group_t</li>
<li>添加任务（block）</li>
<li>添加结束任务（如清理操作、通知UI等）</li>
</ol>
<p>下面着重讲讲在后面两步。</p>
<h4 id="添加任务">添加任务</h4><p>添加任务可以分为以下两种情况：</p>
<ol>
<li>自己创建队列：使用<strong>dispatch_group_async</strong>。</li>
<li>无法直接使用队列变量（如使用AFNetworking添加异步任务）：使用<strong>dispatch_group_enter</strong>，<strong>dispatch_group_leave</strong>。</li>
</ol>
<p>自己创建队列时，当然就用dispatch_group_async函数，简单有效，简单例子如下：</p>
<pre><code><span class="comment">//省去创建group、queue代码。。。</span>

dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^{
    <span class="comment">//Do you work...</span>
});
</code></pre><p>当你无法直接使用队列变量时，就无法使用dispatch_group_async了，下面以使用AFNetworking时的情况：</p>
<pre><code><span class="type">AFHTTPRequestOperationManager</span> *manager = [<span class="type">AFHTTPRequestOperationManager</span> manager];

//<span class="type">Enter</span> group
dispatch_group_enter(group);
[manager <span class="type">GET</span>:@<span class="string">"http://www.baidu.com"</span> parameters:<span class="keyword">nil</span> success:^(<span class="type">AFHTTPRequestOperation</span> *operation, id responseObject) {
    //<span class="type">Deal</span> <span class="keyword">with</span> <span class="literal">result</span>...

    //<span class="type">Leave</span> group
    dispatch_group_leave(group);
}    failure:^(<span class="type">AFHTTPRequestOperation</span> *operation, <span class="type">NSError</span> *error) {
    //<span class="type">Deal</span> <span class="keyword">with</span> error...

    //<span class="type">Leave</span> group
    dispatch_group_leave(group);
}];

//<span class="type">More</span> request...
</code></pre><p>使用<strong>dispatch_group_enter</strong>，<strong>dispatch_group_leave</strong>就可以方便的将一系列网络请求“<strong>打包</strong>”起来~</p>
<h4 id="添加结束任务">添加结束任务</h4><p>添加结束任务也可以分为两种情况，如下：</p>
<ol>
<li>在当前线程<strong>阻塞的同步等待</strong>：dispatch_group_wait。</li>
<li>添加一个异步执行的任务作为结束任务：dispatch_group_notify</li>
</ol>
<p>这两个比较简单，就不再贴代码了=。=</p>
<h2 id="使用dispatch_barrier_async,dispatch_barrier_sync的注意事项">使用dispatch_barrier_async,dispatch_barrier_sync的注意事项</h2><p>dispatch_barrier_async的作用就是向某个队列插入一个block，当目前正在执行的block运行完成后，阻塞这个block后面添加的block，只运行这个block直到完成，然后再继续后续的任务，有点“唯我独尊”的感觉=。=</p>
<p>值得注意的是：</p>
<ol>
<li>dispatch<em>barrier\</em>(a)sync只在自己创建的并发队列上有效，在全局(Global)并发队列、串行队列上，效果跟<strong>dispatch_(a)sync</strong>效果一样。</li>
<li>既然在串行队列上跟<strong>dispatch_(a)sync</strong>效果一样，那就要小心别死锁！</li>
</ol>
<h2 id="dispatch_set_context与dispatch_set_finalizer_f的配合使用">dispatch_set_context与dispatch_set_finalizer_f的配合使用</h2><p>dispatch_set_context可以为队列添加<strong>上下文数据</strong>，但是因为GCD是C语言接口形式的，所以其context参数类型是“<strong>void *</strong>”。也就是说，我们创建context时有如下几种选择：</p>
<ol>
<li>用C语言的malloc创建context数据。</li>
<li>用C++的new创建类对象。</li>
<li>用Objective-C的对象，但是要用__bridge等关键字转为Core Foundation对象。</li>
</ol>
<p>以上所有创建context的方法都有一个必须的要求，就是都要<strong>释放内存！</strong>，无论是用<strong>free、delete还是CF的CFRelease</strong>，我们都要确保在队列不用的时候，释放context的内存，否则就会造成内存泄露。</p>
<p>所以，使用dispatch_set_context的时候，最好结合dispatch_set_finalizer_f使用，为队列设置“析构函数”，在这个函数里面释放内存，大致如下：</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">cleanStaff</span><span class="params">(<span class="keyword">void</span> *context)</span> </span>{
    <span class="comment">//释放context的内存！</span>

    <span class="comment">//CFRelease(context);</span>
    <span class="comment">//free(context);</span>
    <span class="comment">//delete context;</span>
}

...

<span class="comment">//在队列创建后，设置其“析构函数”</span>
dispatch_set_finalizer_f(<span class="built_in">queue</span>, cleanStaff);
</code></pre><p>详细用法，请看我之前写的Blog<a href="http://tutuge.me/2015/03/29/bind-data-to-gcd-queue/" target="_blank" rel="external">为GCD队列绑定NSObject类型上下文数据-利用__bridge_retained(transfer)转移内存管理权</a></p>
<h2 id="总结">总结</h2><p>其实本文更像是总结了GCD中的“坑”=。=</p>
<p>至于经验，总结一条，就是使用任何技术，都要研究透彻，否则后患无穷啊~</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/prerelease/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html" target="_blank" rel="external">Grand Central Dispatch (GCD) Reference</a></li>
<li><a href="https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091" target="_blank" rel="external">Concurrency Programming Guide</a></li>
<li><a href="http://commandshift.co.uk/blog/2014/03/19/using-dispatch-groups-to-wait-for-multiple-web-services" target="_blank" rel="external">Using Dispatch Groups to Wait for Multiple Web Services</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>GCD(Grand Central Dispatch)可以说是Mac、iOS开发中的一大“利器”，本文就总结一些有关使用GCD的经验与技巧。</p>
<h2 id="dispatch_once_t必须是全局或static变量">dispatch_once_t必须是全局或static变量</h2><p>这一条算是“老生常谈”了，但我认为还是有必要强调一次，毕竟非全局或非static的dispatch_once_t变量在使用时会导致非常不好排查的bug，正确的如下：</p>
<pre><code><span class="comment">//静态变量，保证只有一份实例，才能确保只执行一次</span>
<span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;
<span class="built_in">dispatch_once</span>(&amp;onceToken, ^{
   <span class="comment">//单例代码 </span>
});
</code></pre><p>其实就是保证<strong>dispatch_once_t</strong>只有一份实例。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为GCD队列绑定NSObject类型上下文数据-利用__bridge_retained(transfer)转移内存管理权]]></title>
    <link href="http://tutuge.me/2015/03/29/bind-data-to-gcd-queue/"/>
    <id>http://tutuge.me/2015/03/29/bind-data-to-gcd-queue/</id>
    <published>2015-03-29T11:27:40.000Z</published>
    <updated>2015-05-28T09:11:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="2015-5-28更新">2015-5-28更新</h2><p>下面评论的好友“@Jim”给了种新的思路，就是在清除context的函数里面，用“<strong>_bridge_transfer</strong>”转换context，把context的内存管理权限重新交给ARC，这样，就不用显式调用“<strong>CFRelease</strong>”了。如下：</p>
<pre><code><span class="literal">void</span> cleanStaff(<span class="literal">void</span> <span class="subst">*</span>context) {
    <span class="comment">//这里用_bridge_transfer转换，将内存管理权限交还给ARC</span>
    <span class="built_in">Data</span> <span class="subst">*</span><span class="built_in">data</span> <span class="subst">=</span> (_bridge_transfer <span class="built_in">Data</span> <span class="subst">*</span>)(context);
    NSLog(@<span class="string">"In clean, context number: %d"</span>, <span class="built_in">data</span><span class="built_in">.</span>number);

    <span class="comment">//不用显式释放context的内存！</span>
}
</code></pre><h2 id="前言">前言</h2><p>看过GCD（Grand Central Dispatch）的Apple<a href="https://developer.apple.com/library/prerelease/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html" target="_blank" rel="external">官方文档</a>的朋友一定见过“<strong>dispatch_set_context</strong>”和“<strong>dispatch_get_context</strong>”这两个函数，那么这两个函数该怎么用呢？  </p>
<p>我们都知道，GCD的接口参数都是“C语言类型“的，那么，我们如何将NSObject类型（Foundation框架）的数据，传入GCD的接口呢？（即：Core Foundation和Foundation对象的转换）</p>
<h2 id="本文关键字">本文关键字</h2><ul>
<li>GCD：dispatch_set_context，dispatch_get_context</li>
<li>__bridge，__bridge_retained，__bridge_transfer</li>
<li>Core Foundation, NSObject</li>
</ul>
<a id="more"></a>
<h2 id="dispatch_set(get)_context">dispatch_set(get)_context</h2><p>先看看这两个函数的原型：</p>
<pre><code><span class="comment">//设置context</span>
<span class="function"><span class="keyword">void</span> <span class="title">dispatch_set_context</span> <span class="params">( dispatch_object_t <span class="keyword">object</span>, <span class="keyword">void</span> *context )</span></span>;
<span class="comment">//获取context</span>
<span class="keyword">void</span> * dispatch_get_context ( dispatch_object_t <span class="keyword">object</span> );
</code></pre><p>这里的object一般指的就是通过dispatch_queue_create创建的队列。 </p>
<p>所以，这两个函数分别完成了将context“绑定”到特定GCD队列和从GCD队列获取对应context的任务。</p>
<h3 id="什么是context">什么是context</h3><p>在上述函数原型中，context是一个“<strong>void类型指针</strong>”，学过C语言的朋友应该都知道，void型指针可以指向任意类型，就是说，context在这里可以是任意类型的指针。</p>
<p>从这里可以得知，我们可以为队列“<strong>set</strong>”任意类型的数据，并在合适的时候取出来用。</p>
<h2 id="用malloc创建context并绑定到队列上">用malloc创建context并绑定到队列上</h2><p>参考<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW13" target="_blank" rel="external">Apple官方的例子</a>，我们先用传统的<strong>malloc</strong>创建context，看看如下简短例子：</p>
<pre><code><span class="comment">//定义context，即一个结构体</span>
typedef struct _Data {
    int number;
} <span class="built_in">Data</span>;

<span class="comment">//定义队列的finalizer函数，用于释放context内存</span>
<span class="literal">void</span> cleanStaff(<span class="literal">void</span> <span class="subst">*</span>context) {
    NSLog(@<span class="string">"In clean, context number: %d"</span>, ((<span class="built_in">Data</span> <span class="subst">*</span>)context)<span class="subst">-&gt;</span>number);
    <span class="comment">//释放，如果是new出来的对象，就要用delete</span>
    free(context);
}

<span class="subst">-</span> (<span class="literal">void</span>)testBody {
    <span class="comment">//创建队列</span>
    dispatch_queue_t <span class="built_in">queue</span> <span class="subst">=</span> dispatch_queue_create(<span class="string">"me.tutuge.test.gcd"</span>, DISPATCH_QUEUE_SERIAL);

    <span class="comment">//创建Data类型context数据并初始化</span>
    <span class="built_in">Data</span> <span class="subst">*</span>myData <span class="subst">=</span> malloc(sizeof(<span class="built_in">Data</span>));
    myData<span class="subst">-&gt;</span>number <span class="subst">=</span> <span class="number">10</span>;

    <span class="comment">//绑定context</span>
    dispatch_set_context(<span class="built_in">queue</span>, myData);

    <span class="comment">//设置finalizer函数，用于在队列执行完成后释放对应context内存</span>
    dispatch_set_finalizer_f(<span class="built_in">queue</span>, cleanStaff);

    dispatch_async(<span class="built_in">queue</span>, ^{
        <span class="comment">//获取队列的context数据</span>
        <span class="built_in">Data</span> <span class="subst">*</span><span class="built_in">data</span> <span class="subst">=</span> dispatch_get_context(<span class="built_in">queue</span>);
        <span class="comment">//打印</span>
        NSLog(@<span class="string">"1: context number: %d"</span>, <span class="built_in">data</span><span class="subst">-&gt;</span>number);
        <span class="comment">//修改context保存的数据</span>
        <span class="built_in">data</span><span class="subst">-&gt;</span>number <span class="subst">=</span> <span class="number">20</span>;
    });
}
</code></pre><p>上面的代码运行后如下：</p>
<pre><code>2015<span class="tag">-03-29</span> 20<span class="pseudo">:28</span><span class="pseudo">:16</span><span class="class">.854</span> <span class="tag">GCDTest</span><span class="attr_selector">[37787:1443423]</span> 1: <span class="tag">context</span> <span class="rule"><span class="attribute">number</span>:<span class="value"> <span class="number">10</span>
<span class="number">2015</span>-<span class="number">03</span>-<span class="number">29</span> <span class="number">20</span>:<span class="number">28</span>:<span class="number">16.855</span> GCDTest[<span class="number">37787</span>:<span class="number">1443423</span>] In clean, context number: <span class="number">20</span></span></span>
</code></pre><p>看，通过为队列设置context，我们就能为队列绑定自定义的数据，然后在合适的时候取出来用。</p>
<h2 id="NSObject类型的context">NSObject类型的context</h2><p>在Mac、iOS的开发过程中，我们大部分用的都是Foundation框架下的类，就是如NSString、NSDictionary这些NSObject类型的类。<br>但是上面的<strong>dispatch_set(get)_context</strong>接受的context参数是C语言类型的，即Core Foundation类型的，我们如何转换呢？</p>
<p><strong>由于ARC不能管理Core Foundation Object的生命周期</strong>，所以我们必须先转换context的“类型”，以便转换内存管理权。</p>
<h3 id="__bridge">__bridge</h3><p>Apple已经为我们提供了用于转换的关键字，如下：</p>
<ul>
<li>__bridge: 只做了类型转换，不修改内存管理权；</li>
<li>__bridge_retained（即CFBridgingRetain）转换类型，同时将内存管理权从ARC中移除，后面需要使用CFRelease来释放对象；</li>
<li>__bridge_transfer（即CFBridgingRelease）将Core Foundation的对象转换为Objective-C的对象，同时将内存管理权交给ARC。</li>
</ul>
<h3 id="重新定义context">重新定义context</h3><p>为了方便下面的说明，我们先定义context类。</p>
<pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">Data</span> : <span class="title">NSObject</span></span>
<span class="keyword">@property</span>(<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">int</span> number;
<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">Data</span></span>

<span class="comment">//继承dealloc方法，便于观察对象何时被释放</span>
- (<span class="keyword">void</span>)dealloc {
    <span class="built_in">NSLog</span>(<span class="string">@"Data dealloc..."</span>);
}

<span class="keyword">@end</span>
</code></pre><p>看，我们继承了<strong>dealloc</strong>方法，这样就能知道Data类型对象什么时候被释放。</p>
<h3 id="需要注意的点">需要注意的点</h3><p><strong>__bridge</strong>的转换是没有转移内存管理权的，这点要特别注意。  </p>
<p>如果在传context对象时，用的是<strong>__bridge</strong>转换，那么context对象的内存管理权还在ARC手里，一旦当前作用域执行完，context就会被释放，而如果队列的任务用了context对象，就会造成“<strong>EXC_BAD_ACCESS</strong>”崩溃！</p>
<h3 id="正确的用法">正确的用法</h3><p>重写上面的例子，如下：</p>
<pre><code><span class="comment">//定义队列的finalizer函数，用于释放context内存</span>
<span class="function"><span class="keyword">void</span> <span class="title">cleanStaff</span><span class="params">(<span class="keyword">void</span> *context)</span> </span>{
    <span class="comment">//这里用__bridge转换，不改变内存管理权</span>
    Data *data = (__bridge Data *)(context);
    NSLog(@<span class="string">"In clean, context number: %d"</span>, data.number);

    <span class="comment">//释放context的内存！</span>
    CFRelease(context);
}

- (<span class="keyword">void</span>)testBody {
    <span class="comment">//创建队列</span>
    dispatch_queue_t <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"me.tutuge.test.gcd"</span>, DISPATCH_QUEUE_SERIAL);

    <span class="comment">//创建Data类型context数据并初始化</span>
    Data *myData = [Data <span class="keyword">new</span>];
    myData.number = <span class="number">10</span>;

    <span class="comment">//绑定context</span>
    <span class="comment">//这里用__bridge_retained转换，将context的内存管理权从ARC移除，交由我们自己手动释放！</span>
    dispatch_set_context(<span class="built_in">queue</span>, (__bridge_retained <span class="keyword">void</span> *)(myData));

    <span class="comment">//设置finalizer函数，用于在队列执行完成后释放对应context内存</span>
    dispatch_set_finalizer_f(<span class="built_in">queue</span>, cleanStaff);

    dispatch_async(<span class="built_in">queue</span>, ^{
        <span class="comment">//获取队列的context数据</span>
        <span class="comment">//这里用__bridge转换，不改变内存管理权</span>
        Data *data = (__bridge Data *)(dispatch_get_context(<span class="built_in">queue</span>));
        <span class="comment">//打印</span>
        NSLog(@<span class="string">"1: context number: %d"</span>, data.number);
        <span class="comment">//修改context保存的数据</span>
        data.number = <span class="number">20</span>;
    });
}
</code></pre><h4 id="解释">解释</h4><ul>
<li>在dispatch_set_context的时候用<strong>__bridge_retained</strong>转换，将context的内存管理权从ARC移除，交给我们自己管理。</li>
<li>在队列任务中，用dispatch_get_context获取context的时候，用<strong>__bridge</strong>转换，维持context的内存管理权不变，防止出了作用域context被释放。</li>
<li>最后用<strong>CFRelease</strong>释放context内存。</li>
</ul>
<h3 id="运行结果">运行结果</h3><pre><code>2015<span class="tag">-03-29</span> 21<span class="pseudo">:12</span><span class="pseudo">:41</span><span class="class">.631</span> <span class="tag">GCDTest</span><span class="attr_selector">[38131:1465900]</span> 1: <span class="tag">context</span> <span class="rule"><span class="attribute">number</span>:<span class="value"> <span class="number">10</span>
<span class="number">2015</span>-<span class="number">03</span>-<span class="number">29</span> <span class="number">21</span>:<span class="number">12</span>:<span class="number">41.632</span> GCDTest[<span class="number">38131</span>:<span class="number">1465900</span>] In clean, context number: <span class="number">20</span>
<span class="number">2015</span>-<span class="number">03</span>-<span class="number">29</span> <span class="number">21</span>:<span class="number">12</span>:<span class="number">41.632</span> GCDTest[<span class="number">38131</span>:<span class="number">1465900</span>] Data dealloc...</span></span>
</code></pre><p>由结果可知，我们的context对象在最后显式调用<strong>CFRelease</strong>才被释放。</p>
<h2 id="总结">总结</h2><p>总的来说，就是合理运用__bridge_retained(transfer)关键字转换对象的内存管理权，让我们自己控制对象的生命周期。</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/prerelease/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html" target="_blank" rel="external">Grand Central Dispatch (GCD) Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW13" target="_blank" rel="external">Concurrency Programming Guide</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html" target="_blank" rel="external">Toll-Free Bridged Types</a></li>
<li><a href="http://blog.csdn.net/diyagoanyhacker/article/details/7573801" target="_blank" rel="external">Core Foundation 框架</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="2015-5-28更新">2015-5-28更新</h2><p>下面评论的好友“@Jim”给了种新的思路，就是在清除context的函数里面，用“<strong>_bridge_transfer</strong>”转换context，把context的内存管理权限重新交给ARC，这样，就不用显式调用“<strong>CFRelease</strong>”了。如下：</p>
<pre><code><span class="literal">void</span> cleanStaff(<span class="literal">void</span> <span class="subst">*</span>context) {
    <span class="comment">//这里用_bridge_transfer转换，将内存管理权限交还给ARC</span>
    <span class="built_in">Data</span> <span class="subst">*</span><span class="built_in">data</span> <span class="subst">=</span> (_bridge_transfer <span class="built_in">Data</span> <span class="subst">*</span>)(context);
    NSLog(@<span class="string">"In clean, context number: %d"</span>, <span class="built_in">data</span><span class="built_in">.</span>number);

    <span class="comment">//不用显式释放context的内存！</span>
}
</code></pre><h2 id="前言">前言</h2><p>看过GCD（Grand Central Dispatch）的Apple<a href="https://developer.apple.com/library/prerelease/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html">官方文档</a>的朋友一定见过“<strong>dispatch_set_context</strong>”和“<strong>dispatch_get_context</strong>”这两个函数，那么这两个函数该怎么用呢？  </p>
<p>我们都知道，GCD的接口参数都是“C语言类型“的，那么，我们如何将NSObject类型（Foundation框架）的数据，传入GCD的接口呢？（即：Core Foundation和Foundation对象的转换）</p>
<h2 id="本文关键字">本文关键字</h2><ul>
<li>GCD：dispatch_set_context，dispatch_get_context</li>
<li>__bridge，__bridge_retained，__bridge_transfer</li>
<li>Core Foundation, NSObject</li>
</ul>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5]]></title>
    <link href="http://tutuge.me/2015/03/21/effective-objective-c-5-enum/"/>
    <id>http://tutuge.me/2015/03/21/effective-objective-c-5-enum/</id>
    <published>2015-03-21T12:52:57.000Z</published>
    <updated>2015-04-06T03:13:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>Enum，也就是枚举，从C语言开始就有了，C++、Java、Objective-C、Swift这些语言，当然都有对应的枚举类型，功能可能有多有少，但是最核心的还是一个—-规范的定义代码中的状态、选项等“常量”。</p>
<h2 id="Item_5_-_Use_Enumerations_for_States,_Options,_and_Status_Codes">Item 5 - Use Enumerations for States, Options, and Status Codes</h2><p>本节的内容就是如何正确的使用枚举。</p>
<h2 id="状态与选项的区别（states_and_options）">状态与选项的区别（states and options）</h2><p>在用<strong>enum</strong>之前，我个人觉得，区分一下状态和选项的概念还是很必要的。</p>
<p><strong>状态</strong>，同时只能有一种，如“<strong>OK</strong>”，“<strong>Error</strong>”，不可能同时是OK和Error。<br><strong>选项</strong>，同时可以有一种或一种以上，如App可以<strong>同时</strong>支持横屏和竖屏，横屏竖屏在这个时候就是“屏幕方向”的两种不同的选项。</p>
<p>接下来，我们看看如何用枚举定义状态和选项。</p>
<a id="more"></a>
<h2 id="enum与状态（states）">enum与状态（states）</h2><h4 id="不好的做法">不好的做法</h4><p>经常看到这样的写法：</p>
<pre><code><span class="preprocessor">#<span class="keyword">define</span> STATE_OK 0</span>
<span class="preprocessor">#<span class="keyword">define</span> STATE_ERROR 1</span>
<span class="preprocessor">#<span class="keyword">define</span> STATE_UNKNOW 2</span>

<span class="comment">//直接用int型变量接收</span>
<span class="keyword">int</span> STATE = STATE_UNKNOW;
</code></pre><p>这样做有如下“不恰当”：</p>
<ul>
<li>宏定义没有类型约束，只是单纯的替换。</li>
<li>无法限制状态的所有情况，如，认为的将STATE赋值成3，程序可能就会出错，找不到匹配的状态，因为编译器不会对“<strong>STATE = 3;</strong>”提出警告。</li>
</ul>
<h4 id="正确的做法">正确的做法</h4><pre><code>typedef enum _TTGState {
    TTGStateOK  = <span class="number">0</span>,
    TTGStateError,
    TTGStateUnknow
} TTGState;

//指明枚举类型
TTGState <span class="keyword">state</span> = TTGStateOK;
</code></pre><p>用的时候就如下：</p>
<pre><code>- (<span class="typename">void</span>)<span class="string">dealWithState:</span>(TTGState)state {
    <span class="keyword">switch</span> (state) {
        <span class="keyword">case</span> <span class="string">TTGStateOK:</span>
            <span class="comment">//...</span>
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="string">TTGStateError:</span>
            <span class="comment">//...</span>
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="string">TTGStateUnknow:</span>
            <span class="comment">//...</span>
            <span class="keyword">break</span>;
    }
}
</code></pre><h2 id="enum与选项_(options)">enum与选项 (options)</h2><p>选项，就是说一个“选项变量”的类型要能够同时表示一个或多个组合的选择，如下例子：</p>
<pre><code><span class="comment">//方向，可同时支持一个或多个方向</span>
typedef <span class="class"><span class="keyword">enum</span> _<span class="title">TTGDirection</span> </span>{
<span class="constant">    TTGDirectionNone</span> = <span class="number">0</span>,
<span class="constant">    TTGDirectionTop</span> = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,
<span class="constant">    TTGDirectionLeft</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,
<span class="constant">    TTGDirectionRight</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,
<span class="constant">    TTGDirectionBottom</span> = <span class="number">1</span> &lt;&lt; <span class="number">3</span>
} TTGDirection;
</code></pre><p>看，这里的选项是用<strong>位运算</strong>的方式定义的，这样的好处就是，我们的选项变量可以如下表示：</p>
<pre><code><span class="comment">//用“或”运算同时赋值多个选项</span>
TTGDirection direction = TTGDirectionTop | TTGDirectionLeft | TTGDirectionBottom;

<span class="comment">//用“与”运算取出对应位</span>
<span class="keyword">if</span> (direction &amp; TTGDirectionTop) {
    <span class="built_in">NSLog</span>(<span class="string">@"top"</span>);
}
<span class="keyword">if</span> (direction &amp; TTGDirectionLeft) {
    <span class="built_in">NSLog</span>(<span class="string">@"left"</span>);
}
<span class="keyword">if</span> (direction &amp; TTGDirectionRight) {
    <span class="built_in">NSLog</span>(<span class="string">@"right"</span>);
}
<span class="keyword">if</span> (direction &amp; TTGDirectionBottom) {
    <span class="built_in">NSLog</span>(<span class="string">@"bottom"</span>);
}
</code></pre><p><strong>direction</strong>变量的实际内存如下：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_effective_objective_c_5_enum_2.jpg" alt="image"></p>
<p>这样，用位运算，就可以同时支持多个值。</p>
<h2 id="enum在Objective-C中的“升级版”">enum在Objective-C中的“升级版”</h2><p>一般来说，我们不能指定枚举变量的实际类型是什么，就是说，我们不知道枚举最后是int型，还是其他的什么类型。但是从C++ 11开始，我们可以为枚举指定其实际的存储类型，如下语法：</p>
<pre><code><span class="tag">enum</span> <span class="rule"><span class="attribute">TTGState </span>:<span class="value"> NSInteger {<span class="comment">/*...*/</span>}</span></span>;
</code></pre><p>但是，我们在定义枚举的时候如何保证兼容性呢？Foundation框架已经为我们提供了更加“统一、便捷”的枚举定义方法，我们重新定义上面的例子：</p>
<pre><code><span class="comment">//NS_ENUM，定义状态等普通枚举</span>
<span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, TTGState) {
    TTGStateOK = <span class="number">0</span>,
    TTGStateError,
    TTGStateUnknow
};

<span class="comment">//NS_OPTIONS，定义选项</span>
<span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, TTGDirection) {
    TTGDirectionNone = <span class="number">0</span>,
    TTGDirectionTop = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,
    TTGDirectionLeft = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,
    TTGDirectionRight = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,
    TTGDirectionBottom = <span class="number">1</span> &lt;&lt; <span class="number">3</span>
};
</code></pre><p>所以，在开发Mac、iOS程序中，最好所有的枚举都用“<strong>NS_ENUM</strong>”和“<strong>NS_OPTIONS</strong>”定义，保证统一。</p>
<h2 id="总结">总结</h2><p>充分的用好枚举，可以增强代码的可读性，减少各种“错误”，让代码更加的规范。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>Enum，也就是枚举，从C语言开始就有了，C++、Java、Objective-C、Swift这些语言，当然都有对应的枚举类型，功能可能有多有少，但是最核心的还是一个—-规范的定义代码中的状态、选项等“常量”。</p>
<h2 id="Item_5_-_Use_Enumerations_for_States,_Options,_and_Status_Codes">Item 5 - Use Enumerations for States, Options, and Status Codes</h2><p>本节的内容就是如何正确的使用枚举。</p>
<h2 id="状态与选项的区别（states_and_options）">状态与选项的区别（states and options）</h2><p>在用<strong>enum</strong>之前，我个人觉得，区分一下状态和选项的概念还是很必要的。</p>
<p><strong>状态</strong>，同时只能有一种，如“<strong>OK</strong>”，“<strong>Error</strong>”，不可能同时是OK和Error。<br><strong>选项</strong>，同时可以有一种或一种以上，如App可以<strong>同时</strong>支持横屏和竖屏，横屏竖屏在这个时候就是“屏幕方向”的两种不同的选项。</p>
<p>接下来，我们看看如何用枚举定义状态和选项。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[@autoreleasepool-内存的分配与释放]]></title>
    <link href="http://tutuge.me/2015/03/17/what-is-autoreleasepool/"/>
    <id>http://tutuge.me/2015/03/17/what-is-autoreleasepool/</id>
    <published>2015-03-17T12:21:56.000Z</published>
    <updated>2015-04-06T03:15:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>开发过iOS、Mac的朋友应该对“<strong>@autoreleasepool</strong>”不陌生。只要在Xcode里创建一个工程，就能看到下面这样的代码：</p>
<pre><code><span class="comment">//iOS program</span>
<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) {
    <span class="keyword">@autoreleasepool</span> {
        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate class]));
    }
}

<span class="comment">//Command line program</span>
<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[]) {
    <span class="keyword">@autoreleasepool</span> {
        <span class="comment">//...</span>
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>看，每个<strong>main</strong>函数的主体都被<strong>@autoreleasepool</strong>的Block块包在里面，也就是说，接下来所有的对象创建都在这个block里面。</p>
<p>那么，<strong>@autoreleasepool</strong>的作用到底是什么呢？我们开发中可以用它来做什么呢？  </p>
<p>可以在某些情况下，大幅度降低程序的内存占用，如下图:</p>
<p><img src="https://camo.githubusercontent.com/2c1f07459d33c72de07d8a9305703b2ba40abfc4/687474703a2f2f7a6f72726f6368656e2e71696e6975646e2e636f6d2f626c6f675f776861745f69735f6175746f72656c65617365706f6f6c5f312e706e673f696d61676556696577322f302f682f343030" alt="image"></p>
<ul>
<li>测试的内容：500000次循环，每次循环创建一个NSNumber实例和两个NSString实例。</li>
<li>图：红线表示没有用<strong>@autoreleasepool</strong>时的内存占用。</li>
<li>图：绿线表示用了<strong>@autoreleasepool</strong>优化后的内存占用！</li>
</ul>
<p>效果是不是很明显！</p>
<p>代码Github地址：<a href="https://github.com/zekunyan/AutoReleasePoolTestExample" target="_blank" rel="external">AutoReleasePoolTestExample</a> Xcode 6, iOS 8, iPhone 5模拟器.</p>
<a id="more"></a>
<h2 id="MRC_与_ARC">MRC 与 ARC</h2><p>MRC（Mannul Reference Counting）和ARC(Automatic Reference Counting)，分别对应着手动引用计数和自动引用计数。  </p>
<p>对！是计数，不是“<strong>GC、垃圾回收</strong>”什么的，就是说，在Objective-C的开发中，ARC不代表像Java那样有GC做垃圾回收，所以本质上还是要“手动”管理内存的。也就是说，我们在ARC环境下写的代码，不用自己手动插入“<strong>retain、release这些消息</strong>”，ARC会在编译时为我们在合适的位置插入，释放不必要的内存。</p>
<p>而<strong>@autoreleasepool</strong>就跟对象的<strong>release</strong>密切相关。</p>
<h2 id="@autoreleasepool_干了啥">@autoreleasepool 干了啥</h2><p>在MRC时代，如果我们想先retain一个对象，但是并不知道在什么时候可以release它，我们可以像下面这么做：</p>
<pre><code><span class="name">NSAutoreleasePool</span> *<span class="atom">pool</span> = [[<span class="name">NSAutoreleasePool</span> <span class="atom">alloc</span>] <span class="atom">init</span>];

<span class="name">NSString</span>* <span class="atom">str</span> = [[[<span class="name">NSString</span> <span class="atom">alloc</span>] <span class="atom">initWithString</span>:@<span class="string">"tutuge"</span>] <span class="atom">autorelease</span>];
//<span class="atom">use</span> <span class="atom">str</span>...

[<span class="atom">pool</span> <span class="atom">release</span>];
//<span class="atom">str</span> <span class="atom">is</span> <span class="atom">released</span>
</code></pre><p>就是说，我们可以在创建对象的时候给对象发送“<strong>autorelease</strong>”消息，然后当<strong>NSAutoreleasePool</strong>结束的时候，“标记过”autorelease的对象都会被“<strong>release</strong>”掉，也就是会被释放掉。</p>
<p>但是在ARC时代，我们不用手动发送<strong>autorelease</strong>消息，ARC会自动帮我们加。而这个时候，<strong>@autoreleasepool</strong>做的事情，跟<strong>NSAutoreleasePool</strong>就一模一样了。</p>
<h2 id="什么时候用@autoreleasepool">什么时候用@autoreleasepool</h2><p>根据<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html" target="_blank" rel="external">Apple的文档</a>，使用场景如下：</p>
<ul>
<li>写基于命令行的的程序时，就是没有UI框架，如AppKit等Cocoa框架时。</li>
<li>写循环，循环里面包含了大量临时创建的对象。（本文的例子）</li>
<li>创建了新的线程。（非Cocoa程序创建线程时才需要）</li>
<li>长时间在后台运行的任务。</li>
</ul>
<h2 id="利用@autoreleasepool优化循环">利用@autoreleasepool优化循环</h2><p>利用@autoreleasepool优化循环的内存占用，我觉得最有用的一点，下面就说说这个点。<br>如下面的循环，次数非常多，而且循环体里面的对象都是临时创建使用的，就可以用<strong>@autoreleasepool</strong>包起来，让每次循环结束时，可以及时的释放临时对象的内存。</p>
<pre><code><span class="comment">//来自Apple文档，见参考</span>
<span class="built_in">NSArray</span> *urls = &lt;<span class="preprocessor"># An array of file URLs #&gt;;</span>
<span class="keyword">for</span> (<span class="built_in">NSURL</span> *url <span class="keyword">in</span> urls) {

    <span class="keyword">@autoreleasepool</span> {
        <span class="built_in">NSError</span> *error;
        <span class="built_in">NSString</span> *fileContents = [<span class="built_in">NSString</span> stringWithContentsOfURL:url
                                         encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];
        <span class="comment">/* Process the string, creating and autoreleasing more objects. */</span>
    }
}
</code></pre><p>这么做的效果是极其显著地，就如本文最开始的图一样，可以自己把示例工程下回来运行下试试~</p>
<h2 id="总结">总结</h2><p><strong>@autoreleasepool</strong>看起来很不“起眼”，平常开发很容易就忽略它了，但是仔细一看，确如此有用~</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html" target="_blank" rel="external">Using Autorelease Pool Blocks</a></li>
<li><a href="http://stackoverflow.com/questions/14677049/what-is-autoreleasepool-objective-c" target="_blank" rel="external">What is autoreleasepool? - Objective-C</a></li>
<li><a href="http://stackoverflow.com/questions/9086913/objective-c-why-is-autorelease-autoreleasepool-still-needed-with-arc" target="_blank" rel="external">Objective-C: Why is autorelease (@autoreleasepool) still needed with ARC?</a></li>
<li><a href="http://blog.zilongshanren.com/blog/2013/12/20/what-is-autorelease-pool/" target="_blank" rel="external">What-is-autorelease-pool?</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html" target="_blank" rel="external">NSAutoreleasePool</a></li>
</ul>
<h3 id="示例中的第三方库">示例中的第三方库</h3><p><a href="https://github.com/kevinzhow/PNChart" target="_blank" rel="external">PNChart</a></p>
<h3 id="运行中用代码获取App运行消耗内存">运行中用代码获取App运行消耗内存</h3><p><a href="http://stackoverflow.com/questions/787160/programmatically-retrieve-memory-usage-on-iphone" target="_blank" rel="external">Programmatically retrieve memory usage on iPhone</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>开发过iOS、Mac的朋友应该对“<strong>@autoreleasepool</strong>”不陌生。只要在Xcode里创建一个工程，就能看到下面这样的代码：</p>
<pre><code><span class="comment">//iOS program</span>
<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) {
    <span class="keyword">@autoreleasepool</span> {
        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate class]));
    }
}

<span class="comment">//Command line program</span>
<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[]) {
    <span class="keyword">@autoreleasepool</span> {
        <span class="comment">//...</span>
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>看，每个<strong>main</strong>函数的主体都被<strong>@autoreleasepool</strong>的Block块包在里面，也就是说，接下来所有的对象创建都在这个block里面。</p>
<p>那么，<strong>@autoreleasepool</strong>的作用到底是什么呢？我们开发中可以用它来做什么呢？  </p>
<p>可以在某些情况下，大幅度降低程序的内存占用，如下图:</p>
<p><img src="https://camo.githubusercontent.com/2c1f07459d33c72de07d8a9305703b2ba40abfc4/687474703a2f2f7a6f72726f6368656e2e71696e6975646e2e636f6d2f626c6f675f776861745f69735f6175746f72656c65617365706f6f6c5f312e706e673f696d61676556696577322f302f682f343030" alt="image"></p>
<ul>
<li>测试的内容：500000次循环，每次循环创建一个NSNumber实例和两个NSString实例。</li>
<li>图：红线表示没有用<strong>@autoreleasepool</strong>时的内存占用。</li>
<li>图：绿线表示用了<strong>@autoreleasepool</strong>优化后的内存占用！</li>
</ul>
<p>效果是不是很明显！</p>
<p>代码Github地址：<a href="https://github.com/zekunyan/AutoReleasePoolTestExample">AutoReleasePoolTestExample</a> Xcode 6, iOS 8, iPhone 5模拟器.</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[有关宏定义的经验与技巧-简化代码-增强Log]]></title>
    <link href="http://tutuge.me/2015/03/15/%E6%9C%89%E5%85%B3%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E7%BB%8F%E9%AA%8C%E4%B8%8E%E6%8A%80%E5%B7%A7-%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81-%E5%A2%9E%E5%BC%BALog/"/>
    <id>http://tutuge.me/2015/03/15/有关宏定义的经验与技巧-简化代码-增强Log/</id>
    <published>2015-03-15T07:34:28.000Z</published>
    <updated>2015-04-06T03:13:27.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>宏定义、#define啥的，我们经常遇到。<br>一般来说，最常用的可能就是定义一些常量、简单的“函数”，如下：</p>
<pre><code>//定义常量<span class="constant">PI</span>
<span class="comment">#define PI 3.1415926</span>
<span class="comment">
//定义“函数”MIN</span>
<span class="comment">#define MIN(A,B) ((A) &lt; (B) ? (A) : (B))</span>
</code></pre><p>但是，这样定义常量、函数，有一定的风险。（见：<a href="http://tutuge.me/2015/03/11/Effective-Objective-C-读书笔记-Item-4-如何正确定义常量/" target="_blank" rel="external">Effective-Objective-C-读书笔记-Item-4-如何正确定义常量</a>, <a href="http://onevcat.com/2014/01/black-magic-in-macro/" target="_blank" rel="external">宏定义的黑魔法 - 宏菜鸟起飞手册</a>）</p>
<p>本文就列出几条我个人在iOS开发当中常用的经验与技巧。</p>
<a id="more"></a>
<h2 id="简化代码">简化代码</h2><p>在开发当中，我们可能会大量的写一些重复的，甚至具有“危险”的代码，用宏定义#define，往往可以简化代码，看看下面几个例子。</p>
<h3 id="GCD与#define">GCD与#define</h3><p><strong>dispatch_once</strong><br>项目中往往少不了各种单例类，我们一般会如下定义：</p>
<pre><code>+ (instancetype)sharedService {
    <span class="keyword">static</span> XXX *sharedService = <span class="literal">nil</span>;

    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;
    <span class="built_in">dispatch_once</span>, ^{
        sharedService = [XXX new];
    });

    <span class="keyword">return</span> sharedService;
}
</code></pre><p>这时候，就要注意几点：</p>
<ul>
<li>dispatch_once_t必须是<strong>static</strong>的，否则会各种报错=。=。</li>
<li><strong>dispatch_once</strong>的第一个参数必须取onceToken的地址，就是要“<strong>&amp;onceToken</strong>。”</li>
</ul>
<p>看，写个小小的单例都要这么注意，错了一点都很危险啊，而且总要重复写这几行。所以这个时候需要让宏定义帮忙：</p>
<pre><code><span class="comment">//定义宏定义</span>
<span class="preprocessor">#<span class="keyword">define</span> DISPATCH_ONCE_BLOCK(onceBlock) static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, onceBlock);</span>

+ (instancetype)sharedService {
    <span class="keyword">static</span> XXX *sharedService = nil;

    <span class="comment">//直接一行搞定</span>
    DISPATCH_ONCE_BLOCK(^{
        sharedService = [XXX <span class="keyword">new</span>];        
    })

    <span class="keyword">return</span> sharedService;
}
</code></pre><p>看，是不是变得更加简洁、“安全了”~</p>
<p><strong>dispatch_async</strong><br>除了dispatch_once，另一个常用的就是dispatch_async。不多说，直接看例子：</p>
<pre><code><span class="comment">//在Main线程上运行</span>
<span class="id">#define</span> <span class="tag">DISPATCH_ON_MAIN_THREAD</span>(mainQueueBlock) <span class="tag">dispatch_async</span>(<span class="function">dispatch_get_main_queue</span>(), <span class="tag">mainQueueBlock</span>);

<span class="comment">//在Global Queue上运行</span>
<span class="id">#define</span> <span class="tag">DISPATCH_ON_GLOBAL_QUEUE_HIGH</span>(globalQueueBlocl) <span class="tag">dispatch_async</span>(<span class="function">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), <span class="tag">globalQueueBlocl</span>);
<span class="id">#define</span> <span class="tag">DISPATCH_ON_GLOBAL_QUEUE_DEFAULT</span>(globalQueueBlocl) <span class="tag">dispatch_async</span>(<span class="function">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), <span class="tag">globalQueueBlocl</span>);
<span class="id">#define</span> <span class="tag">DISPATCH_ON_GLOBAL_QUEUE_LOW</span>(globalQueueBlocl) <span class="tag">dispatch_async</span>(<span class="function">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>), <span class="tag">globalQueueBlocl</span>);
<span class="id">#define</span> <span class="tag">DISPATCH_ON_GLOBAL_QUEUE_BACKGROUND</span>(globalQueueBlocl) <span class="tag">dispatch_async</span>(<span class="function">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>), <span class="tag">globalQueueBlocl</span>);

<span class="comment">//主线程上</span>
<span class="tag">DISPATCH_ON_MAIN_THREAD</span>(^{
    <span class="comment">//更新UI</span>
})

<span class="comment">//Global Queue </span>
<span class="tag">DISPATCH_ON_GLOBAL_QUEUE_DEFAULT</span>(^{
    <span class="comment">//异步耗时任务</span>
})
</code></pre><p>再也不用写一大堆”dispatch_async(dispatch_get_global_queue”了~看起来是不是很清爽~</p>
<h3 id="能一行搞定，干嘛还要写多行">能一行搞定，干嘛还要写多行</h3><p>很多时候，我们写的函数、方法都会在起始的地方加一些公共的判断，条件满足了才可以继续往下运行，如“用户是否登录”、“某个模块是否加载完成”等等，所以，我们可能会写如下样子的代码：</p>
<pre><code>- (<span class="keyword">void</span>)doSomething {
    <span class="keyword">if</span> (![[XXXAccountService sharedService] isLogin]) {
        <span class="keyword">return</span>;
    }
    <span class="comment">//do staff...</span>
}

- (<span class="keyword">void</span>)doSomething2 {
    <span class="keyword">if</span> (![[XXXAccountService sharedService] isLogin]) {
        <span class="keyword">return</span>;
    }
    <span class="comment">//do staff...</span>
}
</code></pre><p>每次都要这么写，是不是感觉很浪费时间？而且重复的好多=。=<br>所以，我们要用#define，把3行变成一行:</p>
<pre><code><span class="comment">//定义</span>
<span class="preprocessor">#<span class="keyword">define</span> CHECK_LOGIN_IN <span class="keyword">if</span> (![[XXXAccountService sharedService] isLogin]) {return;}</span>

- (<span class="keyword">void</span>)doSomething {
    CHECK_LOGIN_IN
    <span class="comment">//do staff...</span>
}

- (<span class="keyword">void</span>)doSomething2 {
    CHECK_LOGIN_IN
    <span class="comment">//do staff...</span>
}
</code></pre><p>其实#define的原理就是不管三七二十一，直接做替换，所以我们完全可以利用这个特点，发挥自己的想象，简化代码~</p>
<h2 id="宏定义与Log">宏定义与Log</h2><p>打Log，是个永恒的话题。  </p>
<h3 id="NSLog增强版">NSLog增强版</h3><p>我们会经常用到<strong>NSLog</strong>打Log，但是，这个函数能提供的信息非常少，所以，下面就是一个增强版, 最好定义在项目的pch文件中：</p>
<pre><code><span class="comment">#define NSLog(format, ...) \</span>
    <span class="keyword">do</span> { <span class="string">\</span>
        NSLog(@<span class="string">"&lt;%@ : %d : %s&gt;-: %@"</span>, <span class="string">\</span>
        [[NSString <span class="attribute">stringWithUTF8String</span>:__FILE__] lastPathComponent], <span class="string">\</span>
        __LINE__, <span class="string">\</span>
        __FUNCTION__, <span class="string">\</span>
        [NSString <span class="attribute">stringWithFormat</span>:format, <span class="comment">##__VA_ARGS__]); \</span>
    } <span class="keyword">while</span>(<span class="number">0</span>)
</code></pre><p>使用：    </p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>{
    <span class="annotation">@autoreleasepool</span> {
        NSLog(@<span class="string">"Blog: %@"</span>, @<span class="string">"http://tutuge.me"</span>);
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>输出：</p>
<pre><code>&lt;main.<span class="string">m :</span> <span class="number">22</span> : main&gt;-: <span class="string">Blog:</span> <span class="string">http:</span><span class="comment">//tutuge.me</span>
</code></pre><p>看，这下Log就带上了文件名、行号、函数名，一下子就清楚多了~<br>至于为什么要用这个奇怪的“do{…}while(0)”，其实就是为了防止在不同的使用场景中导致语法错误，详细请见：<a href="http://onevcat.com/2014/01/black-magic-in-macro/" target="_blank" rel="external">宏定义的黑魔法 - 宏菜鸟起飞手册</a></p>
<h3 id="为Log增加全局开关">为Log增加全局开关</h3><p>开发中，我们往往会在许多地方加上Log，但是在发布的时候，又不想显示这些Log，这个时候难道要一个一个的删除打Log的地方？<br>所以，为了增加开关，我们需要将上面的增强型NSLog改造一下：</p>
<pre><code><span class="comment">//判断是否要Log</span>
<span class="preprocessor">#ifdef NEED_DEBUG    </span>
<span class="preprocessor">#define NSLog(format, ...) \</span>
    <span class="comment">//Log定义...</span>
<span class="preprocessor">#else</span>
    #define NSLog(format, ...) <span class="keyword">do</span>{ } <span class="keyword">while</span>(<span class="number">0</span>)
<span class="preprocessor">#endif</span>
</code></pre><p>所以，当我们需要Log的时候，在上面定义的之前加上下面这一行：</p>
<pre><code><span class="hexcolor">#def</span>ine NEED_DEBUG
</code></pre><p>就可以打开Log了。不加的话，就不会有Log~简单的条件编译~</p>
<h3 id="为Log增加等级">为Log增加等级</h3><p>开发过Android的应该都知道，Android里面可以很方便的用Log.i、Log.d输出不同“等级”的Log，调试更加方便，NSLog却不行。所以，还是要借助宏定义：</p>
<pre><code><span class="comment">//Debug等级Log, 在此之前定义自己的NSLog</span>
<span class="preprocessor">#ifdef LOG_LEVEL_DEBUG</span>
    <span class="preprocessor">#<span class="keyword">define</span> DLog(format, ...) NSLog(@"&lt;DEBUG&gt;: %@", [NSString stringWithFormat:format, ##__VA_ARGS__])</span>
<span class="preprocessor">#<span class="keyword">else</span></span>
    <span class="preprocessor">#<span class="keyword">define</span> DLog(format, ...) do{ } while(0)</span>
<span class="preprocessor">#<span class="keyword">endif</span></span>

<span class="comment">//Info等级Log</span>
<span class="preprocessor">#ifdef LOG_LEVEL_INFO</span>
    <span class="preprocessor">#<span class="keyword">define</span> ILog(format, ...) NSLog(@"&lt;Info&gt;: %@", [NSString stringWithFormat:format, ##__VA_ARGS__])</span>
<span class="preprocessor">#<span class="keyword">else</span></span>
    <span class="preprocessor">#<span class="keyword">define</span> ILog(format, ...) do{ } while(0)</span>
<span class="preprocessor">#<span class="keyword">endif</span></span>

<span class="comment">//Error等级Log</span>
<span class="preprocessor">#ifdef LOG_LEVEL_ERROR</span>
    <span class="preprocessor">#<span class="keyword">define</span> ELog(format, ...) NSLog(@"&lt;Error&gt;: %@", [NSString stringWithFormat:format, ##__VA_ARGS__])</span>
<span class="preprocessor">#<span class="keyword">else</span></span>
    <span class="preprocessor">#<span class="keyword">define</span> ELog(format, ...) do{ } while(0)</span>
<span class="preprocessor">#<span class="keyword">endif</span></span>
</code></pre><p>当我们在打Log的时候，就可以根据需要，用不同等级的Log，而且可以方便的定制需要输出哪几种，并且之前的“增强版”NSLog也可以使用。</p>
<p>完整的请看<a href="https://gist.github.com/zekunyan/2f2356136b9b40348584" target="_blank" rel="external">Gist</a>.</p>
<h2 id="其它">其它</h2><p>还有一些简单好用的宏定义，在这就只举几个典型的例子了~</p>
<h3 id="打印自定义类型信息">打印自定义类型信息</h3><p>假如有如下结构体定义(自定义类的话，直接重写description方法即可):</p>
<pre><code><span class="comment">//复数结构体</span>
typedef <span class="keyword">struct</span> Complex {
    float r; <span class="comment">//实部</span>
    float i; <span class="comment">//虚部</span>
} Complex;

<span class="comment">//定义打印Complex类型的宏</span>
<span class="comment">//输出：(1+2i), (1-2i)</span>
#define NSLogComplex(<span class="built_in">complex</span>) NSLog(@<span class="string">"Complex: (%g%s%gi)"</span>, <span class="built_in">complex</span>.r, (<span class="built_in">complex</span>.i &gt; <span class="number">0</span> ? <span class="string">"+"</span> : <span class="string">""</span>), <span class="built_in">complex</span>.i)
</code></pre><h3 id="常用函数简化、单例获取">常用函数简化、单例获取</h3><pre><code><span class="comment">//获取View的属性</span>
<span class="hexcolor">#def</span>ine <span class="function"><span class="title">GetViewWidth</span><span class="params">(view)</span></span>  view<span class="class">.frame</span><span class="class">.size</span><span class="class">.width</span>
<span class="hexcolor">#def</span>ine <span class="function"><span class="title">GetViewHeight</span><span class="params">(view)</span></span> view<span class="class">.frame</span><span class="class">.size</span><span class="class">.height</span>
<span class="hexcolor">#def</span>ine <span class="function"><span class="title">GetViewX</span><span class="params">(view)</span></span>      view<span class="class">.frame</span><span class="class">.origin</span><span class="class">.x</span>
<span class="hexcolor">#def</span>ine <span class="function"><span class="title">GetViewY</span><span class="params">(view)</span></span>      view<span class="class">.frame</span><span class="class">.origin</span><span class="class">.y</span>

<span class="comment">//屏幕常量</span>
<span class="hexcolor">#def</span>ine GetScreenWidth      [[UIScreen mainScreen] bounds]<span class="class">.size</span><span class="class">.width</span>
<span class="hexcolor">#def</span>ine GetScreenHeight     [[UIScreen mainScreen] bounds]<span class="class">.size</span><span class="class">.height</span>

<span class="comment">//获取图片资源</span>
<span class="hexcolor">#def</span>ine <span class="function"><span class="title">GetImage</span><span class="params">(imageName)</span></span> [UIImage imageNamed:[NSString stringWithFormat:@<span class="string">"%@"</span>,imageName]]

<span class="comment">//等等~只要你想得到~</span>
</code></pre><h2 id="总结">总结</h2><p>宏定义的各种Tip还远远不止这些，合理使用它，可以有效改善代码的阅读质量~</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://gcc.gnu.org/onlinedocs/cpp/index.html" target="_blank" rel="external">The C Preprocessor</a></li>
<li><a href="http://onevcat.com/2014/01/black-magic-in-macro/" target="_blank" rel="external">宏定义的黑魔法 - 宏菜鸟起飞手册</a></li>
</ul>
<p>I</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>宏定义、#define啥的，我们经常遇到。<br>一般来说，最常用的可能就是定义一些常量、简单的“函数”，如下：</p>
<pre><code>//定义常量<span class="constant">PI</span>
<span class="comment">#define PI 3.1415926</span>
<span class="comment">
//定义“函数”MIN</span>
<span class="comment">#define MIN(A,B) ((A) &lt; (B) ? (A) : (B))</span>
</code></pre><p>但是，这样定义常量、函数，有一定的风险。（见：<a href="http://tutuge.me/2015/03/11/Effective-Objective-C-读书笔记-Item-4-如何正确定义常量/">Effective-Objective-C-读书笔记-Item-4-如何正确定义常量</a>, <a href="http://onevcat.com/2014/01/black-magic-in-macro/">宏定义的黑魔法 - 宏菜鸟起飞手册</a>）</p>
<p>本文就列出几条我个人在iOS开发当中常用的经验与技巧。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="技巧" scheme="http://tutuge.me/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Effective-Objective-C-读书笔记-Item-4-如何正确定义常量]]></title>
    <link href="http://tutuge.me/2015/03/11/Effective-Objective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Item-4-%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F/"/>
    <id>http://tutuge.me/2015/03/11/Effective-Objective-C-读书笔记-Item-4-如何正确定义常量/</id>
    <published>2015-03-10T16:07:23.000Z</published>
    <updated>2015-04-06T03:14:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>写博客果然比光看书要花时间=。=，书都快看完了，才写到第4节。但是总结一遍，的确印象深刻啊~~  </p>
<p>这次的主题是“<strong>常量</strong>”，非常常用，又非常重要的东西~良好的代码规范、设计，少不了各种<strong>常量</strong>。</p>
<h2 id="Item_4_-_Prefer_Typed_Constants_to_Preprocessor_#define">Item 4 - Prefer Typed Constants to Preprocessor #define</h2><p>本节着重对比了常量的定义形式，类型常量和#define的区别、各自的特点。最后得出，我们应该用带有类型的常量，而不是#define。</p>
<a id="more"></a>
<h2 id="一个简单的示例">一个简单的示例</h2><p>应用中，少不了各种动画，也就少不了设定动画的时间长度，一般来说，我们会设定短、中、长几种时间常量，用于不同的场合，了解C语言的童鞋估计对“<strong>#define</strong>”宏定义不陌生，于是，可能就会如下这么定义：</p>
<pre><code><span class="hexcolor">#def</span>ine ANIMATION_DURATION_SHORT <span class="number">0.3</span>
<span class="hexcolor">#def</span>ine ANIMATION_DURATION_MIDDLE <span class="number">0.6</span>
<span class="hexcolor">#def</span>ine ANIMATION_DURATION_LONG <span class="number">1.0</span>
</code></pre><p>于是，所有用到动画时长的地方，直接用这几个宏定义就行了。  </p>
<p>乍一看，似乎没什么问题。</p>
<h3 id="类型+不可变">类型+不可变</h3><p>先来看看宏定义干了什么。<br>总的来说，#define就是“替换”，在编译时，将一切宏定义替换成定义后面的内容。（参考<a href="http://baike.baidu.com/view/2076445.htm" target="_blank" rel="external">百度百科</a>）  </p>
<p>关键在于：</p>
<ul>
<li>宏定义不会检查替换的“<strong>类型</strong>”，只要遇到，就做替换。</li>
<li>宏定义不保证“<strong>不可变</strong>”，因为可以<strong>重复定义</strong>，不能保证值不变。(这个我觉得是最容易让人忽略的地方)</li>
</ul>
<p>所以，用宏定义定义常量，很“危险”。</p>
<h2 id="正确的做法">正确的做法</h2><p>恰当的常量，应该具备合适的常量名字、正确的类型，还有const、extern等关键字的修饰，当然，还要根据常量适用的“<strong>范围</strong>”，做出恰当的处理。一下举例说明。</p>
<h3 id="只在函数中用的常量">只在函数中用的常量</h3><p>只在函数中用的常量：</p>
<pre><code>- (<span class="keyword">void</span>)runAnimation {
    <span class="comment">//动画时间长度常量</span>
    <span class="keyword">static</span> <span class="keyword">const</span> NSTimeInterval kAnimationDurationLong = <span class="number">1.0f</span>;

    <span class="comment">//...</span>
}
</code></pre><p>static、const定义了它是静态不可变的；<strong>NSTimeInterval</strong>则“精确”指定了常量的类型。</p>
<h3 id="只在一个“-m”文件中使用的常量">只在一个“<strong>.m</strong>”文件中使用的常量</h3><p>在类的实现文件“xxx.m”文件中定义常量，也是很常见的。<br>你可能会觉得，既然是一个类使用的，那就放在类的头文件里面定义不就好了。<br><strong>但是这么想是错的=。=</strong><br><strong>因为所有要用到这个类的文件，都会无形当中包含了这些常量声明，将不必要的数据暴露在外面，这样是违反设计原则的，并且，如果常量名字取得不恰当，还有可能造成冲突。</strong></p>
<p>所以，应该如下:</p>
<pre><code><span class="comment">//<span class="label">XXX.m</span></span>

<span class="comment">//必须要static</span>
<span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> kAnimationDurationLong = <span class="number">1.0</span>f;

<span class="class"><span class="keyword">@implementation</span> <span class="title">XXX</span></span>
<span class="comment">//...</span>
<span class="keyword">@end</span> 
</code></pre><p>需要注意的点：</p>
<ul>
<li>一定要放在.m文件中。</li>
<li>必须是<strong>static</strong>，表示此常量作用域只在此.m文件中。如果不加static的话，常量就会在全局作用域中声明，可能会导致跟其他的常量冲突。</li>
<li>const，当然。</li>
<li>NSTimeInterval，确定的类型。</li>
<li>kAnimationDurationLong，“<strong>k</strong>”开头的命名，也算是Apple的规范了吧，内部常量统一以“<strong>k</strong>”开头。</li>
</ul>
<h3 id="全局常量">全局常量</h3><p>一般来说，最常见的全局常量就是发广播Notification时用的Notification的名字，往往都是一些字符串，下面就以这个为例子：</p>
<p>假设我们的类叫“<strong>TTGClass</strong>”，我们的类会向外发送Notification，所以需要定义一个Notification的名字常量供外界注册，如下：</p>
<pre><code><span class="comment">//TTGClass.h</span>
<span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> TTGClassWorkBeginNotification;

<span class="comment">//TTGClass.m</span>
<span class="built_in">NSString</span> * <span class="keyword">const</span> TTGClassWorkBeginNotification = <span class="string">@"TTGClassWorkBeginNotification"</span>;
</code></pre><p>关键：</p>
<ul>
<li>头文件中只是做声明，不做定义。所以用extern表示常量在别处定义的，尽量隐藏细节。</li>
<li>同<strong>类名</strong>做常量名字的开头，<strong>这个非常关键，因为Objective-C里面没有像Java那样的“包”机制，所以必须靠命名来划分不同的类，常量当然也要遵循这个规则。</strong></li>
<li>NSString，确定的类型；const，表明常量；Notification后缀，表明用途。这些都是需要注意的。</li>
</ul>
<h2 id="总结">总结</h2><p>良好的代码，总是少不了定义各种常量，以避免“魔鬼数字、魔鬼字符串”。所以我们应该尽量避免少用#define定义常量，而是用带有类型的、const的常量，并且尽可能的缩小常量的作用域。  </p>
<p>暴露的细节越少，出错的机会也就越小（忘了从哪里看到的=。=）</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>写博客果然比光看书要花时间=。=，书都快看完了，才写到第4节。但是总结一遍，的确印象深刻啊~~  </p>
<p>这次的主题是“<strong>常量</strong>”，非常常用，又非常重要的东西~良好的代码规范、设计，少不了各种<strong>常量</strong>。</p>
<h2 id="Item_4_-_Prefer_Typed_Constants_to_Preprocessor_#define">Item 4 - Prefer Typed Constants to Preprocessor #define</h2><p>本节着重对比了常量的定义形式，类型常量和#define的区别、各自的特点。最后得出，我们应该用带有类型的常量，而不是#define。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="笔记" scheme="http://tutuge.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="翻译" scheme="http://tutuge.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UITextView编辑时插入自定义表情-简单的图文混编]]></title>
    <link href="http://tutuge.me/2015/03/07/UITextView%E7%BC%96%E8%BE%91%E6%97%B6%E6%8F%92%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E6%83%85-%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BE%E6%96%87%E6%B7%B7%E7%BC%96/"/>
    <id>http://tutuge.me/2015/03/07/UITextView编辑时插入自定义表情-简单的图文混编/</id>
    <published>2015-03-07T03:04:38.000Z</published>
    <updated>2015-04-06T03:15:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在iOS开发中，经常需要用UITextView作为编辑文本的输入控件。<br>但是如何在编辑时插入自定义表情呢？就是像发微博时那样？  </p>
<p>本文简单的用<strong>NSTextAttachment</strong>、<strong>NSAttributedString</strong>的特性，实现了</p>
<ul>
<li>在UITextView中编辑文字时插入自定义表情图片</li>
<li>同时可以返回带有表情“<strong>替换符</strong>”的纯文本字符串。</li>
</ul>
<h2 id="示例">示例</h2><p>本文代码工程地址：<a href="https://github.com/zekunyan/UITextViewDIYEmojiExample" target="_blank" rel="external">https://github.com/zekunyan/UITextViewDIYEmojiExample</a></p>
<p>效果图：</p>
<p><img src="http://zorrochen.qiniudn.com/inputEmoji_Sample.gif" alt="image"></p>
<a id="more"></a>
<h2 id="背景知识">背景知识</h2><ul>
<li>NSAttributedString及其子类，用于显示富文本。</li>
<li>NSTextAttachment，NSAttributedString的一种样式类，可以在文本中显示图片。</li>
<li>NSTextStorage，UITextView中的实际的文本封装。（见参考中的UITextView文档）</li>
</ul>
<h3 id="表情与其标志">表情与其标志</h3><p>首先需要明确的是，我们的自定义表情一定是有一一对应的“<strong>标志</strong>”的，如“<strong>[/emoji_haha]</strong>”。<br>就是说，为了方便处理，方便在数据库、网络传输中保存、传输带有表情图片的文本，我们必须要为每种表情取特定的“<strong>名字</strong>”，数据库中储存的、网络传输的文本就只包含这些标志名字就行，在显示的时候做对应的替换。</p>
<p>如：</p>
<p><strong>tutuge.me<img src="http://zorrochen.qiniudn.com/blog_uitextview_input_emoji_emoji_1.png" alt="image"></strong></p>
<p>对应的纯文本就是：</p>
<p><strong>tutuge.me[/emoji_1]</strong></p>
<h2 id="插入并显示表情图片">插入并显示表情图片</h2><p>插入表情很简单，直接实例化<strong>NSTextAttachment</strong>类，将需要的表情的UIImage实例赋值给NSTextAttachment的image属性，然后用“<strong>[NSAttributedString attributedStringWithAttachment:]</strong>”方法实例化一个NSAttributedString的对象，插入到UITextView的textStorage对应的位置即可。</p>
<p>如下：</p>
<pre><code>NSTextAttachment *emojiTextAttachment = [NSTextAttachment <span class="keyword">new</span>];

<span class="comment">//设置表情图片</span>
emojiTextAttachment.image = emojiImage;

<span class="comment">//插入表情</span>
[textView.textStorage <span class="string">insertAttributedString:</span>[NSAttributedString <span class="string">attributedStringWithAttachment:</span>emojiTextAttachment]
<span class="label">                                      atIndex:</span>textView.selectedRange.location];
</code></pre><p>这样，就能在UITextView当前光标位置插入表情图片了。</p>
<h2 id="获取带有表情标志的文本字符串">获取带有表情标志的文本字符串</h2><h3 id="难点">难点</h3><p>NSTextAttachment被插入到NSAttributedString中的时候，<strong>就被当成了一个字符处理！！！</strong>。<br>就是说，只从UITextView的text中，是找不回文本里面不同的表情所对应的标志的！  </p>
<h3 id="解决点">解决点</h3><ol>
<li>我们要能遍历出当前文本中所有的表情，也就是NSTextAttachment类。</li>
<li>我们要能知道遍历出的表情，对应的标志是什么。</li>
</ol>
<h3 id="遍历所有的NSTextAttachment类属性">遍历所有的NSTextAttachment类属性</h3><p>遍历，嗯，先看看Apple有没有提供相应的方法，能遍历NSAttributedString（及其子类）的属性的。查阅文档：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAttributedString_Class/index.html#//apple_ref/occ/instm/NSAttributedString" target="_blank" rel="external">NSAttributedString Class Reference</a>，可以找到这么一个方法：“<strong>- enumerateAttribute:inRange:options:usingBlock:</strong>”，其原型如下：</p>
<pre><code>- (<span class="keyword">void</span>)enumerateAttribute:(<span class="built_in">NSString</span> *)attrName
                   inRange:(<span class="built_in">NSRange</span>)enumerationRange
                   options:(<span class="built_in">NSAttributedStringEnumerationOptions</span>)opts
                usingBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> value,
                                     <span class="built_in">NSRange</span> range,
                                     <span class="built_in">BOOL</span> *stop))block
</code></pre><p>用处：</p>
<pre><code>Executes <span class="operator">the</span> Block <span class="keyword">for</span> <span class="operator">the</span> specified attribute run <span class="operator">in</span> <span class="operator">the</span> specified range.
</code></pre><p>看，就是这个方法~就能遍历出NSTextAttachment对象了~</p>
<h3 id="创建NSTextAttachment的子类">创建NSTextAttachment的子类</h3><p>如何绑定NSTextAttachment所表示的表情和与其对应的标志？创建子类嘛~直接在子类中增加属性，保存标志不就行了。<br>如下：</p>
<pre><code><span class="variable">@interface</span> <span class="attribute">EmojiTextAttachment </span>: NSTextAttachment
<span class="variable">@property</span>(strong, nonatomic) NSString *emojiTag;
<span class="variable">@end</span>
</code></pre><p>所以，这个时候，插入表情的代码应该就是下面这样：</p>
<pre><code>EmojiTextAttachment *emojiTextAttachment = [EmojiTextAttachment <span class="keyword">new</span>];

<span class="comment">//保存表情标志</span>
emojiTextAttachment.emojiTag = emojiTag;

<span class="comment">//设置表情图片</span>
emojiTextAttachment.image = emojiImage;

<span class="comment">//插入表情</span>
[textView.textStorage <span class="string">insertAttributedString:</span>[NSAttributedString <span class="string">attributedStringWithAttachment:</span>emojiTextAttachment]
<span class="label">                                      atIndex:</span>textView.selectedRange.location];
</code></pre><h3 id="创建NSAttributedString的Category">创建NSAttributedString的Category</h3><p>最后，就是将这个遍历表情、拼接最终文本字符串的方法设置成NSAttributedString的自定义Category方法，以方便直接调用。<br>当然，这里面有些细节的处理，如替换表情标志时的字符串偏移量计算等，看代码吧。  </p>
<p>如下：</p>
<pre><code><span class="comment">//NSAttributedString+EmojiExtension.h</span>

<span class="class"><span class="keyword">@interface</span> <span class="title">NSAttributedString</span> (<span class="title">EmojiExtension</span>)</span>
- (<span class="built_in">NSString</span> *)getPlainString;
<span class="keyword">@end</span>


<span class="comment">//NSAttributedString+EmojiExtension.m</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">NSAttributedString</span> (<span class="title">EmojiExtension</span>)</span>

- (<span class="built_in">NSString</span> *)getPlainString {

    <span class="comment">//最终纯文本</span>
    <span class="built_in">NSMutableString</span> *plainString = [<span class="built_in">NSMutableString</span> stringWithString:<span class="keyword">self</span><span class="variable">.string</span>];

    <span class="comment">//替换下标的偏移量</span>
    __block <span class="built_in">NSUInteger</span> base = <span class="number">0</span>;

    <span class="comment">//遍历</span>
    [<span class="keyword">self</span> enumerateAttribute:<span class="built_in">NSAttachmentAttributeName</span> inRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="keyword">self</span><span class="variable">.length</span>)
                     options:<span class="number">0</span>
                  usingBlock:^(<span class="keyword">id</span> value, <span class="built_in">NSRange</span> range, <span class="built_in">BOOL</span> *stop) {

                      <span class="comment">//检查类型是否是自定义NSTextAttachment类</span>
                      <span class="keyword">if</span> (value &amp;&amp; [value isKindOfClass:[EmojiTextAttachment class]]) {
                          <span class="comment">//替换</span>
                          [plainString replaceCharactersInRange:<span class="built_in">NSMakeRange</span>(range<span class="variable">.location</span> + base, range<span class="variable">.length</span>)
                                                     withString:((EmojiTextAttachment *) value)<span class="variable">.emojiTag</span>];

                       <span class="comment">//增加偏移量                          </span>
                          base += ((EmojiTextAttachment *) value)<span class="variable">.emojiTag</span><span class="variable">.length</span> - <span class="number">1</span>;
                      }
                  }];

    <span class="keyword">return</span> plainString;
}

<span class="keyword">@end</span>
</code></pre><h3 id="使用">使用</h3><p>直接调用getPlainString方法即可。</p>
<h2 id="总结">总结</h2><p>其实本文也是来源于最近的项目需求，在网上一直找不到比较好的解决方案，就自己摸索出来一个。至于复杂的图文混合编辑，当然还是Core Text来的强大（自己也在学习中）~</p>
<p>如果有更好地办法，一定要告诉我啊~~~</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITextView_Class/#//apple_ref/occ/instp/UITextView/textStorage" target="_blank" rel="external">UITextView Class Reference</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAttributedString_Class/index.html#//apple_ref/occ/instm/NSAttributedString/enumerateAttribute:inRange:options:usingBlock:" target="_blank" rel="external">NSAttributedString Class Reference</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>在iOS开发中，经常需要用UITextView作为编辑文本的输入控件。<br>但是如何在编辑时插入自定义表情呢？就是像发微博时那样？  </p>
<p>本文简单的用<strong>NSTextAttachment</strong>、<strong>NSAttributedString</strong>的特性，实现了</p>
<ul>
<li>在UITextView中编辑文字时插入自定义表情图片</li>
<li>同时可以返回带有表情“<strong>替换符</strong>”的纯文本字符串。</li>
</ul>
<h2 id="示例">示例</h2><p>本文代码工程地址：<a href="https://github.com/zekunyan/UITextViewDIYEmojiExample">https://github.com/zekunyan/UITextViewDIYEmojiExample</a></p>
<p>效果图：</p>
<p><img src="http://zorrochen.qiniudn.com/inputEmoji_Sample.gif" alt="image"></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于评论不见了=。=]]></title>
    <link href="http://tutuge.me/2015/03/06/%E5%85%B3%E4%BA%8E%E8%AF%84%E8%AE%BA%E4%B8%8D%E8%A7%81%E4%BA%86/"/>
    <id>http://tutuge.me/2015/03/06/关于评论不见了/</id>
    <published>2015-03-06T01:09:32.000Z</published>
    <updated>2015-03-06T01:18:56.000Z</updated>
    <content type="html"><![CDATA[<p>前天升级了一次Hexo，原来的主题说啥也用不了了=。=（前端知识不足，正在补~）导致只能换主题，多说的评论就这样不见了。。。原来有留言的各位筒子，没看到，不好意思啊=。=</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前天升级了一次Hexo，原来的主题说啥也用不了了=。=（前端知识不足，正在补~）导致只能换主题，多说的评论就这样不见了。。。原来有留言的各位筒子，没看到，不好意思啊=。=</p>
]]>
    </summary>
    
      <category term="杂烩" scheme="http://tutuge.me/tags/%E6%9D%82%E7%83%A9/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Entity和Model的不同-关于代码的数据层]]></title>
    <link href="http://tutuge.me/2015/03/01/Entity%E5%92%8CModel%E7%9A%84%E4%B8%8D%E5%90%8C-%E5%85%B3%E4%BA%8E%E4%BB%A3%E7%A0%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%B1%82/"/>
    <id>http://tutuge.me/2015/03/01/Entity和Model的不同-关于代码的数据层/</id>
    <published>2015-03-01T15:03:10.000Z</published>
    <updated>2015-04-06T03:14:37.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>经常都能在一些博客、文档中看到“<strong>Model</strong>”、“<strong>Entity</strong>”的字样。如<strong>MVC</strong>模式中的“<strong>M就是Model</strong>”，“<strong>MVVM对应的Model-View-ViewModel</strong>”，数据库抽象层里面的“<strong>Model</strong>“等。  </p>
<p>它们的区别到底是什么？  </p>
<p>其实没有真正官方的对Entity和Model的定义，在此我只是说说我自己的理解。</p>
<a id="more"></a>
<h2 id="什么是Entity">什么是<strong>Entity</strong></h2><p>先看看这个单词是什么意思：<br><a href="http://www.iciba.com/entity" target="_blank" rel="external">爱词霸</a>：n: 实体，实际存在物，本质。</p>
<p>在代码中，我们经常会遇到一些具有“<strong>现实</strong>”意义的“<strong>个体</strong>”，如一个用户，一首歌曲，一条评论等等，它们都是在逻辑上完整的一个整体，都具有相似的结构，但是却因为“<strong>属性</strong>”的不同而不同。</p>
<p>看看一个典型的Entity类：</p>
<pre><code><span class="comment">//Java </span>

<span class="comment">//Entity类定义</span>
<span class="class"><span class="keyword">class</span> <span class="title">UserEntity</span> </span>{
    <span class="keyword">public</span> String name;
    <span class="keyword">public</span> <span class="keyword">int</span> age;
    <span class="keyword">public</span> String address;
}

<span class="comment">//Entity对象</span>
UserEntity john = <span class="keyword">new</span> UserEntity();
john.name = <span class="string">"John"</span>;
john.age = <span class="number">20</span>;
john.address = <span class="string">"China Hubei Wuhan"</span>;

UserEntity tom = <span class="keyword">new</span> UserEntity();
tom.name = <span class="string">"Tom"</span>;
tom.age = <span class="number">30</span>;
tom.address = <span class="string">"USA Californian"</span>;
</code></pre><p>所以：</p>
<ul>
<li>Entity类，或者说<strong>实体类</strong>，代表了一种“个体”，类中的属性（就是各种变量）则是这个“个体”的具体体现。如UserEntity类，里面有name、age属性，就是说Entity类“<strong>描述</strong>”了某种个体。</li>
<li>Entity类的具体对象，代表了一个具体的实体，一般来说，在代码当中，一个具体的Entity类对象所代表的实体应当是唯一的。</li>
<li>往往Entity类的定义跟数据库中的表定义是一一对应的。</li>
<li>而Entity的具体对象往往对应数据库中的一行数据。</li>
<li>Entity是代码中操作数据的“<strong>最小单元</strong>”。</li>
</ul>
<h2 id="什么是Model">什么是Model</h2><h3 id="各种用法">各种用法</h3><p>其实很多时候，Model有如下几种用法：</p>
<ol>
<li>当成Entity用，完全不具备其他业务逻辑代码。</li>
<li>当成<strong>数据库接口层</strong>，就是将数据库的读写，增删改查都封装在了Model中，往往就会有如“<strong>getUserByID</strong>”这样的方法。</li>
<li>当成纯粹的业务处理类。</li>
</ol>
<p>所以仁者见仁，智者见智，其实都可以。</p>
<p>在此说说我的认识。</p>
<h3 id="我的认识">我的认识</h3><p>先看看Model单词的意思:<br><a href="http://www.iciba.com/model" target="_blank" rel="external">爱词霸</a>：n: 模型；模式；典型。</p>
<p>既然是模型，而不是“数据”，所以我觉得，<strong>Model应该是利用Entity实体，来组合、处理、整合更上层、更抽象数据的类</strong>。</p>
<p>还是基于上面的“<strong>UserEntity</strong>”，看看下面的代码：</p>
<pre><code><span class="keyword">class</span> <span class="title">UserListModel</span> {
    <span class="keyword">private</span> UserEntity[] users;

    <span class="comment">//构造函数，初始化用户列表等。</span>

    <span class="function">UserEntity <span class="title">getUserByName</span><span class="params">(String name)</span> </span>{
        <span class="comment">//查找...</span>
    }

    <span class="keyword">void</span> transformUserAddressFormat {
        <span class="comment">//转化地址格式</span>
    }
}
</code></pre><p>就是说，Entity还是原本的概念，只不过Model是基于Entity的更高层的数据抽象与处理。</p>
<h2 id="总结">总结</h2><p>说实话，Entity、Model，它们的职责到底是什么，真的不好说明白，大家也就做个参考吧=。=</p>
<h2 id="参考">参考</h2><ul>
<li><a href="http://stackoverflow.com/questions/3029952/ddd-and-mvc-difference-between-model-and-entity" target="_blank" rel="external">DDD and MVC: Difference between ‘Model’ and ‘Entity’</a></li>
<li><a href="http://whatis.techtarget.com/definition/entity" target="_blank" rel="external">Whatis.com Entity</a></li>
<li><a href="http://blogsh.de/2011/09/08/models-vs-entities" target="_blank" rel="external">Models vs. Entities</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>经常都能在一些博客、文档中看到“<strong>Model</strong>”、“<strong>Entity</strong>”的字样。如<strong>MVC</strong>模式中的“<strong>M就是Model</strong>”，“<strong>MVVM对应的Model-View-ViewModel</strong>”，数据库抽象层里面的“<strong>Model</strong>“等。  </p>
<p>它们的区别到底是什么？  </p>
<p>其实没有真正官方的对Entity和Model的定义，在此我只是说说我自己的理解。</p>]]>
    
    </summary>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一次审核被拒的经历-关于iCloud到底应该备份什么数据]]></title>
    <link href="http://tutuge.me/2015/02/28/%E4%B8%80%E6%AC%A1%E5%AE%A1%E6%A0%B8%E8%A2%AB%E6%8B%92%E7%9A%84%E7%BB%8F%E5%8E%86-%E5%85%B3%E4%BA%8EiCloud%E5%88%B0%E5%BA%95%E5%BA%94%E8%AF%A5%E5%A4%87%E4%BB%BD%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE/"/>
    <id>http://tutuge.me/2015/02/28/一次审核被拒的经历-关于iCloud到底应该备份什么数据/</id>
    <published>2015-02-28T10:18:11.000Z</published>
    <updated>2015-04-06T03:13:15.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>项目最近一次审核被拒了=。=<br>仔细看了一下后，发现是没有遵守“<strong>iOS Data Storage Guidelines</strong>”。<br>在此总结一下。</p>
<h2 id="被拒原因">被拒原因</h2><p>先看看被拒的反馈信息：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apps must follow the iOS <span class="built_in">Data</span> Storage Guidelines <span class="literal">or</span> they will be rejected</span><br><span class="line"></span><br><span class="line"><span class="keyword">On</span> launch <span class="literal">and</span> content download, your app stores <span class="number">12.14</span> MB, which does <span class="literal">not</span> comply <span class="keyword">with</span> the iOS <span class="built_in">Data</span> Storage Guidelines<span class="built_in">.</span></span><br></pre></td></tr></table></figure>
<p>大致意思就是App下载东西以后，在iCloud里面查看此App需要备份的体积变大了。  </p>
<a id="more"></a>
<p>再根据 <a href="https://developer.apple.com/icloud/documentation/data-storage/index.html" target="_blank" rel="external"><strong>iOS Data Storage Guidelines</strong></a>的说明，得出几点重要信息：</p>
<ul>
<li>只有<strong>用户创建的，并且不能被App重现的文档、数据</strong>，才应该被保存在“<strong><application_home>/Documents</application_home></strong>”路径下。</li>
<li>可以重新产生、下载的数据可以放在“<strong><application_home>/Library/Caches</application_home></strong>”目录下，如用于缓存的数据库文件。</li>
<li>纯粹用于缓存的数据可以放在“<strong><application_home>/tmp</application_home></strong>”目录下。</li>
<li>可以通过对NSURL加参数，来保证特定的文件夹及其内容不被iCloud备份，也不会被清除，如Document文件夹。</li>
</ul>
<p>所以可以初步得出被拒的原因是因为App中下载的文件也被包含在iCloud备份当中了，而Apple审核人员觉得这些文件不应该被备份。</p>
<h3 id="真正应该备份的数据">真正应该备份的数据</h3><p>所以，真正需要备份的文件是<strong>用户创建的，不能通过程序重新产生的</strong>，如记事本应用中用户创建的文本数据，绘画应用中用户画的画等。</p>
<h2 id="解决当中遇到的坑">解决当中遇到的坑</h2><p>既然知道了原因，那就好办了。</p>
<p>根据<strong>iOS Data Storage Guidelines</strong>的简短说明，乍一看，<strong><application_home>/Library/Caches</application_home></strong>是存放可以重新产生、下载的数据。</p>
<p>但是有个“陷阱”在这。</p>
<h3 id="系统可能清空的目录">系统可能清空的目录</h3><p>根据官方文档“<a href="https://developer.apple.com/library/mac/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple_ref/doc/uid/TP40010672-CH2-SW1" target="_blank" rel="external"><strong>File System Programming Guide</strong></a>”可以整理出一下两个系统可能会清除的目录：（在储存空间不够时）</p>
<ol>
<li><strong> Library/Caches/ </strong></li>
<li><strong> tmp/ </strong></li>
</ol>
<p>所以，像App下载的歌曲等资源文件是不能放在上面两个目录中的。</p>
<h2 id="解决：">解决：</h2><p>所以，为了保险起见，最靠谱的还是放在<strong><application_home>/Documents</application_home></strong>中，并且通过设置，不让iCloud备份。</p>
<p>Apple已经提供了相应的函数，如下（iOS 5.1及以后的版本）：</p>
<pre><code>- (BOOL)addSkipBackupAttributeToItemAtURL:(NSURL *)URL
{
    <span class="built_in">assert</span>(<span class="string">[[NSFileManager defaultManager] fileExistsAtPath: [URL path]]</span>);

    NSError *<span class="built_in">error</span> = <span class="keyword">nil</span>;
    BOOL success = [URL setResourceValue: [NSNumber numberWithBool: YES]
                                  forKey: NSURLIsExcludedFromBackupKey <span class="built_in">error</span>: &amp;<span class="built_in">error</span>];
    <span class="keyword">if</span>(!success){
        NSLog(@<span class="string">"Error excluding %@ from backup %@"</span>, [URL lastPathComponent], <span class="built_in">error</span>);
    }
    <span class="keyword">return</span> success;
}
</code></pre><h3 id="特性">特性</h3><ul>
<li><strong><application_home>/Documents</application_home></strong>根目录也可以通过上面的函数设置成不备份。（如应用AVPlayer）</li>
<li>设置是递归的，所以其所有子目录和文件都不用再设置一次，都会自动不被备份。（测试有效，但是不确定=。=，参考：<a href="http://stackoverflow.com/questions/14376883/is-nsurlisexcludedfrombackupkey-recursive" target="_blank" rel="external">is-nsurlisexcludedfrombackupkey-recursive</a>）</li>
</ul>
<h2 id="总结">总结</h2><p>多看官方说明=。=</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/icloud/documentation/data-storage/index.html" target="_blank" rel="external">iOS Data Storage Guidelines</a></li>
<li><a href="https://developer.apple.com/library/ios/qa/qa1719/_index.html" target="_blank" rel="external">How do I prevent files from being backed up to iCloud and iTunes?</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple_ref/doc/uid/TP40010672-CH2-SW4" target="_blank" rel="external">File System Programming Guide</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>项目最近一次审核被拒了=。=<br>仔细看了一下后，发现是没有遵守“<strong>iOS Data Storage Guidelines</strong>”。<br>在此总结一下。</p>
<h2 id="被拒原因">被拒原因</h2><p>先看看被拒的反馈信息：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apps must follow the iOS <span class="built_in">Data</span> Storage Guidelines <span class="literal">or</span> they will be rejected</span><br><span class="line"></span><br><span class="line"><span class="keyword">On</span> launch <span class="literal">and</span> content download, your app stores <span class="number">12.14</span> MB, which does <span class="literal">not</span> comply <span class="keyword">with</span> the iOS <span class="built_in">Data</span> Storage Guidelines<span class="built_in">.</span></span><br></pre></td></tr></table></figure>
<p>大致意思就是App下载东西以后，在iCloud里面查看此App需要备份的体积变大了。  </p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="审核" scheme="http://tutuge.me/tags/%E5%AE%A1%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Block类型变量-缓存Http请求与回调]]></title>
    <link href="http://tutuge.me/2015/02/19/Block%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F-%E7%BC%93%E5%AD%98Http%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%9B%9E%E8%B0%83/"/>
    <id>http://tutuge.me/2015/02/19/Block类型变量-缓存Http请求与回调/</id>
    <published>2015-02-18T19:18:36.000Z</published>
    <updated>2015-04-06T03:13:45.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>Objective-C中的Blocks实在是太好用了，有了它，我们就可以将“代码块”封装起来，当成变量使用、传递，所以，在Objective-C中，iOS中，许多的回调是用Block来完成的。</p>
<h2 id="问题">问题</h2><p>我自己在之前的项目中，就遇到过一个问题。因为项目的需要，手机端所有的跟服务器的通信都需要“加密”，在经过一番调研后，我们使用的是类似OAuth机制（至于什么是OAuth，各位Google一下就明白了，大部分的公共API都用到了这种机制）。</p>
<a id="more"></a>
<h3 id="缓存Http请求后的回调代码块">缓存Http请求后的回调代码块</h3><p>既然是OAuth机制，就是说我们每次向服务器发起的请求，除了跟业务相关的参数，还需要带上AccessToken、UserToken这类的授权参数，而AccessToken在本次请求中是否会过期，在结果返回前是不知道的，所以，为了更好地用户体验，不至于让用户在某个时刻的操作，因为授权过期了而“没有响应”，我们的每次Http请求都必须缓存起来。</p>
<p>这里的缓存可不是单单指缓存请求的参数、URL，更重要的是缓存Http请求成功或者失败时的“<strong>回调代码块</strong>”。</p>
<h2 id="实现">实现</h2><h3 id="AFNetworking的Get方法">AFNetworking的Get方法</h3><p>在iOS的项目中，AFNetworking应该算是使用的最多的网络库了，它的Get请求的方法接口如下：</p>
<pre><code><span class="pp">- <span class="params">(<span class="variable">AFHTTPRequestOperation</span> *)</span>GET:<span class="params">(<span class="variable">NSString</span> *)</span>URLString
                     parameters:<span class="params">(id)</span>parameters
                        success:<span class="params">(void (^)</span><span class="params">(<span class="variable">AFHTTPRequestOperation</span> *operation, id response<span class="variable">Object</span>)</span>)success
                        failure:<span class="params">(void (^)</span><span class="params">(<span class="variable">AFHTTPRequestOperation</span> *operation, <span class="variable">NSError</span> *error)</span>)failure</span>
</code></pre><p>只有四个参数，分别是Url、参数、成功的回调Block，失败的回调Block，看，这里，回调的代码块就被封装到了Block里面，并当成参数传入。</p>
<h3 id="再次封装">再次封装</h3><p>介于AFNetworking只提供了最基本的Get、Post、Put这些方法，所以，我们往往根据业务的接口做了封装，如先定义了请求的类型枚举：</p>
<pre><code>//Http type, for<span class="instruction"> execute
</span>typedef<span class="function"> NS_ENUM(</span>NSUInteger, HTTP_REQUEST_TYPE<span class="function">)</span> {
    ICG_GET = 0,
    ICG_POST
};
</code></pre><p>然后定义了统一的请求入口与回调参数Block：</p>
<pre><code><span class="comment">//请求成功后的回调</span>
typedef <span class="typename">void</span> (^http_success)(id result);
<span class="comment">//请求失败后的回调</span>
typedef <span class="typename">void</span> (^http_fail)();

<span class="comment">//统一的请求入口</span>
+ (<span class="typename">void</span>)<span class="string">executeWithType:</span>(HTTP_REQUEST_TYPE)type <span class="string">api:</span>(NSString *)api
<span class="label">            parameters:</span>(NSDictionary *)parameters <span class="string">success:</span>                (http_success)success <span class="string">fail:</span>(http_fail)fail {    

    <span class="comment">//为每个请求增加AccessToken、UserToken等公共参数</span>
    <span class="comment">//...</span>

    <span class="comment">//缓存Http请求</span>
    <span class="comment">//...</span>

    <span class="comment">//根据type区分具体是哪一种Http请求。</span>
    <span class="keyword">switch</span> (type) {
        <span class="keyword">case</span> <span class="string">ICG_GET:</span>
            [HttpUtil <span class="string">get:</span>url <span class="string">parameters:</span>paras <span class="string">success:</span>success <span class="string">fail:</span>fail];
            <span class="keyword">break</span>;    
        <span class="keyword">case</span> <span class="string">ICG_POST:</span>
            [HttpUtil <span class="string">post:</span>url <span class="string">parameters:</span>paras <span class="string">success:</span>success <span class="string">fail:</span>fail];
            <span class="keyword">break</span>;    
<span class="label">        default:</span>
            <span class="keyword">break</span>;
    }
}
</code></pre><h3 id="再次封装的好处">再次封装的好处</h3><p>为什么要再次做封装，将基本的Http请求统一入口？道理很简单，就是为了能方便的对每次请求增加额外的处理，并且对上层调用透明。如:</p>
<ul>
<li>统一为每个请求增加Log。</li>
<li>统一为每个请求增加如AccessToken这些额外的参数。</li>
<li>方便对Http请求做缓存！</li>
</ul>
<h3 id="缓存Http请求的数据结构">缓存Http请求的数据结构</h3><p>既然我们已经有了统一的请求入口，为了缓存，所需要做的就是将能代表一次请求的所有参数缓存起来就行了，如URL、请求参数等，如下数据结构：</p>
<pre><code><span class="variable">@interface</span> <span class="attribute">RequestHolder </span>: NSObject

<span class="comment">//URL地址</span>
<span class="variable">@property</span>(strong, nonatomic) NSString *url;
<span class="comment">//请求参数</span>
<span class="variable">@property</span>(strong, nonatomic) NSMutableDictionary *paras;
<span class="comment">//请求类型，如Get、Post</span>
<span class="variable">@property</span>(assign, nonatomic) HTTP_REQUEST_TYPE type;
<span class="comment">//请求成功回调</span>
<span class="variable">@property</span>(copy) http_success success;
<span class="comment">//请求失败回调</span>
<span class="variable">@property</span>(copy) http_fail fail;
<span class="variable">@end</span>
</code></pre><p>这几个参数，就可以完整的“代表、重现”一次具体的Http请求。</p>
<h3 id="如何缓存">如何缓存</h3><p>只要App开启，Http请求就会不停地产生，会有源源不断的请求，难道我们把每次请求都缓存起来？</p>
<p>全部都缓存肯定是不行的，所以我们需要一个缓存策略。</p>
<p>一个App中，所有的Http请求的路径，也就是Url，不包括参数，应该是数量固定的，如“/user, /comment”，并且，一个请求往往对应的操作、功能也是唯一的，所以，完全可以以请求的<strong>Url</strong>为<strong>Key</strong>，以本次请求的“<strong>RequestHolder</strong>”为<strong>Value</strong>，用Objective-C中的NSDictionary来缓存Http请求。</p>
<p>所以，缓存请求的方法大致如下：</p>
<pre><code><span class="comment">//缓存Http请求</span>

- (<span class="keyword">void</span>)cacheHttpRequest:(HTTP_REQUEST_TYPE)<span class="class"><span class="keyword">type</span> <span class="title">url</span>:</span>(NSString *)url
                parameters:(NSMutableDictionary *)parameters success:(http_success)success fail:(http_fail)fail {

    <span class="comment">//创建缓存数据结构，保存本次请求的参数、回调</span>
    ICGRequestHolder *requestHolder = [ICGRequestHolder <span class="keyword">new</span>];
    requestHolder.url = url;
    requestHolder.paras = parameters;
    requestHolder.success = [success copy];
    requestHolder.fail = [fail copy];
    requestHolder.<span class="keyword">type</span> = <span class="class"><span class="keyword">type</span>;</span>

    <span class="comment">//保存本次请求</span>
    [_operationQueue addOperationWithBlock:^{
        _cachedRequests[url] = requestHolder;
    }];
}
</code></pre><p>这样，就能完整的缓存Http请求了。</p>
<h3 id="从缓存中恢复Http请求">从缓存中恢复Http请求</h3><p>恢复请求很简单，直接遍历所有缓存的请求，再次发起Http请求即可，就不再贴代码了。</p>
<h3 id="删除成功的Http请求">删除成功的Http请求</h3><p>缓存的目的是在请求失败时，如AccessToken超时时，我们可以在重新获取AccessToken后重现上次失败的请求，所以，一旦请求成功时，我们还需要将成功的请求删除，当然，也是利用Url，如下：</p>
<pre><code>- (<span class="typename">void</span>)<span class="string">removeRequestForKey:</span>(NSString *)url {
    <span class="comment">//放入队列执行</span>
    [_operationQueue <span class="string">addOperationWithBlock:</span>^{
        <span class="comment">//删除Url对应的请求</span>
        [_cachedRequests <span class="string">removeObjectForKey:</span>url];
    }];
}
</code></pre><h2 id="总结">总结</h2><p>本文只是简单地利用Objective-C中的Block特性，实现了Http请求的缓存。目的不是介绍Block，是为了分享我自己在项目中运用Block的例子，如果读者有更好的方法，欢迎留言啊~~</p>
<h2 id="参考、推荐阅读">参考、推荐阅读</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html" target="_blank" rel="external">Working with Blocks</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>Objective-C中的Blocks实在是太好用了，有了它，我们就可以将“代码块”封装起来，当成变量使用、传递，所以，在Objective-C中，iOS中，许多的回调是用Block来完成的。</p>
<h2 id="问题">问题</h2><p>我自己在之前的项目中，就遇到过一个问题。因为项目的需要，手机端所有的跟服务器的通信都需要“加密”，在经过一番调研后，我们使用的是类似OAuth机制（至于什么是OAuth，各位Google一下就明白了，大部分的公共API都用到了这种机制）。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[提升UITableView性能-复杂页面的优化]]></title>
    <link href="http://tutuge.me/2015/02/19/%E6%8F%90%E5%8D%87UITableView%E6%80%A7%E8%83%BD-%E5%A4%8D%E6%9D%82%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://tutuge.me/2015/02/19/提升UITableView性能-复杂页面的优化/</id>
    <published>2015-02-18T17:28:41.000Z</published>
    <updated>2015-04-06T03:13:03.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>随着App的用户界面的内容越来越丰富，再强的手机可能都无法同时渲染复杂的UI界面和保证流畅的体验。所以，我们这些程序猿=。=在写代码的时候就要注意，如何尽可能提高用户的操作流畅性。</p>
<p>之前的做的项目，<a href="https://itunes.apple.com/us/app/qing-ju-yin-le-quan-guo-zui/id913235479?l=zh&amp;ls=1&amp;mt=8" target="_blank" rel="external">青桔音乐iOS客户端</a>里面的首页就是一个类似微信朋友圈的“动态”页面，大致如下：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_ios_speed_up_uitableview_1_1.png?imageView2/0/h/300" alt="image"></p>
<p>如果是你，你会怎么实现这个页面呢？</p>
<p>这还用问，当然是用UITableView+自定义的UITableViewCell。</p>
<p>UITableView是可以滑动的，为了不让用户在滑动中感到有卡顿，该如何优化？下面，我就写一下我自己在做项目时的“经验”~</p>
<a id="more"></a>
<h2 id="优化">优化</h2><p>主要分为以下几点：</p>
<ul>
<li>只定义一种Cell。</li>
<li>提前计算并缓存每个Cell的高度。</li>
<li>提前创建真正显示的、需要加工的数据并缓存。</li>
<li>缓存View！</li>
<li>其它。</li>
</ul>
<h3 id="只定义一种Cell">只定义一种Cell</h3><p>乍一看，这个界面至少有3种样式的Cell，为什么只定义一种呢？</p>
<h4 id="分析结构">分析结构</h4><p>仔细分析一下，页面中每个Cell的内容都有头像、标题、正文、评论、其它（歌曲、图片、歌手）。所以，从整体上看，每个Cell的结构是一致的！</p>
<h4 id="重用=大致固定数量的Cell">重用=大致固定数量的Cell</h4><p>并且，凡是认真研究过UITableView的人应该都知道，Apple已经为我们提供了Cell的重用，如用“<strong>registerNib:forCellReuseIdentifier</strong>”方法注册自定义Cell的Nib，然后在“<strong>cellForRowAtIndexPath</strong>”的时候用“<strong>dequeueReusableCellWithIdentifier</strong>”获取可以重用的Cell，所以，无论UITableView要显示内容有多少，真正创建出的Cell可能只有5、6个。</p>
<p>所以，我们完全可以只创建一种Cell，虽然这样一个Cell的“体积”可能会很大，但是介于Cell的数量不会很多，所以完全可以接受。</p>
<h5 id="只定义一种Cell的好处"><strong>只定义一种Cell的好处</strong></h5><ul>
<li>减少代码量，减少Nib文件的数量，统一一个Nib文件定义Cell，容易修改、维护。</li>
<li>基于Cell的重用，真正运行时铺满屏幕所需的Cell数量大致是固定的，设为<strong>N</strong>个。所以如果如果只有一种Cell，那就是只有<strong>N</strong>个Cell的实例；但是如果有<strong>M</strong>种Cell，那么运行时最多可能会是“<strong>M x N = MN</strong>”个Cell的实例，虽然可能并不会占用太多内存，但是能少点不是更好吗。</li>
</ul>
<h4 id="善用hidden隐藏（显示）Subview">善用hidden隐藏（显示）Subview</h4><p>既然只定义一种Cell，那该如何显示不同类型的内容呢？<br>答案就是，把所有不同类型的view都定义好，放在cell里面，通过hidden显示、隐藏，来显示不同类型的内容。如下图定义Cell：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_ios_speed_up_uitableview_1_2.jpg?imageView2/0/h/400" alt="image"></p>
<p>图中的Subview1、Subview2、Subview3就是不同类型Cell的不同之处，所以我们在“<strong>cellForRowAtIndexPath</strong>”函数中，设置Cell的样式、内容时，就可以通过显示、隐藏这三个子view来显示。</p>
<p>毕竟，在用户快速滑动中，只是单纯的显示、隐藏subview比实时创建要快得多。</p>
<h3 id="提前计算并缓存每个Cell的高度">提前计算并缓存每个Cell的高度</h3><p>开发过Android，用过Android的ListView以后，对UITableView需要提前计算Cell的高度很不适应。=。= </p>
<p>首先要确定的是，在iOS中，系统会先调用“<strong>tableView:heightForRowAtIndexPath:</strong>”获取每个Cell即将显示的高度，从而确定整个UITableView的布局。然后才调用“<strong>tableView:cellForRowAtIndexPath</strong>”获取每个Cell，我们也是在这里填充、设置Cell的。</p>
<p><strong>所以，既然高度总会被用到，那就早早的在获取数据时就计算好吧！</strong></p>
<h4 id="在Model（Entity）中计算并保存Cell的高度">在Model（Entity）中计算并保存Cell的高度</h4><p>其实，在Model（Entity）中保存UI的参数是很奇怪的=。=（最好放在ViewModel中，就是MVVM模式的），我们的Entity可能就是下面的样子：</p>
<pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">DataEntity</span> : <span class="title">NSObject</span></span>

<span class="comment">//原始数据</span>
<span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *content;
<span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *title;

<span class="comment">//Cell 高度</span>
<span class="keyword">@property</span>(<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> cellHeight;

<span class="comment">//计算高度</span>
- (<span class="keyword">void</span>)calculateCellHeight;

<span class="keyword">@end</span>
</code></pre><p>这样，就不用在“<strong>tableView:heightForRowAtIndexPath:</strong>”中每次都计算了。</p>
<h3 id="提前创建真正显示的、需要加工的数据并缓存">提前创建真正显示的、需要加工的数据并缓存</h3><p>Cell中显示的内容，很多时候可能并不是直接从服务器拿到的数据，而是经过“加工”的数据。如本文中的“动态”也，每个Cell的标题、正文都有可点击的连接Link、表情图片等富文本内容，而我们一般用NSAttributeString类来显示。</p>
<p>既然每次都会用到，倒不如在获取到数据的时候就创建、加工好这些内容，等到需要现实的时候，直接拿来用不就行了。</p>
<p>所以，我们的Entity类可能变成下面这个样子: </p>
<pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">DataEntity</span> : <span class="title">NSObject</span></span>

<span class="comment">//原始数据</span>
<span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *content;
<span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *title;

<span class="comment">//Cell 高度</span>
<span class="keyword">@property</span>(<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> cellHeight;

<span class="comment">//真正显示的内容</span>
<span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSAttributedString</span> *showTitle;
<span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSAttributedString</span> *showContent;

<span class="comment">//计算高度</span>
- (<span class="keyword">void</span>)calculateCellHeight;

<span class="comment">//创建、加工真正显示的内容</span>
- (<span class="keyword">void</span>)setupShowTitileAndContent;

<span class="keyword">@end</span>
</code></pre><p>这样，在“<strong>tableView:cellForRowAtIndexPath</strong>”中，我们直接拿showTitle、showContent来显示就好，不用再创建。</p>
<h3 id="缓存View!">缓存View!</h3><p>什么？缓存View？！</p>
<p>是的，当Cell中的部分View是非常独立的，并且不便于重用的，而且“体积”非常小，在内存可控的前提下，我们完全可以将这些view缓存起来！</p>
<p>方法当然也是将缓存的view放在Entity中~。</p>
<h3 id="其它">其它</h3><p>当然，还有其他的优化方法，简单说一说：</p>
<ul>
<li>尽量设置Cell的view为opaque，避免GPU对Cell下面的内容也进行绘制。</li>
<li>避免大量的图片缩放、颜色渐变等。</li>
<li>避免同步的从网络、文件获取数据（这个是必须的=。=）</li>
<li>用shadowPath创建阴影。</li>
<li>尽量减少subview的数量，如多用drawRect绘制元素，替代用view显示。</li>
<li>尽量显示“<strong>大小刚好合适</strong>”的图片资源。</li>
</ul>
<h2 id="总结">总结</h2><p>总的来说，就是：</p>
<p><strong>缓存一切可以缓存的！就是“用空间替换时间”！</strong></p>
<p><strong>在UITableView的Delegate、DataSource方法中，减少任何不必要的操作</strong></p>
<h2 id="参考，推荐阅读">参考，推荐阅读</h2><ul>
<li><a href="http://www.raywenderlich.com/31166/25-ios-app-performance-tips-tricks#tableviews" target="_blank" rel="external">25 iOS App Performance Tips &amp; Tricks</a></li>
<li><a href="http://stackoverflow.com/questions/1352479/tricks-for-improving-iphone-uitableview-scrolling-performance" target="_blank" rel="external">Tricks for improving iPhone UITableView scrolling performance?</a></li>
<li><a href="http://stackoverflow.com/questions/6172158/how-can-i-speed-up-a-uitableview" target="_blank" rel="external">How can I speed up a UITableView?</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>随着App的用户界面的内容越来越丰富，再强的手机可能都无法同时渲染复杂的UI界面和保证流畅的体验。所以，我们这些程序猿=。=在写代码的时候就要注意，如何尽可能提高用户的操作流畅性。</p>
<p>之前的做的项目，<a href="https://itunes.apple.com/us/app/qing-ju-yin-le-quan-guo-zui/id913235479?l=zh&amp;ls=1&amp;mt=8">青桔音乐iOS客户端</a>里面的首页就是一个类似微信朋友圈的“动态”页面，大致如下：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_ios_speed_up_uitableview_1_1.png?imageView2/0/h/300" alt="image"></p>
<p>如果是你，你会怎么实现这个页面呢？</p>
<p>这还用问，当然是用UITableView+自定义的UITableViewCell。</p>
<p>UITableView是可以滑动的，为了不让用户在滑动中感到有卡顿，该如何优化？下面，我就写一下我自己在做项目时的“经验”~</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NSString的Copy与内存分配]]></title>
    <link href="http://tutuge.me/2015/02/18/NSString%E7%9A%84Copy%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>http://tutuge.me/2015/02/18/NSString的Copy与内存分配/</id>
    <published>2015-02-18T09:00:47.000Z</published>
    <updated>2015-04-06T03:15:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>不管是用什么语言开发，字符串应该算是用的最多的了。在Objective-C中，字符串类是NSString，以及其子类NSMutableString等。所以，对于字符串类，编程语言、编译器等往往会做特殊处理。下面我就说说我自己在项目中发现的NSString的“奇怪”的地方。</p>
<a id="more"></a>
<h2 id="字符串常量，copy，mutableCopy">字符串常量，copy，mutableCopy</h2><h3 id="Example">Example</h3><p>先看看如下面的代码，猜猜会输出什么：</p>
<pre><code><span class="built_in">NSString</span> *str1 = <span class="string">@"abc"</span>;
<span class="built_in">NSString</span> *str2 = <span class="string">@"abc"</span>;
<span class="built_in">NSString</span> *str3 = [[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@"abc"</span>];
<span class="built_in">NSString</span> *str4 = [str1 <span class="keyword">copy</span>];
<span class="built_in">NSString</span> *str5 = [str1 mutableCopy];

<span class="comment">//输出内存中的地址</span>
<span class="built_in">NSLog</span>(<span class="string">@"str1: %p"</span>, str1);
<span class="built_in">NSLog</span>(<span class="string">@"str2: %p"</span>, str2);
<span class="built_in">NSLog</span>(<span class="string">@"str3: %p"</span>, str3);
<span class="built_in">NSLog</span>(<span class="string">@"str4: %p"</span>, str4);
<span class="built_in">NSLog</span>(<span class="string">@"str5: %p"</span>, str5);
</code></pre><p>直接给出结果：</p>
<pre><code><span class="comment">//地址值由运行时决定，不唯一</span>
<span class="string">str1:</span> <span class="number">0x10cd12040</span>
<span class="string">str2:</span> <span class="number">0x10cd12040</span>
<span class="string">str3:</span> <span class="number">0x10cd12040</span>
<span class="string">str4:</span> <span class="number">0x10cd12040</span>
<span class="string">str5:</span> <span class="number">0x7f874b508350</span> <span class="comment">//mutable copy</span>
</code></pre><p>看，是不是很“神奇”。</p>
<h3 id="简单解释">简单解释</h3><p>NSString是“不可变（immutable）”的类型，这个是关键。<br>代码中的“@”开头的字符串，其实就是一个字符串常量，运行时会检测这个字符串是否已经存在，存在的话，就直接将这个字符串的地址赋给变量；不存在的话，则创建，再赋值。</p>
<p><strong>第一行</strong>: “abc”字符串不存在，创建，取得字符串地址“0x10cd12040”，赋给str1. </p>
<p><strong>第二行</strong>: “abc”字符串已经存在，直接将地址“0x10cd12040”赋给str2.  </p>
<p><strong>第三行</strong>: （记住，NSString是不可变的）alloc并不会分配新的内存，直接将字符串地址“0x10cd12040”赋给str3.  </p>
<p><strong>第四行</strong>: copy，既然是不可变的，也就没有必要分配新内存，直接将地址“0x10cd12040”赋给str4.  </p>
<p><strong>第五行</strong>: mutableCopy其实就是创建一个NSMutableString的实例，既然是“可变（mutable）”的类型了，当然要分配新的内存，所以，字符串的地址也变成新的“0x7f874b508350”。</p>
<p>可以这么说，编译器、runtime充分利用了NSString是“<strong>不可变（immutable）</strong>”类型这个特点，只要字符串内容一致，就不会分配新的内存储存，字符串在程序中使用量非常大，这么做无疑可以大大节省内存，提升性能。</p>
<h2 id="Property_和_NSString">Property 和 NSString</h2><p>先来看看一个UserEntity类：</p>
<pre><code><span class="comment">//UserEntity.h</span>

<span class="variable">@interface</span> <span class="attribute">UserEntity </span>: NSObject &lt;NSCopying&gt;
<span class="variable">@property</span>(strong, nonatomic) NSString *name;
<span class="variable">@end</span>
</code></pre><p>只有一个名为name的NSString类型Property。<br>相信大家对这个不陌生吧。一般我们的应用中会有很多Entity类型，每个Entity类里面肯定避免不了有许多NSString的字符串类型。这里的name的属性是：strong和nonatomic，strong表明name要“持有”一份name所指的字符串的引用，nonatomic表示property类型不用加锁。</p>
<p>接着咱们看看下面的代码：</p>
<pre><code>UserEntity *userEntity = [UserEntity <span class="keyword">new</span>];        

<span class="comment">//创建mutable类型的字符串</span>
NSMutableString *showName = [[NSMutableString alloc] <span class="string">initWithString:</span>@<span class="string">"tutuge"</span>];        

<span class="comment">//先保存“tutuge”字符串到userEntity的name</span>
userEntity.name = showName;        

<span class="comment">//修改showName</span>
[showName <span class="string">appendString:</span>@<span class="string">" blog"</span>];        

<span class="comment">//输出userEntity的name属性</span>
NSLog(@<span class="string">"Name: %@"</span>, userEntity.name);
</code></pre><p>猜猜会输出什么？</p>
<pre><code><span class="attribute">Name</span>: <span class="string">tutuge blog</span>
</code></pre><p>看，我们明明是保存的“tutuge”，怎么到后面输出的是“tutuge blog”？</p>
<h3 id="让NSString类型的Property为Copy型">让NSString类型的Property为Copy型</h3><p>因为name的Property属性是strong的，所以赋值后，它跟showName均指向同一个NSMutableString实例，如下：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_ios_nsstring_copy_1_1.jpg" alt="image"></p>
<p>所以改变了showName，当然name输出的值也就变了。<br>这个时候，name的property属性就不能是strong了，应该是copy，如下：</p>
<pre><code><span class="comment">//UserEntity.h</span>

<span class="variable">@interface</span> <span class="attribute">UserEntity </span>: NSObject &lt;NSCopying&gt;
<span class="variable">@property</span>(copy, nonatomic) NSString *name;
<span class="variable">@end</span>
</code></pre><p>这样的话，当“<strong>userEntity.name = showName;</strong>”这句运行后，内存布局如下：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_ios_nsstring_copy_1_2.jpg" alt="image"></p>
<p>这样，就避免了这个问题。</p>
<h2 id="总结">总结</h2><p>很所时候，代码并不是看上去那样“运行”的，多试试，多查阅资料，就能了解其中的奥秘了~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>不管是用什么语言开发，字符串应该算是用的最多的了。在Objective-C中，字符串类是NSString，以及其子类NSMutableString等。所以，对于字符串类，编程语言、编译器等往往会做特殊处理。下面我就说说我自己在项目中发现的NSString的“奇怪”的地方。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用NSProxy实现消息转发-模块化的网络接口层设计-原创]]></title>
    <link href="http://tutuge.me/2015/02/16/%E5%88%A9%E7%94%A8NSProxy%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82%E8%AE%BE%E8%AE%A1-%E5%8E%9F%E5%88%9B/"/>
    <id>http://tutuge.me/2015/02/16/利用NSProxy实现消息转发-模块化的网络接口层设计-原创/</id>
    <published>2015-02-16T10:52:08.000Z</published>
    <updated>2015-04-06T03:12:54.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>之前在做项目的时候，所有业务的网络接口方法，全部都写在了一个文件里面，一开始还好，毕竟每个方法的代码也只是十几行，增加、修改也比较容易。但是随着接口的增多，这个文件慢慢居然超过了1000行，里面几十个方法都写在一起，实在是不好维护。  </p>
<p>虽然保持这样也没有什么，多用用Cmd+F就能找到。但是，真是越看越不顺眼😳， 代码一定要有“美感”啊~😝</p>
<p>所以在查阅了大量文章后，终于想出了本文即将说明的办法，越发觉得Objective-C的“消息”机制是多么的赞~😚</p>
<h2 id="Github_示例">Github 示例</h2><p>贴上本文中的示例工程：<a href="https://github.com/zekunyan/HttpProxyExample" target="_blank" rel="external">https://github.com/zekunyan/HttpProxyExample</a></p>
<a id="more"></a>
<h2 id="问题">问题</h2><p>先抛出问题。  </p>
<p>一款互联网应用，免不了要跟服务器打交道，在iOS项目中，最有名的网络库应该就是<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a>了。所以，很多人就会利用AFnetworking提供的Get、Post等基本Http请求接口，封装自己的网络接口层代码，我自己在项目中也是这么做的。  </p>
<p>但是，AFNetworking只是提供了Get、Post、Json传输等基本的Http请求方法，所以一旦落实到具体的业务相关的请求上，我们要为每个请求（URL）都写一个单独的接口方法。</p>
<p><strong>那么，问题就来了</strong>  </p>
<p>业务相关的接口那么多，举个例子，什么“通过用户ID获取用户基本信息”、“获取用户的所有评论”等，每个请求都是一个方法，这么多方法该怎么组织呢？全部放在一起？那这个接口类岂不是会非常乱？不放在一起？那岂不是会有很多个网络请求类？(至于要不要统一接口入口，我想这个根据项目来决定吧=。=)</p>
<h2 id="需求">需求</h2><ul>
<li>所有网络接口都从统一的类调用，如HttpProxy。</li>
<li>网络接口的具体实现，按照业务划分到不同的类中，如“<strong>UserHttpHandler</strong>”、“<strong>CommentHttpHandler</strong>”。</li>
</ul>
<p>其实，按照面向对象的原则，就是接口代理类<strong>HttpProxy</strong>拥有若干个按照业务划分的接口（Interface），这些接口的所有方法组成了网络层的不同的Http请求。如下图：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_ios_http_proxy_1_1.jpg" alt="image"></p>
<p>那么，调用的时候，所有接口都用HttpProxy调用，如：</p>
<pre><code><span class="comment">//实际调用的是UserHttpHandler类的方法</span>
<span class="attr_selector">[[HttpProxy sharedInstance]</span> <span class="tag">getUserWithID</span>:@<span class="tag">100</span>];

<span class="comment">//实际调用的是CommentHttpHandler类的方法</span>
<span class="attr_selector">[[HttpProxy sharedInstance]</span> <span class="tag">getCommentsWithDate</span><span class="pseudo">:date</span>];
</code></pre><h2 id="关键">关键</h2><p>根据前面的描述，我们可以得出，关键就是：<strong>消息转发（Message Forward）</strong></p>
<p>Objective-C里面没有我们传统的“方法调用”，取而代之的是“消息”，所有的方法都是通过向对象发送“消息”实现调用的。而这个机制，也就为我们的实现提供了方便。</p>
<p>也就是说：我们要将发给“<strong>HttpProxy</strong>”的消息，让HttpProxy转发给真正能接受这个消息的对象，HttpProxy就是个<strong>代理</strong>。</p>
<p>苹果已经给我们提供了这个“代理”类了-NSProxy。</p>
<h2 id="NSProxy">NSProxy</h2><p>什么是NSProxy：</p>
<ul>
<li>NSProxy没有父类，是顶级类(根类)，跟NSObject同等地位。</li>
<li>NSProxy和NSObject都实现了“<strong>NSObject</strong> Protocol”。</li>
<li>NSProxy设计时就是以“抽象类”设计的，专门为<strong>转发消息</strong>而生。</li>
</ul>
<p>实现要求:</p>
<ol>
<li>继承NSProxy的子类要实现自己的初始化方法，如“init”、“initWith”。</li>
<li>重写“<strong> - forwardInvocation: </strong>”和“<strong> - methodSignatureForSelector: </strong>”方法，完成消息转发。</li>
</ol>
<p>详细内容参考Apple的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSProxy_Class/index.html#//apple_ref/occ/instm/NSProxy/forwardInvocation:" target="_blank" rel="external">文档</a>。</p>
<h2 id="实现">实现</h2><h3 id="定义">定义</h3><p>先不管HttpProxy，咱们看看具体的接口，先举两个例子：</p>
<pre><code><span class="comment">//UserHttpHandler.h</span>
<span class="comment">//用户相关接口</span>
<span class="variable">@protocol</span> UserHttpHandler &lt;NSObject&gt;
- (void)<span class="attribute">getUserWithID</span>:(NSNumber *)userID;
<span class="variable">@end</span>

<span class="comment">//CommentHttpHandler.h</span>
<span class="comment">//评论相关接口</span>
<span class="variable">@protocol</span> CommentHttpHandler &lt;NSObject&gt;
- (void)<span class="attribute">getCommentsWithDate</span>:(NSDate *)date;
<span class="variable">@end</span>
</code></pre><p>好的，接口有了，我们的HttpProxy类应该“实现”了这两个接口。<br>然后，最好是单例类，所以还要有个获取单例的方法。<br>最后，还需要一个向HttpProxy注册具体实现了接口Protocol的方法。</p>
<p>所以，HttpProxy应该是这个样子的：</p>
<pre><code><span class="comment">//HttpProxy.h</span>

<span class="comment">//1. 继承了NSproxy。 2. “实现”了网络接口Protocol</span>
<span class="annotation">@interface</span> <span class="string">HttpProxy :</span> NSProxy &lt;UserHttpHandler, CommentHttpHandler&gt;

<span class="comment">//获取单例</span>
+ (instancetype)sharedInstance;

<span class="comment">//注册具体实现类</span>
- (<span class="typename">void</span>)<span class="string">registerHttpProtocol:</span>(Protocol *)httpProtocol <span class="string">handler:</span>(id)handler;

<span class="annotation">@end</span>
</code></pre><h3 id="找到消息对应的实现类对象">找到消息对应的实现类对象</h3><p>如何在HttpProxy做消息转发时，找到某个消息对应的真正的实现类对象呢？</p>
<p>最好的办法就是保存每个接口方法到其实现类对象的映射，可以用Dictionary保存，关系如下图：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_ios_http_proxy_1_2.jpg" alt="image"></p>
<p>所以，<strong>registerHttpProtocol:handler:</strong>方法的职责就是：</p>
<ol>
<li>遍历Protocol的所有方法（利用Objective-C的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html" target="_blank" rel="external">Runtime功能</a>）。</li>
<li>保存Protocol所有方法到实现类的对象的映射关系。（用方法的字符串表示作为key，实现类对象为value）</li>
</ol>
<p>所以，HttpProxy应该持有一个Dictionary的实例，用于保存映射关系，HttpProxy的实现部分如：</p>
<pre><code><span class="comment">//HttpProxy.m</span>

<span class="variable">@interface</span> HttpProxy ()
<span class="comment">//保存映射关系的字典。</span>
<span class="variable">@property</span>(strong, nonatomic) NSMutableDictionary *selToHandlerMap;
<span class="variable">@end</span>
</code></pre><p>注册方法实现如下：</p>
<pre><code>- (<span class="type">void</span>)registerHttpProtocol:(<span class="type">Protocol</span> *)httpProtocol handler:(id)handler {
    unsigned <span class="type">int</span> numberOfMethods = <span class="number">0</span>;

    //<span class="type">Get</span> all methods <span class="keyword">in</span> protocol
    struct objc_method_description *methods = protocol_copyMethodDescriptionList(
            httpProtocol, <span class="type">YES</span>, <span class="type">YES</span>, &amp;numberOfMethods);

    //<span class="type">Register</span> protocol methods
    <span class="keyword">for</span> (unsigned <span class="type">int</span> i = <span class="number">0</span>; i &lt; numberOfMethods; i++) {
        struct objc_method_description <span class="keyword">method</span> = methods[i];
        [_selToHandlerMap setValue:handler forKey:<span class="type">NSStringFromSelector</span>(<span class="keyword">method</span>.name)];
    }
}
</code></pre><h3 id="实现消息的转发">实现消息的转发</h3><p>我们已经可以注册接口、保存映射关系了，剩下的就是重写NSProxy的两个方法，以实现消息的转发，至于这两个方法具体作用是什么，读者可以自行查阅相关资料。如下：</p>
<pre><code><span class="comment">//HttpProxy.m</span>

<span class="comment">//获取Method signature</span>
- (NSMethodSignature *)<span class="string">methodSignatureForSelector:</span>(SEL)sel {

    <span class="comment">//获取method的字符串表示</span>
    NSString *methodsName = NSStringFromSelector(sel);

    <span class="comment">//查找对应实现类对象</span>
    id handler = [_selToHandlerMap <span class="string">valueForKey:</span>methodsName];

    <span class="comment">//再次检查handler是否可以相应此消息</span>
    <span class="keyword">if</span> (handler != nil &amp;&amp; [handler <span class="string">respondsToSelector:</span>sel]) {
        <span class="keyword">return</span> [handler <span class="string">methodSignatureForSelector:</span>sel];
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> [<span class="keyword">super</span> <span class="string">methodSignatureForSelector:</span>sel];
    }
}

<span class="comment">//转发方法消息</span>
- (<span class="typename">void</span>)<span class="string">forwardInvocation:</span>(NSInvocation *)invocation {
    NSString *methodsName = NSStringFromSelector(invocation.selector);
    id handler = [_selToHandlerMap <span class="string">valueForKey:</span>methodsName];

    <span class="keyword">if</span> (handler != nil &amp;&amp; [handler <span class="string">respondsToSelector:</span>invocation.selector]) {
        [invocation <span class="string">invokeWithTarget:</span>handler];
    } <span class="keyword">else</span> {
        [<span class="keyword">super</span> <span class="string">forwardInvocation:</span>invocation];
    }
}
</code></pre><h2 id="Example">Example</h2><p>看看如何使用HttpProxy：</p>
<pre><code><span class="comment">//初始化，注册Protocol对应的实现类对象</span>
<span class="attr_selector">[[HttpProxy sharedInstance]</span> <span class="tag">registerHttpProtocol</span>:@<span class="tag">protocol</span>(UserHttpHandler) <span class="tag">handler</span>:<span class="attr_selector">[UserHttpHandlerImp new]</span>];
<span class="attr_selector">[[HttpProxy sharedInstance]</span> <span class="tag">registerHttpProtocol</span>:@<span class="tag">protocol</span>(CommentHttpHandler) <span class="tag">handler</span>:<span class="attr_selector">[CommentHttpHandlerImp new]</span>];

<span class="comment">//调用</span>
<span class="attr_selector">[[HttpProxy sharedInstance]</span> <span class="tag">getUserWithID</span>:@<span class="tag">100</span>];
<span class="attr_selector">[[HttpProxy sharedInstance]</span> <span class="tag">getCommentsWithDate</span>:<span class="attr_selector">[NSDate new]</span>];
</code></pre><h2 id="总结">总结</h2><p>所有的代码及示例都提交到Github了，<a href="https://github.com/zekunyan/HttpProxyExample" target="_blank" rel="external">HttpProxyExample</a>。</p>
<p>总的来说，就是利用Objective-C的“消息”机制，继承NSProxy抽象类，实现自己定义的转发机制，将网络接口层的各个方法的实现与声明分离，提升项目代码的可维护性，更加模块化。如下图表示:</p>
<p><img src="http://zorrochen.qiniudn.com/blog_ios_http_proxy_1_3.jpg" alt="image"></p>
<p>以上，就是我自己在项目中，利用NSProxy设计并实现的网络接口层结构。💪</p>
<p>从了解NSProxy、Runtime到设计、实现出这个网络层架构，着实花了点时间，收获真是不少。其实像这种纯代码层次的重构，很多人会觉得“吃力不讨好”😨，但我觉得，正是这样，才能真正让自己提升。</p>
<p>代码是具有美感的！嗯！😝</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSProxy_Class/index.html#//apple_ref/occ/instm/NSProxy" target="_blank" rel="external">NSProxy Class Reference</a></li>
<li><a href="http://objectivetoast.com/2014/05/12/nsproxy-nsobjects-lesser-known-sibling/" target="_blank" rel="external">NSProxy, NSObject’s Lesser-Known Sibling</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html" target="_blank" rel="external">Objective-C Runtime Programming Guide</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>之前在做项目的时候，所有业务的网络接口方法，全部都写在了一个文件里面，一开始还好，毕竟每个方法的代码也只是十几行，增加、修改也比较容易。但是随着接口的增多，这个文件慢慢居然超过了1000行，里面几十个方法都写在一起，实在是不好维护。  </p>
<p>虽然保持这样也没有什么，多用用Cmd+F就能找到。但是，真是越看越不顺眼😳， 代码一定要有“美感”啊~😝</p>
<p>所以在查阅了大量文章后，终于想出了本文即将说明的办法，越发觉得Objective-C的“消息”机制是多么的赞~😚</p>
<h2 id="Github_示例">Github 示例</h2><p>贴上本文中的示例工程：<a href="https://github.com/zekunyan/HttpProxyExample">https://github.com/zekunyan/HttpProxyExample</a></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Effective-Objective-C-读书笔记-Item-3]]></title>
    <link href="http://tutuge.me/2015/02/14/Effective-Objective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Item-3/"/>
    <id>http://tutuge.me/2015/02/14/Effective-Objective-C-读书笔记-Item-3/</id>
    <published>2015-02-14T08:51:51.000Z</published>
    <updated>2015-04-06T03:14:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>item 3讲的是Objective-C里面的“字面量语法”-“Literal Syntax”，个人觉得非常有用。</p>
<h2 id="Item_3_-_Prefer_Literal_Syntax_over_the_Equivalent_Methods">Item 3 - Prefer Literal Syntax over the Equivalent Methods</h2><p>本节讲了Objective-C中的“字面量语法”，并且建议我们更多的使用这种语法，而不是使用传统的等价的函数方法。</p>
<a id="more"></a>
<h2 id="引子">引子</h2><p>当我们使用Objective-C编程的时候，总会经常使用到几种Foundation框架中的基本类，如NSString、NSNumber、NSArray、NSDictionary，或者是它们的子类。例如，当我们想创建一个字符串的时候，会这么写：</p>
<pre><code>NSString *<span class="keyword">str</span> = @<span class="string">"a string"</span>;
</code></pre><p>不知道各位写这句的时候有没有觉得奇怪？为什么不用先“alloc”，再“initWithXXX”这么来创建呢。是的，这里创建字符串，就用到了Objective-C提供的“字面量语法”-“Literal Syntax”，而这种语法的“标志”就是“@”符号。<br>有了字面量语法，我们就不用每次创建一些基本类型的时候，写一大堆alloc、init了。</p>
<h2 id="NSNumber">NSNumber</h2><p>字符串可以用字面量语法创建，数字类NSNumber肯定也可以，如下：</p>
<pre><code>NSNumber <span class="keyword">*</span>intNum = <span class="comment">@1;</span>
NSNumber <span class="keyword">*</span>floatNum = <span class="comment">@1.1f;</span>
NSNumber <span class="keyword">*</span>doubleNum = <span class="comment">@1.1;</span>
NSNumber <span class="keyword">*</span>boolNum = <span class="comment">@YES;</span>
NSNumber <span class="keyword">*</span>charNum = <span class="comment">@'a';</span>

//不用字面量语法
NSNumber <span class="keyword">*</span>intNumber = [[NSNumber alloc] initWithInt:1];
</code></pre><p>看，是不是很方便~</p>
<h2 id="NSArray">NSArray</h2><h3 id="创建">创建</h3><p>数组算是最常用的一种数据结构了，如果没有字面量语法，创建数组可能是这样：</p>
<pre><code><span class="constant">NSArray </span>*numbers = [[<span class="constant">NSArray </span>alloc] <span class="symbol">initWithObjects:</span>
    <span class="variable">@1</span>, <span class="variable">@1</span>.<span class="number">1</span>, <span class="variable">@2</span>.0f, <span class="variable">@YES</span>, <span class="keyword">nil</span>];
</code></pre><p>用字面量语法的话，就是这样：</p>
<pre><code>NSArray <span class="variable">*numbers</span> = <span class="variable">@[</span><span class="variable">@1</span>, <span class="variable">@1</span>.1, <span class="variable">@2</span>.0f, <span class="variable">@YES</span>];
</code></pre><h3 id="存取值">存取值</h3><p>创建了数组，肯定要从数组里面取值，用NSArray的方法就是这样：</p>
<pre><code><span class="comment">//取</span>
NSNumber <span class="variable">*aNumber</span> = [numbers objectAtIndex:<span class="number">2</span>];
<span class="comment">//存</span>
NSMutableArray <span class="variable">*mutableArray</span> = [[NSMutableArray alloc] initWithArray:
    <span class="variable">@[</span><span class="variable">@1</span>, <span class="variable">@2</span>, <span class="variable">@3</span>]];
[mutableArray replaceObjectAtIndex:<span class="number">1</span> withObject:<span class="variable">@4</span>];
</code></pre><p>跟C语言、Java这些语法很不一样啊，人家都是通过中括号“[]”直接用下标取值就可以。有了字面量同语法，Objective-C也可以这样:</p>
<pre><code><span class="comment">//取</span>
NSNumber <span class="variable">*aNumber</span> = numbers[<span class="number">2</span>];
<span class="comment">//存</span>
NSMutableArray <span class="variable">*mutableArray</span> = [[NSMutableArray alloc] initWithArray:
    <span class="variable">@[</span><span class="variable">@1</span>, <span class="variable">@2</span>, <span class="variable">@3</span>]];
mutableArray[<span class="number">1</span>] = <span class="variable">@4</span>;
</code></pre><h3 id="要注意的地方">要注意的地方</h3><p>传统的通过“initWithObjects”方法创建数组的时候，是根据最后的“nil”判断数组是否结束的，也就是说，用于初始化数组的元素中有“nil”值也不会导致异常（Exception），如下语句：</p>
<pre><code><span class="built_in">NSNumber</span> *number1 = @<span class="number">1</span>;
<span class="built_in">NSNumber</span> *number2 = <span class="literal">nil</span>; <span class="comment">//空指针</span>
<span class="built_in">NSNumber</span> *number3 = @<span class="number">3</span>;

<span class="comment">//创建</span>
<span class="built_in">NSArray</span> *numbers = [[<span class="built_in">NSArray</span> alloc] initWithObjects:
    number1, number2, number3, <span class="literal">nil</span>];

<span class="comment">//输出为1，因为number2，创建到number2就截止了</span>
<span class="built_in">NSLog</span>(<span class="string">@"numbers count: %d"</span>, numbers<span class="variable">.count</span>);
</code></pre><p>但是，如果用字面量语法创建，就是出问题：</p>
<pre><code>NSNumber <span class="keyword">*</span>number1 = <span class="comment">@1;</span>
NSNumber <span class="keyword">*</span>number2 = nil;
NSNumber <span class="keyword">*</span>number3 = <span class="comment">@3;</span>

//创建出现异常！！！
NSArray <span class="keyword">*</span>numbers = <span class="comment">@[number1, number2, number3];</span>

NSLog(<span class="comment">@"numbers count: %d", numbers.count);</span>
</code></pre><p>因为字面量语法只是单纯的将中括号中的元素全部加到数组中，但是，Objective-C中的数组是不可以存放nil值的，所以程序会运行时抛出异常。    </p>
<h2 id="NSDictionary">NSDictionary</h2><h3 id="创建-1">创建</h3><p>如果不用字面量语法创建字典，传统的创建函数简直令人匪夷所思：</p>
<pre><code><span class="comment">// number1-&gt;@1</span>
<span class="comment">// number2-&gt;@2</span>
<span class="built_in">NSDictionary</span> *dict = [[<span class="built_in">NSDictionary</span> alloc] initWithObjectsAndKeys:
    @<span class="number">1</span>, <span class="string">@"number1"</span>, @<span class="number">2</span>, <span class="string">@"number2"</span>, <span class="literal">nil</span>];
</code></pre><p>是不是很奇怪，<strong>value在前面，key在后面</strong></p>
<p>所以，还是用新的语法吧：</p>
<pre><code>NSDictionary *dict = @{@<span class="string">"number1"</span> : <span class="localvars">@1</span>, @<span class="string">"number2"</span> : <span class="localvars">@2</span>}<span class="comment">;</span>
</code></pre><p>这样才符合“常识”嘛，key在前，value在后面，跟JSON的定义一样。  </p>
<h3 id="存取值-1">存取值</h3><p>取值的语法跟NSArray的语法很想，只不过是将下标数字变成了key：</p>
<pre><code><span class="comment">//传统</span>
NSNumber *number1 = [dict <span class="string">objectForKey:</span>@<span class="string">"number1"</span>];
[dict <span class="string">setValue:</span>@<span class="number">5</span> <span class="string">forKey:</span>@<span class="string">"number1"</span>];

<span class="comment">//字面量语法</span>
NSNumber *number2 = dict[@<span class="string">"number1"</span>];
dict[@<span class="string">"number1"</span>] = @<span class="number">6</span>;
</code></pre><h3 id="注意">注意</h3><p>需要注意的地方，跟创建数组一样，NSDictionary的value不能为nil值，否则会抛出异常。</p>
<h2 id="总结">总结</h2><p>总的来说，使用字面量语法可以让代码更加清晰、简单，毕竟，更少的代码，有时候意味着更少的错误。      </p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>item 3讲的是Objective-C里面的“字面量语法”-“Literal Syntax”，个人觉得非常有用。</p>
<h2 id="Item_3_-_Prefer_Literal_Syntax_over_the_Equivalent_Methods">Item 3 - Prefer Literal Syntax over the Equivalent Methods</h2><p>本节讲了Objective-C中的“字面量语法”，并且建议我们更多的使用这种语法，而不是使用传统的等价的函数方法。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="笔记" scheme="http://tutuge.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="翻译" scheme="http://tutuge.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>