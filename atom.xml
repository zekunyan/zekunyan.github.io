<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>土土哥的技术Blog</title>
  
  <subtitle>iOS&amp;Android程序猿,喜欢Mac,Linux,各种开源技术,各种语言,RCFans</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tutuge.me/"/>
  <updated>2019-07-28T18:17:19.747Z</updated>
  <id>http://tutuge.me/</id>
  
  <author>
    <name>燕泽堃</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>好久没有更新博客-惭愧啊=。=</title>
    <link href="http://tutuge.me/2019/07/29/2019-07-29-occupied-with-work/"/>
    <id>http://tutuge.me/2019/07/29/2019-07-29-occupied-with-work/</id>
    <published>2019-07-28T17:59:00.000Z</published>
    <updated>2019-07-28T18:17:19.747Z</updated>
    
    <content type="html"><![CDATA[<p>周末才发现博客的个人简介图片都挂了。。。<a href="http://tutuge.me/about/">http://tutuge.me/about/</a><br>才想起来好久没有更新了=。=<br>TODO List上攒了一堆的“要写、要分享”的内容<br>但是迟迟没有动手<br>一直以来都用“工作太忙、没想好、积累不够”搪塞自己</p><p>哎。。。<br>其实还是<strong>太懒</strong><br>自从工作了以后<br>Geek精神感觉就被放入了牢笼<br>慢慢陷入了<strong>舒适区</strong><br>虽然工作上一直很顺利<br>但是内心总有不安与悸动</p><p>生活的意义是什么？<br>工作的目标是什么？<br>从小只想着“星辰大海”<br>现在只盼望“升职加薪”</p><p>唯有<strong>英国诗人狄兰·托马斯的《不要温和地走进那个良夜》</strong>在脑海里回响：</p><blockquote><p>Do not go gentle into that good night,<br>Old age should burn and rave at close of day;<br>Rage, rage against the dying of the light.<br>…</p></blockquote><p><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g5g3gj9dr8j31hg0u0b2a.jpg" alt="Interstellar"></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周末才发现博客的个人简介图片都挂了。。。&lt;a href=&quot;http://tutuge.me/about/&quot;&gt;http://tutuge.me/about/&lt;/a&gt;&lt;br&gt;才想起来好久没有更新了=。=&lt;br&gt;TODO List上攒了一堆的“要写、要分享”的内容&lt;br&gt;但是迟迟没有动手&lt;br&gt;一直以来都用“工作太忙、没想好、积累不够”搪塞自己&lt;/p&gt;
&lt;p&gt;哎。。。&lt;br&gt;其实还是&lt;strong&gt;太懒&lt;/strong&gt;&lt;br&gt;自从工作了以后&lt;br&gt;Geek精神感觉就被放入了牢笼&lt;br&gt;慢慢陷入了&lt;strong&gt;舒适区&lt;/strong&gt;&lt;br&gt;虽然工作上一直很顺利&lt;br&gt;但是内心总有不安与悸动&lt;/p&gt;
&lt;p&gt;生活的意义是什么？&lt;br&gt;工作的目标是什么？&lt;br&gt;从小只想着“星辰大海”&lt;br&gt;现在只盼望“升职加薪”&lt;/p&gt;
&lt;p&gt;唯有&lt;strong&gt;英国诗人狄兰·托马斯的《不要温和地走进那个良夜》&lt;/strong&gt;在脑海里回响：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Do not go gentle into that good night,&lt;br&gt;Old age should burn and rave at close of day;&lt;br&gt;Rage, rage against the dying of the light.&lt;br&gt;…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://tva1.sinaimg.cn/large/0060lm7Tly1g5g3gj9dr8j31hg0u0b2a.jpg&quot; alt=&quot;Interstellar&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="其它" scheme="http://tutuge.me/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="杂烩" scheme="http://tutuge.me/tags/%E6%9D%82%E7%83%A9/"/>
    
  </entry>
  
  <entry>
    <title>阿里巴巴国际无线技术部 - 招人啦～求iOS、Android、Java</title>
    <link href="http://tutuge.me/2018/05/01/alibaba-icbu-mobile-hc-get/"/>
    <id>http://tutuge.me/2018/05/01/alibaba-icbu-mobile-hc-get/</id>
    <published>2018-04-30T16:00:01.000Z</published>
    <updated>2019-07-28T18:14:32.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阿里巴巴（中国）网络技术有限公司"><a href="#阿里巴巴（中国）网络技术有限公司" class="headerlink" title="阿里巴巴（中国）网络技术有限公司"></a>阿里巴巴（中国）网络技术有限公司</h1><h2 id="招人啦～求iOS、Android、Java"><a href="#招人啦～求iOS、Android、Java" class="headerlink" title="招人啦～求iOS、Android、Java"></a>招人啦～求iOS、Android、Java</h2><p>大量招人啊～～～真实信息绝无有假啊～～～我不是HR不是猎头，我是开发啊～～～我就是土土哥啊～～～</p><ul><li>工作地点：杭州，滨江</li><li>简历投递邮箱：<a href="mailto:zekun.yzk@alibaba-inc.com" target="_blank" rel="noopener">zekun.yzk@alibaba-inc.com</a></li><li>关键词：<strong>有竞争力的薪酬、大神云集、集团战略重点</strong></li><li>软文：<a href="http://tutuge.me/2017/09/28/alibaba-icbu-mobile-hc/">阿里巴巴国际无线技术部 - 在这里遇见最好的自己</a></li></ul><a id="more"></a><hr><h2 id="国际技术事业部-ICBU技术部-iOS高级开发工程师（P6-P7）"><a href="#国际技术事业部-ICBU技术部-iOS高级开发工程师（P6-P7）" class="headerlink" title="国际技术事业部-ICBU技术部-iOS高级开发工程师（P6/P7）"></a>国际技术事业部-ICBU技术部-iOS高级开发工程师（P6/P7）</h2><h3 id="岗位描述"><a href="#岗位描述" class="headerlink" title="岗位描述:"></a>岗位描述:</h3><ol><li>根据业务需求，基于iOS平台进行应用程序开发； </li><li>参与移动平台软件框架的研究，设计和实现、关键技术验证和选型等工作； </li><li>带领并指导开发工程师、程序员进行代码开发等工作； </li><li>参与移动规范制订、技术文档编写。</li></ol><h3 id="岗位要求"><a href="#岗位要求" class="headerlink" title="岗位要求:"></a>岗位要求:</h3><ol><li>本科及以上学历，计算机或相关专业； </li><li>三年及以上手机应用实际开发经验，三年以上iOS开发经验，五年以上C/C+/Java开发经验； </li><li>精通Objective-C、Mac OS X、Xcode； </li><li>精通iOS SDK中的UI、网络、数据库、XML/JSON解析等开发技巧； </li><li>有多个完整的iOS项目经验，至少参加过一个完整的商业级手机应用或游戏开发项目； </li><li>熟悉各种主流手机特性，深刻理解手机客户端软件及服务端开发特点； </li><li>精通常用软件架构模式，熟悉各种算法与数据结构，多线程，网络编程（Socket、http/web service）等； </li><li>个性乐观开朗，逻辑思维强，善于团队合作。</li></ol><hr><h2 id="国际技术事业部-ICBU技术部-Android高级开发工程师（P6-P7）"><a href="#国际技术事业部-ICBU技术部-Android高级开发工程师（P6-P7）" class="headerlink" title="国际技术事业部-ICBU技术部-Android高级开发工程师（P6/P7）"></a>国际技术事业部-ICBU技术部-Android高级开发工程师（P6/P7）</h2><h3 id="岗位描述-1"><a href="#岗位描述-1" class="headerlink" title="岗位描述:"></a>岗位描述:</h3><ol><li>根据业务需求，基于Android平台进行应用程序开发； </li><li>参与移动平台软件框架的研究，设计和实现、关键技术验证和选型等工作; </li><li>参与移动规范制订、技术文档编写。</li></ol><h3 id="岗位要求-1"><a href="#岗位要求-1" class="headerlink" title="岗位要求:"></a>岗位要求:</h3><ol><li>3年以上客户端开发经验，精通Android手机平台。 </li><li>熟悉掌握至少一种主流手机平台编程语言（C，C++或Java等），有Java相关开发经验不少于2年 </li><li>精通一主流手机平台下的高性能编程及性能调优，精通一个系列以上的高市场占有率的手机环境 </li><li>开发基础良好，理解设计模式，在项目或产品中有很好的设计实践； </li><li>有强烈的责任心和团队精神，善于沟通和合作；能独立完成设计和编码； </li><li>对Android的UI控件有实际使用和优化经验者优先；有前端开发经验者优先；</li></ol><hr><h2 id="国际技术事业部-ICBU技术部-Java高级开发工程师（P6-P7）"><a href="#国际技术事业部-ICBU技术部-Java高级开发工程师（P6-P7）" class="headerlink" title="国际技术事业部-ICBU技术部-Java高级开发工程师（P6/P7）"></a>国际技术事业部-ICBU技术部-Java高级开发工程师（P6/P7）</h2><h3 id="岗位描述："><a href="#岗位描述：" class="headerlink" title="岗位描述："></a>岗位描述：</h3><ol><li>深入理解业务需求，参与业务讨论，进行相关系统的设计和开发，落地业务策略；</li><li>持续优化系统架构和系统的可扩展性，参与系统的长期设计规划；</li><li>持续优化系统稳定性，保障系统的高可用性。</li></ol><h3 id="岗位要求-2"><a href="#岗位要求-2" class="headerlink" title="岗位要求:"></a>岗位要求:</h3><ol><li>3年及以上使用JAVA开发的经验，JAVA基础扎实，理解io、多线程、集合等基础框架，了解JVM原理；</li><li>对用过的开源框架，能了解到它的原理和机制；对Spring,ibatis,struts等开源框架熟悉；</li><li>熟悉分布式系统的设计和应用，熟悉分布式、缓存、消息等机制；能对分布式常用技术进行合理应用，解决问题；</li><li>有互联网行业背景或国际化背景更好；</li></ol><h3 id="能力要求："><a href="#能力要求：" class="headerlink" title="能力要求："></a>能力要求：</h3><ul><li>有很强的技术兴趣，长年跟踪和学习技术的发展趋势;</li><li>有很强的沟通能力，对事情重点能够清晰描述和掌握;</li><li>有很强的推动能力，协调各方排除万难，共同完成目标;</li><li>有很强的同理心，能够站在对方的角度分析问题，理解对方;</li><li>有很强的乐观精神，相信未来一定会更好;</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;阿里巴巴（中国）网络技术有限公司&quot;&gt;&lt;a href=&quot;#阿里巴巴（中国）网络技术有限公司&quot; class=&quot;headerlink&quot; title=&quot;阿里巴巴（中国）网络技术有限公司&quot;&gt;&lt;/a&gt;阿里巴巴（中国）网络技术有限公司&lt;/h1&gt;&lt;h2 id=&quot;招人啦～求iOS、Android、Java&quot;&gt;&lt;a href=&quot;#招人啦～求iOS、Android、Java&quot; class=&quot;headerlink&quot; title=&quot;招人啦～求iOS、Android、Java&quot;&gt;&lt;/a&gt;招人啦～求iOS、Android、Java&lt;/h2&gt;&lt;p&gt;大量招人啊～～～真实信息绝无有假啊～～～我不是HR不是猎头，我是开发啊～～～我就是土土哥啊～～～&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工作地点：杭州，滨江&lt;/li&gt;
&lt;li&gt;简历投递邮箱：&lt;a href=&quot;mailto:zekun.yzk@alibaba-inc.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zekun.yzk@alibaba-inc.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;关键词：&lt;strong&gt;有竞争力的薪酬、大神云集、集团战略重点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;软文：&lt;a href=&quot;http://tutuge.me/2017/09/28/alibaba-icbu-mobile-hc/&quot;&gt;阿里巴巴国际无线技术部 - 在这里遇见最好的自己&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="其它" scheme="http://tutuge.me/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="杂烩" scheme="http://tutuge.me/tags/%E6%9D%82%E7%83%A9/"/>
    
  </entry>
  
  <entry>
    <title>转-阿里巴巴国际无线技术部 - 在这里遇见最好的自己</title>
    <link href="http://tutuge.me/2017/09/28/alibaba-icbu-mobile-hc/"/>
    <id>http://tutuge.me/2017/09/28/alibaba-icbu-mobile-hc/</id>
    <published>2017-09-27T16:00:00.000Z</published>
    <updated>2018-10-07T17:37:29.590Z</updated>
    
    <content type="html"><![CDATA[<h2 id="转自"><a href="#转自" class="headerlink" title="转自"></a>转自</h2><p>给自己部门的软文！<br><a href="http://icbu.info/welcome-to-icbu/" target="_blank" rel="noopener">阿里巴巴国际无线技术部 - 在这里遇见最好的自己</a></p><h2 id="我们做什么"><a href="#我们做什么" class="headerlink" title="我们做什么"></a>我们做什么</h2><p>阿里巴巴国际无线技术部背靠阿里巴巴集团和阿里巴巴国际站，阿里巴巴国际站是全球领先的跨境B2B贸易服务平台，服务全世界数以千万计的采购商和供应商，阿里巴巴国际站（<a href="http://www.alibaba.com）帮助中小企业拓展国际贸易的出口营销推广服务，专注服务于全球中小微企业，在平台上，通过向海外买家展示、推广供应商的企业和产品，进而获得贸易商机和订单，买卖双方可以在线更高效地找到适合的彼此，并更快更安心地达成交易，是出口企业拓展国际贸易的首选跨境贸易平台。" target="_blank" rel="noopener">www.alibaba.com）帮助中小企业拓展国际贸易的出口营销推广服务，专注服务于全球中小微企业，在平台上，通过向海外买家展示、推广供应商的企业和产品，进而获得贸易商机和订单，买卖双方可以在线更高效地找到适合的彼此，并更快更安心地达成交易，是出口企业拓展国际贸易的首选跨境贸易平台。</a></p><p>阿里巴巴国际站技术致力于打造一站式eWTP全球国际B类贸易服务平台解决方案。近年来，随着智能手机的普及无线的趋势已经锐不可当。阿里巴巴国际无线技术部不仅是站在阿里巴巴集团和阿里巴巴国际站两个巨人的肩上，更是站在无线时代的浪潮之上。来吧少年，一起为全球中小企业服务！</p><a id="more"></a><h2 id="我们在哪里"><a href="#我们在哪里" class="headerlink" title="我们在哪里"></a>我们在哪里</h2><h3 id="杭州-一座来了就不想走的城市"><a href="#杭州-一座来了就不想走的城市" class="headerlink" title="杭州 - 一座来了就不想走的城市"></a>杭州 - 一座来了就不想走的城市</h3><p>杭州有“欲把西湖比西子，淡妆浓抹总相宜”的西湖，<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/175b41acb93011a4e220fbcf498603f0.png" alt="4feb7f9bc5d49be00e1ef5c333629572.png"></p><p>杭州有“钱塘岸上春如织，淼淼寒潮带晴色”的钱塘江（潮），<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/4781472e7fb735b122b5a47faf8c135a.png" alt="266bd18a3fdb4f9746534e534992564b.png"></p><p>杭州有“最爱湖东行不足，绿杨阴里白沙堤”的白堤，<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/691676d5035cbdd8aa78e2514f7e4b26.png" alt="eae547f37ace3cc6b7e484d3499a096c.png"></p><p>。。。。。。</p><p>从古至今无数的文人墨客为杭州驻足，给杭州添色。正所谓“你在杭州看风景,看风景的人在历史中看你”。古有一本《西湖梦寻》让无数人慕名杭州，今有一家“阿里巴巴”让追梦人逐梦杭州。来吧少年，“江南无所有，聊赠一聘书”。</p><h2 id="为什么是我们"><a href="#为什么是我们" class="headerlink" title="为什么是我们"></a>为什么是我们</h2><p>阿里巴巴早已经是一家庞大的集团公司，有大家熟知的淘宝、天猫等等。然而我却要说请记住它们，但请来阿里巴巴国际无线技术部：</p><h3 id="内部环境：国际化-集团三大战略之一"><a href="#内部环境：国际化-集团三大战略之一" class="headerlink" title="内部环境：国际化 - 集团三大战略之一"></a>内部环境：国际化 - 集团三大战略之一</h3><p>早在2015年阿里巴巴集团提出：农村化、国际化、大数据和云计算是阿里巴巴集团未来的三大战略，2016年马老师又创造性的提出了eWTP，2016年9月马老师在二十国集团工商峰会（B20）发表演讲，系统性的阐述eWTP的理念、愿景和行动计划。并且在一年中几乎飞遍全球，向各国政府、国际组织描述和倡议eWTP。<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/04a5d40cf5de4a9d7cb7e8b585cd92dc.png" alt="49268106f804b42c44126ee5d4b50360.png"></p><p>2017年6月阿里巴巴在美国底特律举办大规模的论坛，马老师做了“中国的贸易机会”的主题演讲，更是承诺未来的5年内在美国创造100万的工作机。<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/e6d2d85ca980dee8afe223cd3e10c71e.png" alt="9da3ce0ea7ca889ff0956449093055a2.png"></p><p>无论是国际化、eWTP和中美贸易阿里巴巴国际无线技术部都是最重要的战场。</p><h3 id="外部环境：一带一路-国家级顶层战略"><a href="#外部环境：一带一路-国家级顶层战略" class="headerlink" title="外部环境：一带一路 - 国家级顶层战略"></a>外部环境：一带一路 - 国家级顶层战略</h3><p>2013年，中国首次超越美国跃居世界第一大贸易国。持续三年世界第一之后，世贸组织（WTO）的最新数据显示，2016年中国的进出口贸易额被美国反超，丧失了“世界第一外贸国家”的称号。</p><p>2015国家发展改革委、外交部、商务部联合发布了《推动共建丝绸之路经济带和21世纪海上丝绸之路的愿景与行动》，即是大家熟知的“一带一路”。它将充分依靠中国与有关国家既有的双多边机制，借助既有的、行之有效的区域合作平台，一带一路旨在借用古代丝绸之路的历史符号，高举和平发展的旗帜，积极发展与沿线国家的经济合作伙伴关系，共同打造政治互信、经济融合、文化包容的利益共同体、命运共同体和责任共同体。可以说“一带一路”和eWTP有异曲同工之秒。</p><p>2017年3月16号《中国新外贸模式研究报告》正式发布，重点分析了以阿里巴巴为代表的新外贸模式。结论是：新外贸模式极大降低了中国外贸的交易成本，同时交易平台提供的信息、数据和生态价值，会随时间增加为企业带来更大价值。阿里巴巴提倡的新外贸模式是外贸行业的新拐点。</p><p>无论是内部环境还是外部环境，作为阿里巴巴发家的阿里巴巴国际站正站在新的历史起点欲展翅翱翔，来吧少年，一起鹰击长空。</p><h2 id="我们的技术"><a href="#我们的技术" class="headerlink" title="我们的技术"></a>我们的技术</h2><p>在新技术上无论是Andriod还是iOS，我们积极跟进业内新技术，试验落地。比如：在Apple Watch产品发布之初便做了适配、遵循Andriod的MD规范、DeepLink、Firebase等；在国际化上自研多语言的实时更新引擎、RTL适配，做到覆盖全球所有主流语种、货币单位等。  </p><p>阿里巴巴国际无线技术部出品的Alibaba.com Andriod APP 多次获得Google Play官方推荐，以2017年3月10日为例：我们获得Google Play 104个国家的主页和购物分类的黄金展位。这是我们不断追求卓越，不断提升用户体验，不断创新的结果。由于我们在技术上的精益求精，我们始终和Google保持着非常良好的合作关系。<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/8603c70eae9fb9f962fc0a0bda80f413.png" alt="bf7fbddf181556817e7f6eb4c6eb6219.png"><br>更多的荣誉：<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/d8f8a426f79f3e77a425bf6a0a1c997d.png" alt="Frame1.png"></p><p>来吧少年，一起码出未来！</p><h2 id="我们的团队"><a href="#我们的团队" class="headerlink" title="我们的团队"></a>我们的团队</h2><p>阿里巴巴国际无线技术部现聚集40多名江湖三大名门正派（Andriod, iOS,JAVA）的顶级高手，由江湖人称“小马哥”的带头大哥领导，在这里每一个人都身怀绝技，一起来走进这些可爱的小伙伴吧：</p><h3 id="如果你是终生学习者，如果你对认知科学、商业本质感兴趣，来吧少年！"><a href="#如果你是终生学习者，如果你对认知科学、商业本质感兴趣，来吧少年！" class="headerlink" title="如果你是终生学习者，如果你对认知科学、商业本质感兴趣，来吧少年！"></a>如果你是终生学习者，如果你对认知科学、商业本质感兴趣，来吧少年！</h3><p>“小马哥”之所以称为“小马哥”，不仅仅因为他姓马，也不仅仅他的英文名叫“Jack”，更重要的是有马老师的风采。如果你常年关注“得到APP”，你一定对傅盛、刘润、罗胖、李笑来等等如数家珍，那么来吧少年，在这里近距离感受“小马哥”价值2W的《认知升级》。在这里每一天都是成长！<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/b537531d13ce08f1463bce9e97ac0acc.png" alt="Frame4.png"></p><h3 id="如果你是iOS的开发者，又常见混迹开源社区，来吧少年！"><a href="#如果你是iOS的开发者，又常见混迹开源社区，来吧少年！" class="headerlink" title="如果你是iOS的开发者，又常见混迹开源社区，来吧少年！"></a>如果你是iOS的开发者，又常见混迹开源社区，来吧少年！</h3><p>曾宪华：Github账号xhzengAIB，Objective-C社区世界排名15，中国排名第6。来吧少年！和大神面对面。<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/60ea9f6cad94a3e0ac2e1bb121e8bc86.png" alt="Frame3.png"></p><p>更多大神的资料请看：<br><a href="http://zengxianhua.com" target="_blank" rel="noopener">http://zengxianhua.com</a><br><a href="http://tutuge.me">http://tutuge.me</a><br><a href="http://www.tanhao.me" target="_blank" rel="noopener">http://www.tanhao.me</a><br><a href="https://github.com/zekunyan" target="_blank" rel="noopener">https://github.com/zekunyan</a><br><a href="https://github.com/caoping" target="_blank" rel="noopener">https://github.com/caoping</a>  </p><h3 id="如果你怀有一颗不安分的心，来吧少年！"><a href="#如果你怀有一颗不安分的心，来吧少年！" class="headerlink" title="如果你怀有一颗不安分的心，来吧少年！"></a>如果你怀有一颗不安分的心，来吧少年！</h3><p>我们一起去探索这个世界：<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6b33d913bad296d6a9284c25cbd25f57.png" alt="Frameo.png"></p><h3 id="如果你精通八大菜系，来吧少年！"><a href="#如果你精通八大菜系，来吧少年！" class="headerlink" title="如果你精通八大菜系，来吧少年！"></a>如果你精通八大菜系，来吧少年！</h3><p>我们一起去吃遍全球：<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/5858ddc3d4ec7baac08fc659ca1fb739.png" alt="Frame.png"><br>如果以上这些都还不够打动你，那么下面一张一定可以：<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/e49449564295d68aa2dbe212193b7cf6.png" alt="Frame-wu.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;转自&quot;&gt;&lt;a href=&quot;#转自&quot; class=&quot;headerlink&quot; title=&quot;转自&quot;&gt;&lt;/a&gt;转自&lt;/h2&gt;&lt;p&gt;给自己部门的软文！&lt;br&gt;&lt;a href=&quot;http://icbu.info/welcome-to-icbu/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阿里巴巴国际无线技术部 - 在这里遇见最好的自己&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;我们做什么&quot;&gt;&lt;a href=&quot;#我们做什么&quot; class=&quot;headerlink&quot; title=&quot;我们做什么&quot;&gt;&lt;/a&gt;我们做什么&lt;/h2&gt;&lt;p&gt;阿里巴巴国际无线技术部背靠阿里巴巴集团和阿里巴巴国际站，阿里巴巴国际站是全球领先的跨境B2B贸易服务平台，服务全世界数以千万计的采购商和供应商，阿里巴巴国际站（&lt;a href=&quot;http://www.alibaba.com）帮助中小企业拓展国际贸易的出口营销推广服务，专注服务于全球中小微企业，在平台上，通过向海外买家展示、推广供应商的企业和产品，进而获得贸易商机和订单，买卖双方可以在线更高效地找到适合的彼此，并更快更安心地达成交易，是出口企业拓展国际贸易的首选跨境贸易平台。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.alibaba.com）帮助中小企业拓展国际贸易的出口营销推广服务，专注服务于全球中小微企业，在平台上，通过向海外买家展示、推广供应商的企业和产品，进而获得贸易商机和订单，买卖双方可以在线更高效地找到适合的彼此，并更快更安心地达成交易，是出口企业拓展国际贸易的首选跨境贸易平台。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;阿里巴巴国际站技术致力于打造一站式eWTP全球国际B类贸易服务平台解决方案。近年来，随着智能手机的普及无线的趋势已经锐不可当。阿里巴巴国际无线技术部不仅是站在阿里巴巴集团和阿里巴巴国际站两个巨人的肩上，更是站在无线时代的浪潮之上。来吧少年，一起为全球中小企业服务！&lt;/p&gt;
    
    </summary>
    
      <category term="其它" scheme="http://tutuge.me/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="杂烩" scheme="http://tutuge.me/tags/%E6%9D%82%E7%83%A9/"/>
    
  </entry>
  
  <entry>
    <title>反编译分析并模拟实现methodSignatureForSelector方法</title>
    <link href="http://tutuge.me/2017/04/08/diy-methodSignatureForSelector/"/>
    <id>http://tutuge.me/2017/04/08/diy-methodSignatureForSelector/</id>
    <published>2017-04-08T14:38:52.000Z</published>
    <updated>2018-10-07T17:37:29.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近跟同事讨论了有关<code>methodSignatureForSelector:</code>的问题，大概如下：</p><blockquote><ol><li>一个ProtocolA声明了一个实例方法funcA，然后一个类ClassA声明实现这个ProtocolA，但是并没有实现方法funcA，对ClassA的实例调用<code>methodSignatureForSelector:@selector(funcA)</code>能否返回正确的signature？</li><li>一个类ClassB，在@interface声明了实例方法funcB，但是没有实现funcB，对ClassB的实例调用<code>methodSignatureForSelector:@selector(funcB)</code>，能否返回正确的signature？</li></ol></blockquote><p>写个Demo验证了下，结果非常有意思，不由得好奇起来，所以深入研究了下<code>methodSignatureForSelector:</code>的实现，然后自己模拟实现出来。</p><p>Github地址：<a href="https://github.com/zekunyan/TTGRemakeMethodSignatureForSelector" target="_blank" rel="noopener">TTGRemakeMethodSignatureForSelector</a></p><p>详细的研究过程如下：</p><a id="more"></a><h2 id="写Demo验证问题"><a href="#写Demo验证问题" class="headerlink" title="写Demo验证问题"></a>写Demo验证问题</h2><p>测试类TestClass和Protocol如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@protocol</span> TestProtocol &lt;NSObject&gt;</span><br><span class="line">- (void)protocolTestFunc1;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">TestClass </span>: NSObject &lt;TestProtocol&gt; <span class="comment">// 不实现Protocol任何方法</span></span><br><span class="line">- (void)testFunc1; <span class="comment">// 不实现</span></span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"><span class="variable">@implementation</span> TestClass</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>调用<code>methodSignatureForSelector:</code>获取<code>protocolTestFunc1</code>和<code>testFunc1</code>的methodSignature，<code>protocolTestFunc1</code>可以获取到，但是<code>testFunc1</code>就不行。</p><h2 id="扩展到所有情况"><a href="#扩展到所有情况" class="headerlink" title="扩展到所有情况"></a>扩展到所有情况</h2><p>分析整理下可能的情况：</p><p>对于一个类：</p><ol><li>方法没有声明，也没有实现</li><li>方法有声明，但是没有实现</li><li>方法没有声明，但是有实现</li><li>实例方法和类方法都有上面1、2、3的情况</li></ol><p>对于一个Protocol：</p><ol><li>方法有声明，但是没有实现</li><li>实例方法和类方法</li><li>required和optional方法</li></ol><p><strong>经过验证，发现：</strong></p><ol><li><strong>对于类，只要@implementation里实现了方法，不管@interface是否有声明，都可以返回methodSignature</strong></li><li><strong>对于Protocol声明的方法，不管实例方法还是类方法，不管required还是optional的，都可以返回methodSignature</strong></li></ol><p>所以，有必要进一步研究<code>methodSignatureForSelector:</code>的实现。</p><h2 id="从Runtime源码入手"><a href="#从Runtime源码入手" class="headerlink" title="从Runtime源码入手"></a>从Runtime源码入手</h2><p><code>methodSignatureForSelector:</code>是<code>NSObject</code>的方法，所以想知道原理，第一步当然就是翻看Runtime的源码，看看有没有实现，最新的<code>objc4-709</code>源码，实现如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// From objc4-709 NSObject.mm</span></span><br><span class="line"><span class="comment">// Replaced by CF (returns an NSMethodSignature)</span></span><br><span class="line"><span class="selector-tag">-</span> (NSMethodSignature *)<span class="selector-tag">methodSignatureForSelector</span><span class="selector-pseudo">:(SEL)sel</span> &#123;</span><br><span class="line">    <span class="selector-tag">_objc_fatal</span>(<span class="string">"-[NSObject methodSignatureForSelector:] "</span></span><br><span class="line">                <span class="string">"not available without CoreFoundation"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，Runtime源码是没有实现的，要到CoreFoundation里面找。</p><h2 id="找CoreFoundation源码"><a href="#找CoreFoundation源码" class="headerlink" title="找CoreFoundation源码"></a>找CoreFoundation源码</h2><p>接着Google CoreFoundation源码，找到<a href="https://opensource.apple.com/source/CF/CF-1153.18/" target="_blank" rel="noopener">https://opensource.apple.com/source/CF/CF-1153.18/</a>，怎么都找不到有关<code>methodSignatureForSelector:</code>的实现，难道要就此打住？</p><h2 id="反编译大法"><a href="#反编译大法" class="headerlink" title="反编译大法"></a>反编译大法</h2><p>既然找不到源码，那就只好祭出反编译大法，直接上汇编=。=</p><h3 id="找到CoreFoundation动态库"><a href="#找到CoreFoundation动态库" class="headerlink" title="找到CoreFoundation动态库"></a>找到CoreFoundation动态库</h3><p>CoreFoundation是在程序运行时链接上去的动态库，属于系统动态库的一部分，所以首先要找到CoreFoundation动态库的二进制代码文件，命令行：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo -<span class="built_in">i</span></span><br><span class="line"><span class="built_in">find</span> / -name CoreFoundation.framework</span><br></pre></td></tr></table></figure><p>搜到的结果很多，以iPhone模拟器的为例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneSimulator.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneSimulator.sdk/</span>System<span class="regexp">/Library/</span>Frameworks<span class="regexp">/CoreFoundation.framework</span></span><br></pre></td></tr></table></figure><p>打开<code>CoreFoundation.framework</code>文件夹，<code>CoreFoundation</code>文件就是要反编译的文件。</p><h3 id="Hopper-Disassembler反编译"><a href="#Hopper-Disassembler反编译" class="headerlink" title="Hopper Disassembler反编译"></a>Hopper Disassembler反编译</h3><p>用Hopper Disassembler打开<code>CoreFoundation</code>文件，在Labels搜索<code>methodSignatureForSelector:</code>，就能找到对应的汇编实现代码，如下：</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvbqcq2ifsj30tv0bqjte.jpg" alt=""></p><p>Hopper翻译的代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * +[<span class="built_in">NSObject</span> methodSignatureForSelector:](<span class="keyword">void</span> * <span class="keyword">self</span>, <span class="keyword">void</span> * _cmd, <span class="keyword">void</span> * arg2) &#123;</span><br><span class="line">    rdi = <span class="keyword">self</span>;</span><br><span class="line">    rbx = arg2;</span><br><span class="line">    <span class="keyword">if</span> ((rbx != <span class="number">0x0</span>) &amp;&amp; (___methodDescriptionForSelector(object_getClass(rdi), rbx) != <span class="number">0x0</span>)) &#123;</span><br><span class="line">            rax = [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:rdx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">            rax = <span class="number">0x0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可发现，关键在于<code>___methodDescriptionForSelector:</code>方法。</p><h3 id="methodDescriptionForSelector-方法的实现"><a href="#methodDescriptionForSelector-方法的实现" class="headerlink" title="___methodDescriptionForSelector:方法的实现"></a>___methodDescriptionForSelector:方法的实现</h3><p>进一步看<code>___methodDescriptionForSelector:</code>的实现。</p><p>汇编代码、Hopper翻译的代码都很长，循环也不见了，全是goto：</p><p><img src="/2017/04/08/diy-methodSignatureForSelector/blog_RemakeMethodSignatureForSelector_3.jpg" alt=""></p><p>经过反复校对整理（排除Hopper的错误=。=），可以整理出主要的流程如下图所示：</p><p><img src="/2017/04/08/diy-methodSignatureForSelector/blog_RemakeMethodSignatureForSelector_2.png" alt=""></p><p>根据流程，可以得出，<code>___methodDescriptionForSelector:</code>方法：</p><ol><li>用<code>class_copyProtocolList</code>、<code>protocol_getMethodDescription</code>方法，检查是否有对应的selector，不管是否实现</li><li>用<code>class_getInstanceMethod</code>检查selector是否有<strong>implementation</strong>，注意，是<strong>implementation</strong>，跟是否声明了没有关系</li></ol><p>所以，符合前面的结论。</p><h2 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h2><p>流程都有了，不如更进一步，自己实现一个<code>methodSignatureForSelector:</code>方法出来～</p><h3 id="模拟实现-methodDescriptionForSelector"><a href="#模拟实现-methodDescriptionForSelector" class="headerlink" title="模拟实现___methodDescriptionForSelector:"></a>模拟实现___methodDescriptionForSelector:</h3><p>按照流程，实现代码如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟实现___methodDescriptionForSelector方法：</span></span><br><span class="line">struct objc_method_description ttg_MethodDescription(<span class="keyword">Class</span> <span class="keyword">class</span>, SEL sel) &#123;</span><br><span class="line">    <span class="comment">// 结果</span></span><br><span class="line">    struct objc_method_description <span class="keyword">description</span> = (struct objc_method_description)&#123;<span class="keyword">NULL</span>, <span class="keyword">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">Class</span> currentClass = <span class="keyword">class</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (currentClass &amp;&amp; <span class="keyword">description</span>.name == <span class="keyword">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取Protocol列表</span></span><br><span class="line">        unsigned <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">        __unsafe_unretained Protocol **protocols = class_copyProtocolList(currentClass, &amp;<span class="keyword">count</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历所有Protocol</span></span><br><span class="line">        <span class="keyword">for</span> (unsigned <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">count</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// Required 方法</span></span><br><span class="line">            <span class="keyword">description</span> = protocol_getMethodDescription(protocols[i], sel, YES, class_isMetaClass(currentClass) ^ <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">description</span>.name != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Optional 方法</span></span><br><span class="line">            <span class="keyword">description</span> = protocol_getMethodDescription(protocols[i], sel, NO, class_isMetaClass(currentClass) ^ <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">description</span>.name != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 释放</span></span><br><span class="line">        free(protocols);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到、返回</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">description</span>.name != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">description</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取父类，继续</span></span><br><span class="line">        currentClass = class_getSuperclass(currentClass);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取实例方法</span></span><br><span class="line">    Method method = class_getInstanceMethod(<span class="keyword">class</span>, sel);</span><br><span class="line">    <span class="keyword">if</span> (method) &#123;</span><br><span class="line">        <span class="comment">// 找到实例方法</span></span><br><span class="line">        <span class="keyword">return</span> *method_getDescription(method);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 返回空</span></span><br><span class="line">        <span class="keyword">return</span> (struct objc_method_description)&#123;<span class="keyword">NULL</span>, <span class="keyword">NULL</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>用description记录迭代中的结果，只要找到就返回</li><li>用currentClass记录每次迭代的类class</li><li>Protocol的@required和@optional方法都要检查</li><li>注意释放Protocol数组</li><li>最后才用<code>class_getInstanceMethod</code>获取类本身的实现</li></ol><h3 id="模拟实现methodSignatureForSelector"><a href="#模拟实现methodSignatureForSelector" class="headerlink" title="模拟实现methodSignatureForSelector:"></a>模拟实现methodSignatureForSelector:</h3><p>用Category给NSObject加两个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">TTGRemakeMethodSignatureForSelector</span>)</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)ttg_methodSignatureForSelector:(SEL)sel;</span><br><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)ttg_methodSignatureForSelector:(SEL)sel;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>实现基本一样：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">TTGRemakeMethodSignatureForSelector</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)ttg_methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_description description = ttg_MethodDescription([<span class="keyword">self</span> <span class="keyword">class</span>], sel); <span class="comment">// 注意！是获取实例的class</span></span><br><span class="line">    <span class="keyword">if</span> (sel &amp;&amp; description.types != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:description.types];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)ttg_methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_description description = ttg_MethodDescription(object_getClass(<span class="keyword">self</span>), sel); <span class="comment">// 必须用object_getClass获取metaClass</span></span><br><span class="line">    <span class="keyword">if</span> (sel &amp;&amp; description.types != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:description.types];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><strong>注意要获取正确的”class”：</strong></p><ol><li>对于对象实例，从<code>[obj class]</code>、<code>object_getClass(obj)</code>结果一致，都是对象的类</li><li>对于类，要获取元类，也就是metaClass，只能用<code>object_getClass(class)</code></li></ol><h3 id="验证模拟实现"><a href="#验证模拟实现" class="headerlink" title="验证模拟实现"></a>验证模拟实现</h3><p>验证自己模拟实现的<code>methodSignatureForSelector:</code>和系统的是否一致：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试equal相等</span></span><br><span class="line">NSMethodSignature *signature1 = [test methodSignatureForSelector:<span class="meta">@selector(testFunc1)</span>];</span><br><span class="line">NSMethodSignature *signature2 = [test ttg_methodSignatureForSelector:<span class="meta">@selector(testFunc1)</span>];</span><br><span class="line">NSLog(@<span class="string">"signature1 == signature2: %d"</span>, [signature1 isEqual:signature2]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke实例方法</span></span><br><span class="line">NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[test ttg_methodSignatureForSelector:<span class="meta">@selector(testFunc1)</span>]];</span><br><span class="line">invocation.target = test;</span><br><span class="line">invocation.selector = <span class="meta">@selector(testFunc1)</span>;</span><br><span class="line">[invocation invoke];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke类方法</span></span><br><span class="line">invocation = [NSInvocation invocationWithMethodSignature:[TestClass ttg_methodSignatureForSelector:<span class="meta">@selector(staticTestFunc1)</span>]];</span><br><span class="line">invocation.target = [TestClass <span class="class"><span class="keyword">class</span>];</span></span><br><span class="line">invocation.selector = <span class="meta">@selector(staticTestFunc1)</span>;</span><br><span class="line">[invocation invoke];</span><br></pre></td></tr></table></figure><p>结果跟系统实现的行为一致，更多Case见Github的Demo。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从两个小问题出发，到最后通过反编译、模拟实现，终于搞清楚了<code>methodSignatureForSelector:</code>的原理、流程、各种隐藏特性！哈哈～～过瘾～～</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近跟同事讨论了有关&lt;code&gt;methodSignatureForSelector:&lt;/code&gt;的问题，大概如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;一个ProtocolA声明了一个实例方法funcA，然后一个类ClassA声明实现这个ProtocolA，但是并没有实现方法funcA，对ClassA的实例调用&lt;code&gt;methodSignatureForSelector:@selector(funcA)&lt;/code&gt;能否返回正确的signature？&lt;/li&gt;
&lt;li&gt;一个类ClassB，在@interface声明了实例方法funcB，但是没有实现funcB，对ClassB的实例调用&lt;code&gt;methodSignatureForSelector:@selector(funcB)&lt;/code&gt;，能否返回正确的signature？&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;写个Demo验证了下，结果非常有意思，不由得好奇起来，所以深入研究了下&lt;code&gt;methodSignatureForSelector:&lt;/code&gt;的实现，然后自己模拟实现出来。&lt;/p&gt;
&lt;p&gt;Github地址：&lt;a href=&quot;https://github.com/zekunyan/TTGRemakeMethodSignatureForSelector&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TTGRemakeMethodSignatureForSelector&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;详细的研究过程如下：&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>反编译分析Xcode8的Bug, release下连续两次调用有二级指针参数的空方法会Crash</title>
    <link href="http://tutuge.me/2017/03/14/xcode8-crash-on-out-parameter/"/>
    <id>http://tutuge.me/2017/03/14/xcode8-crash-on-out-parameter/</id>
    <published>2017-03-13T16:00:00.000Z</published>
    <updated>2018-10-07T17:37:29.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><ul><li>在最新的Xcode 9 Beta版本中，此Bug已被苹果修复：<strong>Bug ID 30530580: Crash on “Release” Build Configuration scheme setting for Out Parameters code</strong></li></ul><h2 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h2><p>二级指针，也叫指针的指针，或者Out Parameters，可以用来改变一个指针的地址值，由于在Objective-C里面方法、函数不支持返回多个值，所以经常用二级指针实现这个功能，比如<code>NSFileManager</code>的<code>- (BOOL)removeItemAtURL:(NSURL *)URL error:(NSError **)error</code>方法，就可以让方法在内部创建error后传出。</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近在Debug代码的时候，注释掉了一个带有二级指针参数的方法内部所有代码，然后在Release环境下安装运行，结果居然Crash了，猛然想起好像以前同事也遇到过，仔细检查了下，感觉代码是没有问题的，所以继续深究，新建了一个空的工程，重现了这个EXC_BAD_ACCESS的Crash，代码非常简单，如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;CoreFoundation/CoreFoundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestClass</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestClass</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)runTest &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    [TestClass testFunc:&amp;array];</span><br><span class="line">    [TestClass testFunc:&amp;array];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"array: %@"</span>, array);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)testFunc:(<span class="built_in">NSMutableArray</span> **)array &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [TestClass runTest];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经测试，在Xcode 8.0、以及最新的8.2.1稳定版下，Release环境中，都会Crash，放到iOS工程里面，模拟器、真机也会。但是，在Xcode7下就没有问题。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>首先，从代码本身上来看，是没有问题的，带有二级指针的方法<code>testFunc:</code>是空的方法，虽然传进来了<code>NSMutableArray **array</code>，但是没有对其赋值。</p><p><code>runTest</code>方法也只是创建了一个<code>NSMutableArray</code>对象，然后取了指针的指针，调用了两次<code>testFunc:</code>，然后打印，按理来说是没有任何副作用的。</p><p>所以，直接从代码上看，发现不了问题的原因。</p><h3 id="clang-rewrite-objc分析"><a href="#clang-rewrite-objc分析" class="headerlink" title="clang -rewrite-objc分析"></a>clang -rewrite-objc分析</h3><p>直接看代码没有用，那就用clang重写出C++代码分析，命令行对<code>main.m</code>执行<code>clang -rewrite-objc main.m</code>，得到C++重写后的代码，在文件的最后，就能找到<code>testFunc:</code>和<code>runTest</code>的C++代码，如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runTest的C++代码</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _C_TestClass_runTest(Class <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *array = ((<span class="built_in">NSMutableArray</span> *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"NSMutableArray"</span>), sel_registerName(<span class="string">"new"</span>));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">NSMutableArray</span> **))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"TestClass"</span>), sel_registerName(<span class="string">"testFunc:"</span>), &amp;array);</span><br><span class="line">    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">NSMutableArray</span> **))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"TestClass"</span>), sel_registerName(<span class="string">"testFunc:"</span>), &amp;array);</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders__5_6lqsnn195jj6pw61j66npcnm0000gn_T_main_5a7341_mi_0, array);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// testFunc:的C++代码</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _C_TestClass_testFunc_(Class <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSMutableArray</span> **array) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从C++代码来看，也没有可能会导致EXC_BAD_ACCESS问题的释放、dealloc之类的代码，继续！</p><h3 id="Hopper-Disassembler反编译分析"><a href="#Hopper-Disassembler反编译分析" class="headerlink" title="Hopper Disassembler反编译分析"></a>Hopper Disassembler反编译分析</h3><p>重写出C++代码无法解决，就只能让Hopper出马了，毕竟“汇编面前，没有秘密”=。=，以x86_64架构二进制为例。</p><p>先来看<code>testFunc:</code>的：</p><p><img src="/2017/03/14/xcode8-crash-on-out-parameter/xcode8_crash_on_out_parameter_1.jpg" alt=""></p><p>跟预想的一致，没有任何“有效代码”。</p><p>再看<code>runTest</code>方法：</p><p><img src="/2017/03/14/xcode8-crash-on-out-parameter/xcode8_crash_on_out_parameter_2.jpg" alt=""></p><p>为了方便分析，把反编译出来的汇编代码分了段：</p><ol><li>调用<code>NSMutableArray new</code>创建array变量，保存在r15寄存器上</li><li>第一次调用<code>testFunc:</code></li><li>先<code>retain</code>，然后<code>release</code>，rbx保存array，r15释放</li><li>第二次调用<code>testFunc:</code></li><li><strong>先<code>release</code>，再<code>retain</code>，即释放了rbx，然后又retain，这里明显有问题</strong></li><li>调用<code>NSlog</code>打印</li><li>最后release释放array变量</li></ol><p>为了进一步验证，用Hopper的反汇编生成Objective-C代码功能进行验证，生成的代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Xcode8 Release环境编译的x86_64二进制反编译后生成的代码</span></span><br><span class="line"><span class="keyword">void</span> +[TestClass runTest](<span class="keyword">void</span> * <span class="keyword">self</span>, <span class="keyword">void</span> * _cmd) &#123;</span><br><span class="line">    <span class="comment">// 创建</span></span><br><span class="line">    r15 = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    <span class="comment">// 第一次testFunc:</span></span><br><span class="line">    [TestClass testFunc:r15];</span><br><span class="line">    <span class="comment">// retain然后release</span></span><br><span class="line">    rbx = [r15 <span class="keyword">retain</span>];</span><br><span class="line">    [r15 release];</span><br><span class="line">    <span class="comment">// 第二次testFunc:</span></span><br><span class="line">    [TestClass testFunc:rbx];</span><br><span class="line">    <span class="comment">// 先release !!!</span></span><br><span class="line">    [rbx release];</span><br><span class="line">    <span class="comment">// 然后retain</span></span><br><span class="line">    rbx = [rbx <span class="keyword">retain</span>];</span><br><span class="line">    <span class="comment">// NSLog打印</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"array: %@"</span>, rbx);</span><br><span class="line">    <span class="comment">// 释放</span></span><br><span class="line">    [rbx release];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>release和retain的顺序错误</strong><br>Hopper生成的代码跟汇编分析基本一致，至此，可以看出，唯一“不正常”的代码就是第5段的<strong>“先release，再retain”</strong>，这会导致array变量提前释放，以至于后面再次retain无效，NSLog的时候，出现访问已被释放的变量，于是出现EXC_BAD_ACCESS崩溃。</p><h3 id="对比Xcode7"><a href="#对比Xcode7" class="headerlink" title="对比Xcode7"></a>对比Xcode7</h3><p>现在已经基本可以确定问题了，但是为什么Xcode7就不会Crash？反编译一探究竟。</p><p>相同的代码，Xcode7 Release环境编译出可执行二进制文件，反编译后，用Hopper生成Objective-C代码，然后跟Xcode8的做对比，如下：</p><p><img src="/2017/03/14/xcode8-crash-on-out-parameter/xcode8_crash_on_out_parameter_3.jpg" alt=""></p><p>可以看出，Xcode8编译后，release和retain的顺序错了，导致了array变量提前被释放，继而EXC_BAD_ACCESS错误。而Xcode7编译的一切正常。</p><h2 id="问题原因小结"><a href="#问题原因小结" class="headerlink" title="问题原因小结"></a>问题原因小结</h2><p>现在可以大胆猜测，EXC_BAD_ACCESS的原因就是<strong>Xcode8的编译错误</strong>。<br>在编译上面的代码时，Xcode8不能正确的处理array变量作为二级指针传入testFunc空函数后的<strong>release、retain顺序</strong>，导致array被<strong>提前释放</strong>，最终产生EXC_BAD_ACCESS错误。  </p><p>目前已经给Xcode提了Bug report，等待苹果的回复～</p><p>所有的代码、Xcode7和8编译出的二进制可执行文件、Hopper的文件，打包放在了Github上：<a href="https://github.com/zekunyan/OutParameterPointerCrashOnXcode8" target="_blank" rel="noopener">https://github.com/zekunyan/OutParameterPointerCrashOnXcode8</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>汇编面前，没有秘密！=。=</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;更新&quot;&gt;&lt;a href=&quot;#更新&quot; class=&quot;headerlink&quot; title=&quot;更新&quot;&gt;&lt;/a&gt;更新&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在最新的Xcode 9 Beta版本中，此Bug已被苹果修复：&lt;strong&gt;Bug ID 30530580: Crash on “Release” Build Configuration scheme setting for Out Parameters code&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;二级指针&quot;&gt;&lt;a href=&quot;#二级指针&quot; class=&quot;headerlink&quot; title=&quot;二级指针&quot;&gt;&lt;/a&gt;二级指针&lt;/h2&gt;&lt;p&gt;二级指针，也叫指针的指针，或者Out Parameters，可以用来改变一个指针的地址值，由于在Objective-C里面方法、函数不支持返回多个值，所以经常用二级指针实现这个功能，比如&lt;code&gt;NSFileManager&lt;/code&gt;的&lt;code&gt;- (BOOL)removeItemAtURL:(NSURL *)URL error:(NSError **)error&lt;/code&gt;方法，就可以让方法在内部创建error后传出。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>有趣的Autolayout示例5-Masonry实现</title>
    <link href="http://tutuge.me/2017/03/12/autolayout-example-with-masonry5/"/>
    <id>http://tutuge.me/2017/03/12/autolayout-example-with-masonry5/</id>
    <published>2017-03-12T13:41:17.000Z</published>
    <updated>2018-10-07T17:37:29.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第五篇来了！<br>还是3个小例子，仍然是主要部分用Masonry手写代码实现，其它的约束在storyboard里面直接拖拽搭建。三个例子分别是：  </p><ol><li>UITableViewCell中多个变高的Label</li><li>StairView自定义View的<code>intrinsicContentSize</code>，并支持在UITableViewCell中自动计算高度</li><li>给同一个属性添加<strong>多重约束</strong>，实现复杂关系</li></ol><p><img src="/2017/03/12/autolayout-example-with-masonry5/blog_autolayout_example_with_masonry5_1.png" alt=""></p><p>前四篇：  </p><ul><li>第一篇：<a href="http://tutuge.me/2015/05/23/autolayout-example-with-masonry/">有趣的Autolayout示例-Masonry实现</a>  </li><li>第二篇：<a href="http://tutuge.me/2015/08/08/autolayout-example-with-masonry2/">有趣的Autolayout示例2-Masonry实现</a>  </li><li>第三篇：<a href="http://tutuge.me/2015/12/14/autolayout-example-with-masonry3/">有趣的Autolayout示例3-Masonry实现</a></li><li>第四篇：<a href="http://tutuge.me/2016/08/06/autolayout-example-with-masonry4/">有趣的Autolayout示例4-Masonry实现</a></li></ul><p>Github地址：<br><a href="https://github.com/zekunyan/AutolayoutExampleWithMasonry" target="_blank" rel="noopener">https://github.com/zekunyan/AutolayoutExampleWithMasonry</a></p><a id="more"></a><h2 id="Case1-UITableViewCell中多个变高的Label"><a href="#Case1-UITableViewCell中多个变高的Label" class="headerlink" title="Case1: UITableViewCell中多个变高的Label"></a>Case1: UITableViewCell中多个变高的Label</h2><h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><p>功能就是Cell整体变高，内部水平三个Label，宽度一样，高度由内容决定。</p><p>在本例子中，Label的宽度定为80，避免多行Label的<code>preferredMaxLayoutWidth</code>的设置干扰。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>原理一句话就是：Cell的高度由三个Label中最高的得出。</p><p>但是，实际设置Autolayout的时候，不存在什么<code>cell.height = MAX(labels.height)</code>这样的关系。</p><p>所以要转换一下，改为<strong><code>ANY(label.bottom) &lt;= cell.bottom</code></strong>，即<strong>每个Label的底部bottom都是在cell的底部bottom上面的</strong>，换算到坐标系里面，就是在Y轴上，<strong><code>label.bottom &lt;= cell.bottom</code></strong>。</p><p>所以，cell的约束如下图所示：</p><p><img src="/2017/03/12/autolayout-example-with-masonry5/blog_autolayout_example_with_masonry5_2.png" alt=""></p><h3 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h3><p>对应的代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setupLayout &#123;</span><br><span class="line">    <span class="comment">// label1的约束    </span></span><br><span class="line">    [_label1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.width.equalTo(@<span class="number">80</span>); <span class="comment">// 宽度80</span></span><br><span class="line">        make.top.equalTo(<span class="keyword">self</span>.contentView.mas_topMargin); <span class="comment">// 上</span></span><br><span class="line">        make.left.equalTo(<span class="keyword">self</span>.contentView.mas_leftMargin); <span class="comment">// 左</span></span><br><span class="line">        <span class="comment">// label.bottom &lt;= cell.contentView.bottom，注意是在Y轴上对比</span></span><br><span class="line">        make.bottom.lessThanOrEqualTo(<span class="keyword">self</span>.contentView.mas_bottomMargin); </span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// label2的约束 </span></span><br><span class="line">    <span class="comment">// 类似...</span></span><br><span class="line">    <span class="comment">// label3的约束 </span></span><br><span class="line">    <span class="comment">// 类似...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Case2-StairView自定义View实现intrinsicContentSize"><a href="#Case2-StairView自定义View实现intrinsicContentSize" class="headerlink" title="Case2: StairView自定义View实现intrinsicContentSize"></a>Case2: StairView自定义View实现<code>intrinsicContentSize</code></h2><h3 id="实现功能-1"><a href="#实现功能-1" class="headerlink" title="实现功能"></a>实现功能</h3><p>实现一个自定义布局的View - StairView，阶梯布局View。<br>StairView支持设置Label成阶梯状从上到下、从左到右分布，如下图：</p><p><img src="/2017/03/12/autolayout-example-with-masonry5/blog_autolayout_example_with_masonry5_3.jpg" alt=""></p><p>同时，StairView要支持Autolayout，支持大小由内容决定，可以在Cell里面用，并自动计算高度。</p><p>接下来，看看如何实现这个StairView。</p><h3 id="intrinsicContentSize是什么"><a href="#intrinsicContentSize是什么" class="headerlink" title="intrinsicContentSize是什么"></a>intrinsicContentSize是什么</h3><p>如果说到Autolayout的内容决定大小，就会遇到<code>intrinsicContentSize</code>方法，这个方法是什么呢？</p><p>intrinsic单词的意思：</p><blockquote><p>adj.固有的，内在的，本质的； [解剖]体内的； 本征； 先天性</p></blockquote><p>而<code>intrinsicContentSize</code>方法的官方解释是：</p><blockquote><p>Returns the natural size for the receiving view, considering only properties of the view itself.</p></blockquote><p>所以，UIView的<code>intrinsicContentSize</code>，就是获取这个View的<strong>固有的，内在的，本质的</strong>的<strong>内容大小</strong>。</p><p>在看Discussion部分：</p><blockquote><p>Custom views typically have content that they display of which the layout system is unaware. Overriding this method allows a custom view to communicate to the layout system what size it would like to be based on its content. This intrinsic size must be independent of the content frame, because there’s no way to dynamically communicate a changed width to the layout system based on a changed height, for example.</p></blockquote><p>比较长，简单说，就是Autolayout布局系统是不知道自定义View的内容大小的，所以自定义View可以重写这个方法，返回自己的<strong>内容大小</strong>，交由Autolayout布局系统去计算布局。并且，这个大小是不能依赖外部的大小的。</p><p>所以，如果我们的View的大小是固定的时候，最简单，直接返回即可：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGSize</span>)intrinsicContentSize &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGSizeMake</span>(<span class="number">100</span>, <span class="number">100</span>); <span class="comment">// 固定100x100大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果大小需要计算，就要先计算，然后返回：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGSize</span>)intrinsicContentSize &#123;</span><br><span class="line">    <span class="comment">// 先计算内容大小，可以按情况缓存，减少计算量</span></span><br><span class="line">    <span class="built_in">CGSize</span> contentSize = [<span class="keyword">self</span> calculateContentSize];</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> contentSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了<code>intrinsicContentSize</code>的返回大小，Autolayout的布局系统才能正确的布局。</p><h3 id="StairView的实现"><a href="#StairView的实现" class="headerlink" title="StairView的实现"></a>StairView的实现</h3><p>清楚了<code>intrinsicContentSize</code>的作用以后，就可以着手实现StairView了。</p><h4 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h4><p>为了尽量简单，StairView的方法只有一个：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  设置阶梯title</span></span><br><span class="line"><span class="comment"> *  @param titles 标题数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setStairTitles:(<span class="built_in">NSArray</span> &lt;<span class="built_in">NSString</span> *&gt; *)titles;</span><br></pre></td></tr></table></figure><p>直接传入字符串数组即可。</p><h4 id="内部属性"><a href="#内部属性" class="headerlink" title="内部属性"></a>内部属性</h4><p>StairView内部由UILabel组成实现，所以需要一个数组保存所有的Label，还要一个CGSize类型的变量，保存当前的内容大小：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">StairView</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> &lt;<span class="built_in">UILabel</span> *&gt; *itemViews; <span class="comment">// Label数组</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGSize</span> contentSize; <span class="comment">// 内容大小，随时更新</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="设置阶梯标题-setStairTitles-的实现"><a href="#设置阶梯标题-setStairTitles-的实现" class="headerlink" title="设置阶梯标题: setStairTitles:的实现"></a>设置阶梯标题: setStairTitles:的实现</h4><p>接着就是实现<code>setStairTitles:</code>方法。<br>基本逻辑就是: <code>删除旧的Label-&gt;循环创建新的Label-&gt;重新布局</code>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setStairTitles:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)titles &#123;</span><br><span class="line">    <span class="comment">// 批量从superView删除旧的Label</span></span><br><span class="line">    [_itemViews makeObjectsPerformSelector:<span class="keyword">@selector</span>(removeFromSuperview)];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新创建</span></span><br><span class="line">    _itemViews = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环创建新的Label</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *title <span class="keyword">in</span> titles) &#123;</span><br><span class="line">        <span class="built_in">UILabel</span> *label = [<span class="built_in">UILabel</span> new];</span><br><span class="line">        <span class="comment">// 设置样式</span></span><br><span class="line">        label.text = title;</span><br><span class="line">        label.font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">12</span>];</span><br><span class="line">        label.layer.borderColor = [<span class="built_in">UIColor</span> lightGrayColor].CGColor;</span><br><span class="line">        label.layer.borderWidth = <span class="number">1.0</span>f / [<span class="built_in">UIScreen</span> mainScreen].scale;</span><br><span class="line">        label.numberOfLines = <span class="number">0</span>;</span><br><span class="line">        [<span class="keyword">self</span> addSubview:label];</span><br><span class="line">        <span class="comment">// 添加Label</span></span><br><span class="line">        [_itemViews addObject:label];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新布局</span></span><br><span class="line">    _contentSize = <span class="built_in">CGSizeZero</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重点！</span></span><br><span class="line">    [<span class="keyword">self</span> updateStairLayout];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内部阶梯Label的布局-intrinsicContentSize的计算-updateStairLayout的实现"><a href="#内部阶梯Label的布局-intrinsicContentSize的计算-updateStairLayout的实现" class="headerlink" title="内部阶梯Label的布局+intrinsicContentSize的计算: updateStairLayout的实现"></a>内部阶梯Label的布局+intrinsicContentSize的计算: updateStairLayout的实现</h4><p>从上面的设置代码可看出，重点是对内部Label布局的<code>updateStairLayout</code>方法，按照前面所说的功能要求，基本的原理就是:<br><code>根据当前阶梯数量计算每个Label的平均width-&gt;遍历所有Label计算当前width下的高度-&gt;设置每个Label的frame-&gt;更新contentSize</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)updateStairLayout &#123;</span><br><span class="line">    <span class="keyword">if</span> (_itemViews.count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有设置内容，内容大小为零</span></span><br><span class="line">        _contentSize = <span class="built_in">CGSizeZero</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算每个Label的平均宽度</span></span><br><span class="line">    <span class="built_in">CGFloat</span> eachLabelWidth = <span class="built_in">CGRectGetWidth</span>(<span class="keyword">self</span>.bounds) / (<span class="built_in">CGFloat</span>)_itemViews.count;</span><br><span class="line">    <span class="built_in">CGFloat</span> lastY = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> lastX = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UILabel</span> *label <span class="keyword">in</span> _itemViews) &#123;</span><br><span class="line">        <span class="comment">// 根据内容、当前width计算高度</span></span><br><span class="line">        label.preferredMaxLayoutWidth = eachLabelWidth;</span><br><span class="line">        <span class="built_in">CGFloat</span> height = [label sizeThatFits:<span class="built_in">CGSizeMake</span>(eachLabelWidth, <span class="number">0</span>)].height;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置frame</span></span><br><span class="line">        <span class="built_in">CGRect</span> frame = <span class="built_in">CGRectMake</span>(lastX, lastY, eachLabelWidth, height);</span><br><span class="line">        label.frame = frame;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新下一轮</span></span><br><span class="line">        lastX += eachLabelWidth;</span><br><span class="line">        lastY += height;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新contentSize</span></span><br><span class="line">    <span class="built_in">CGSize</span> newContentSize = <span class="built_in">CGSizeMake</span>(<span class="built_in">CGRectGetWidth</span>(<span class="keyword">self</span>.bounds), lastY);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断内容大小是否有变化</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CGSizeEqualToSize</span>(newContentSize, _contentSize)) &#123;</span><br><span class="line">        <span class="comment">// 更新contentSize</span></span><br><span class="line">        _contentSize = newContentSize;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知外部IntrinsicContentSize失效</span></span><br><span class="line">        [<span class="keyword">self</span> invalidateIntrinsicContentSize];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>要先判断设置的阶梯title数量是否为零，否则计算平均宽度时会导致除数为零的Crash</li><li>每个Label的高度，根据当前的平均宽度，用<code>sizeThatFits:</code>计算得出</li><li>最后更新<code>_contentSize</code>的值</li><li>重点！<code>[self invalidateIntrinsicContentSize]</code>通知外界，StairView的内容大小发生变化</li></ul><p>计算内部Label布局的原理还是很简单的，重点就是最后的更新<code>_contentSize</code>和调用<code>[self invalidateIntrinsicContentSize]</code>。</p><h4 id="通知外界内容大小发生变化-invalidateIntrinsicContentSize方法"><a href="#通知外界内容大小发生变化-invalidateIntrinsicContentSize方法" class="headerlink" title="通知外界内容大小发生变化-invalidateIntrinsicContentSize方法"></a>通知外界内容大小发生变化-invalidateIntrinsicContentSize方法</h4><p>先看看官方文档的解释：</p><blockquote><p>Call this when something changes in your custom view that invalidates its intrinsic content size. This allows the constraint-based layout system to take the new intrinsic content size into account in its next layout pass.</p></blockquote><p>意思就是，当自定义View的内容大小发生变化时，调用此方法通知布局系统，在下一次布局更新中刷新。</p><p>所以，对照上面的代码:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断内容大小是否有变化</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">CGSizeEqualToSize</span>(newContentSize, _contentSize)) &#123;</span><br><span class="line">    <span class="comment">// 更新contentSize</span></span><br><span class="line">    _contentSize = newContentSize;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知外部IntrinsicContentSize失效</span></span><br><span class="line">    [<span class="keyword">self</span> invalidateIntrinsicContentSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就很明显了，就是按照文档的说明做的。</p><h4 id="关键：何时调用updateStairLayout更新布局、刷新contentSize"><a href="#关键：何时调用updateStairLayout更新布局、刷新contentSize" class="headerlink" title="关键：何时调用updateStairLayout更新布局、刷新contentSize"></a>关键：何时调用updateStairLayout更新布局、刷新contentSize</h4><p>有了<code>updateStairLayout</code>方法来布局、计算contentSize，也用了<code>invalidateIntrinsicContentSize</code>通知系统刷新，那么剩下来的关键就是<strong>何时何地调用更新布局、contentSize</strong></p><p><strong>在<code>layoutSubviews</code>的时候</strong><br>这里很明显，<code>layoutSubviews</code>就是刷新自定义view的地方，系统会在布局的过程中，多次调用，如frame改变。</p><p><strong>在<code>intrinsicContentSize</code>的时候</strong><br>这里比较容易忽视，有时候，系统调用<code>intrinsicContentSize</code>方法的时候，可能在自定义View的布局之前，所以这个时候要“强制”刷新布局、计算出当前状态下正确的contentSize</p><p>所以，有两处地方要加上：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGSize</span>)intrinsicContentSize &#123;</span><br><span class="line">    [<span class="keyword">self</span> updateStairLayout];</span><br><span class="line">    <span class="keyword">return</span> _contentSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)layoutSubviews &#123;</span><br><span class="line">    [<span class="keyword">super</span> layoutSubviews];</span><br><span class="line">    [<span class="keyword">self</span> updateStairLayout];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义View小结"><a href="#自定义View小结" class="headerlink" title="自定义View小结"></a>自定义View小结</h3><p>StairView的原理、代码都讲完了，算是一个典型的自定义的、根据内容决定高度的View案例，主要要注意的就是<strong>更新布局、contentSize的时机</strong>，以及<strong>及时invalidateIntrinsicContentSize通知布局系统更新</strong></p><h2 id="Case3-给同一个属性添加多重约束，实现复杂关系"><a href="#Case3-给同一个属性添加多重约束，实现复杂关系" class="headerlink" title="Case3: 给同一个属性添加多重约束，实现复杂关系"></a>Case3: 给同一个属性添加<strong>多重约束</strong>，实现复杂关系</h2><p>这个Case主要是为了纠正一个可能的误区：<strong>Autolayout里面，同一个属性，是可以加上多重约束的</strong>，或者说，同一个View的同一个属性，可以参与到多个约束里面的。</p><p>先看看Case的功能：</p><p><img src="/2017/03/12/autolayout-example-with-masonry5/blog_autolayout_example_with_masonry5_4.jpg" alt=""></p><p>注意到，右边绿色label的左边，不仅要大于左边蓝色label的右边，还要大于整体宽度的1/3，所以，是要<strong>同时满足多条约束条件的</strong>。</p><h3 id="区分观念：Frame布局和Autolayout的不同"><a href="#区分观念：Frame布局和Autolayout的不同" class="headerlink" title="区分观念：Frame布局和Autolayout的不同"></a>区分观念：Frame布局和Autolayout的不同</h3><p><strong>按照Frame布局</strong></p><p>按照传统的用Frame布局的方式，label的左边，其实就是<code>label.frame.origin.x</code>这个属性，所以，要左边满足条件的话，首先想到的可能就是：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 满足大于蓝色<span class="built_in">label</span>的右边</span><br><span class="line"><span class="built_in">label</span>.frame.<span class="built_in">origin</span>.x &gt; blueLabel1.frame.<span class="built_in">origin</span>.x + blueLabel1.frame.size.<span class="built_in">width</span>;</span><br><span class="line"><span class="built_in">label</span>.frame.<span class="built_in">origin</span>.x &gt; blueLabel2.frame.<span class="built_in">origin</span>.x + blueLabel2.frame.size.<span class="built_in">width</span>;</span><br><span class="line"><span class="built_in">label</span>.frame.<span class="built_in">origin</span>.x &gt; blueLabel3.frame.<span class="built_in">origin</span>.x + blueLabel3.frame.size.<span class="built_in">width</span>;</span><br><span class="line">// 满足大于整体的<span class="number">1</span>/<span class="number">3</span></span><br><span class="line"><span class="built_in">label</span>.frame.<span class="built_in">origin</span>.x &gt; (superView.frame.<span class="built_in">origin</span>.x + superView.frame.size.<span class="built_in">width</span>) / <span class="number">3</span></span><br></pre></td></tr></table></figure><p>这，乍一看，就是不停的在<code>layoutSubView</code>的时候做判断、处理。</p><p><strong>按照Autolayout布局</strong></p><p>而Autolayout是什么，是<strong>约束</strong>，是一种布局关系，只是对具体View的相关属性的一种关系设置，我们设置了约束，系统就会在需要的时候，按照约束，计算出每个View的frame，自动更新。</p><p>所以，同一个属性，完全是可以加多个约束条件的。</p><h3 id="代码细节-1"><a href="#代码细节-1" class="headerlink" title="代码细节"></a>代码细节</h3><p>一旦没有了一个属性一个约束的<strong>观念限制</strong>，这个Case的功能就很好实现了，关键代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建绿色label</span></span><br><span class="line">_greenLabel = [<span class="built_in">UILabel</span> new];</span><br><span class="line">[_containerView addSubview:_greenLabel];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置内容抗压优先级最高</span></span><br><span class="line">[_greenLabel setContentCompressionResistancePriority:<span class="built_in">UILayoutPriorityRequired</span> forAxis:<span class="built_in">UILayoutConstraintAxisHorizontal</span>];</span><br><span class="line"></span><br><span class="line">[_greenLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    <span class="comment">// 垂直居中</span></span><br><span class="line">    make.centerY.equalTo(_containerView);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 右边不超出</span></span><br><span class="line">    make.right.lessThanOrEqualTo(_containerView);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 左边大于等于父View宽度的1/3，注意不是width属性</span></span><br><span class="line">    make.left.greaterThanOrEqualTo(_containerView.mas_right).multipliedBy((<span class="built_in">CGFloat</span>)(<span class="number">1.0</span>f / <span class="number">3.0</span>f));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环，左边大于所有左边label的右边+8</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UILabel</span> *label <span class="keyword">in</span> _leftLabels) &#123;</span><br><span class="line">        make.left.greaterThanOrEqualTo(label.mas_right).offset(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>只要约束没有冲突，我们设置的约束，就可以在各种情况下，按照需要生效。<br>对于这种内容动态变化，View之间关系复杂的情况，用Autolayout就非常有效了。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这个系列居然已经出到了第五篇了，自己都觉得不可思议=。=<br>所有的例子都是日常工作中遇到、想到的，觉得算是一个点，就把它记录了下来，以后会一直坚持下去～</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;第五篇来了！&lt;br&gt;还是3个小例子，仍然是主要部分用Masonry手写代码实现，其它的约束在storyboard里面直接拖拽搭建。三个例子分别是：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;UITableViewCell中多个变高的Label&lt;/li&gt;
&lt;li&gt;StairView自定义View的&lt;code&gt;intrinsicContentSize&lt;/code&gt;，并支持在UITableViewCell中自动计算高度&lt;/li&gt;
&lt;li&gt;给同一个属性添加&lt;strong&gt;多重约束&lt;/strong&gt;，实现复杂关系&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/2017/03/12/autolayout-example-with-masonry5/blog_autolayout_example_with_masonry5_1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;前四篇：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一篇：&lt;a href=&quot;http://tutuge.me/2015/05/23/autolayout-example-with-masonry/&quot;&gt;有趣的Autolayout示例-Masonry实现&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;第二篇：&lt;a href=&quot;http://tutuge.me/2015/08/08/autolayout-example-with-masonry2/&quot;&gt;有趣的Autolayout示例2-Masonry实现&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;第三篇：&lt;a href=&quot;http://tutuge.me/2015/12/14/autolayout-example-with-masonry3/&quot;&gt;有趣的Autolayout示例3-Masonry实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;第四篇：&lt;a href=&quot;http://tutuge.me/2016/08/06/autolayout-example-with-masonry4/&quot;&gt;有趣的Autolayout示例4-Masonry实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Github地址：&lt;br&gt;&lt;a href=&quot;https://github.com/zekunyan/AutolayoutExampleWithMasonry&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/zekunyan/AutolayoutExampleWithMasonry&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="Autolayout" scheme="http://tutuge.me/tags/Autolayout/"/>
    
      <category term="Masonry" scheme="http://tutuge.me/tags/Masonry/"/>
    
  </entry>
  
  <entry>
    <title>在对象dealloc的后期执行Task-开源库TTGDeallocTaskHelper</title>
    <link href="http://tutuge.me/2017/03/11/TTGDeallocTaskHelper/"/>
    <id>http://tutuge.me/2017/03/11/TTGDeallocTaskHelper/</id>
    <published>2017-03-11T03:11:11.000Z</published>
    <updated>2018-10-07T17:37:29.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近更新了下以前写的TTGDeallocTaskHelper库，功能非常简单，就是<strong>在不改变原有代码的情况下，不用Runtime的Method Swizzling给任意对象添加任务Block，在对象dealloc的后期执行Block。</strong>使用时：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给object对象添加dealloc后期要执行的任务Block</span></span><br><span class="line">[object ttg_addDeallocTask:^(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> target, <span class="built_in">NSUInteger</span> identifier) &#123;</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>Github地址：<a href="https://github.com/zekunyan/TTGDeallocTaskHelper/" target="_blank" rel="noopener">https://github.com/zekunyan/TTGDeallocTaskHelper</a></p><p>一张图说明原理：</p><p><img src="/2017/03/11/TTGDeallocTaskHelper/TTGDeallocTaskHelper_1.jpg" alt="总体结构"></p><p>库的详细原理、限制、注意事项，为什么说“<strong>后期</strong>”执行，将在下文给出。</p><a id="more"></a><h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><p>先给出几个使用案例。</p><h3 id="删除Notification监听"><a href="#删除Notification监听" class="headerlink" title="删除Notification监听"></a>删除Notification监听</h3><p>比如你给一个第三方类对象添加了Notification通知，要在对象release后删除Notification的监听，就可以：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[object ttg_addDeallocTask:^(__<span class="keyword">unsafe_unretained</span> SomeClass *object, <span class="built_in">NSUInteger</span> identifier) &#123;</span><br><span class="line"><span class="comment">// 删除Notification监听</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:object];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="快速Debug内存泄漏"><a href="#快速Debug内存泄漏" class="headerlink" title="快速Debug内存泄漏"></a>快速Debug内存泄漏</h3><p>有时你想快速验证一下一个类有没有释放，存不存在内存泄漏，比如一个ViewController返回后，就可以这么做：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[someViewController ttg_addDeallocTask:^(__<span class="keyword">unsafe_unretained</span> <span class="built_in">UIViewController</span> *controller, <span class="built_in">NSUInteger</span> identifier) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"我正常释放了！哈哈哈！"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="事件打点"><a href="#事件打点" class="headerlink" title="事件打点"></a>事件打点</h3><p>业务开发中，想监听某个事件什么时候销毁，就可以：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[someEvent ttg_addDeallocTask:^(__<span class="keyword">unsafe_unretained</span> SomeEvent *event, <span class="built_in">NSUInteger</span> identifier) &#123;</span><br><span class="line">    <span class="comment">// 打点。。。</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>是不是很方便！没有对原有的代码做任何侵入。<br>接下来看看实现原理。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="在对象dealloc的时候做操作的四种办法"><a href="#在对象dealloc的时候做操作的四种办法" class="headerlink" title="在对象dealloc的时候做操作的四种办法"></a>在对象dealloc的时候做操作的四种办法</h3><p>在对象dealloc的时候做操作，有好几种方法：</p><ul><li><strong>继承</strong>：这个应该是最“正常”的方法了，继承对应的类，在子类中实现<code>dealloc</code>方法，执行相关的任务。缺点是要修改用到类的地方为自己定义的子类</li><li><strong>Method Swizzling</strong>：方法交换，直接自己定义新的dealloc方法实现，实现任务的调用。但是坏处是所有的对象都会被替换，侵入性太大</li><li><strong>ISA Swizzling</strong>：动态的生成对象的子类，在子类继承方法，实现调用任务，然后设置对象的isa指针，使其指向子类。这种方法的好处是只会影响到单个对象，但是系统KVO也是用这个方法，重复设置isa的话，会有问题。</li><li><strong>利用Associated Object</strong>：Associated Object会在对象释放时自动释放，所以可以用来“挂载”要执行的任务。</li></ul><p>对比了上面的四种方法后，选定用Associated Object的方式实现TTGDeallocTaskHelper。</p><h3 id="用Associated-Object挂载任务"><a href="#用Associated-Object挂载任务" class="headerlink" title="用Associated Object挂载任务"></a>用Associated Object挂载任务</h3><p>总的思路是：</p><ol><li>给对象添加Associated Object</li><li>在Associated Object里面保存要执行的任务Block</li><li>实现Associated Object的<code>dealloc</code>方法，在Associated Object释放的时候，批量执行之前添加的Block</li></ol><p>图示如下：</p><p><img src="/2017/03/11/TTGDeallocTaskHelper/TTGDeallocTaskHelper_1.jpg" alt="总体结构"></p><h3 id="Associated-Object-TaskModel"><a href="#Associated-Object-TaskModel" class="headerlink" title="Associated Object - TaskModel"></a>Associated Object - TaskModel</h3><p><strong>属性</strong></p><p>上图中的TaskModel，就是库代码里面的<code>TTGDeallocTaskModel</code>类，包含三个属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) pthread_mutex_t lock;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *tasksDict;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">unsafe_unretained</span>) <span class="keyword">id</span> target;</span><br></pre></td></tr></table></figure><ul><li><code>tasksDict</code>保存要执行的任务Block</li><li><code>lock</code>锁用来保证多线程下操作<code>tasksDict</code>的安全性</li><li><code>target</code>指向的是原对象，是<code>unsafe_unretained</code>的，保证始终不为nil，所以也建议不要在任务Block里面调用target的方法</li></ul><h3 id="添加任务Block"><a href="#添加任务Block" class="headerlink" title="添加任务Block"></a>添加任务Block</h3><p><code>TTGDeallocTaskModel</code>的<code>tasksDict</code>就是用来保存要执行的任务Block的，为了能在添加了以后删除，所以要以Key-Value的形式保存。<br>Key的类型是NSUInteger，全局自增，保证唯一。</p><h4 id="OSAtomicIncrement64实现线程安全的自增整型Key-identifier"><a href="#OSAtomicIncrement64实现线程安全的自增整型Key-identifier" class="headerlink" title="OSAtomicIncrement64实现线程安全的自增整型Key-identifier"></a>OSAtomicIncrement64实现线程安全的自增整型Key-identifier</h4><p>为了保证自增的Key的线程安全，同时平衡性能，所以此处用<code>OSAtomicIncrement64</code>实现原子整型数自增：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局静态变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> int64_t globalIdentifier = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 自增+1，生成新的Key</span></span><br><span class="line"><span class="built_in">NSUInteger</span> newIdentifier = (<span class="built_in">NSUInteger</span>)OSAtomicIncrement64(&amp;globalIdentifier);</span><br></pre></td></tr></table></figure><h4 id="pthread-mutex-t保证操作字典的线程安全"><a href="#pthread-mutex-t保证操作字典的线程安全" class="headerlink" title="pthread_mutex_t保证操作字典的线程安全"></a>pthread_mutex_t保证操作字典的线程安全</h4><p>为了保证NSMutableDictionary的多线程操作的安全，用pthread_mutex_t对添加Block的操作加锁：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;_lock);</span><br><span class="line">[_tasksDict setObject:[taskBlock <span class="keyword">copy</span>] forKey:newIdentifierNumber];</span><br><span class="line">pthread_mutex_unlock(&amp;_lock);</span><br></pre></td></tr></table></figure><h3 id="删除任务Block"><a href="#删除任务Block" class="headerlink" title="删除任务Block"></a>删除任务Block</h3><p>删除任务有两种，分别是删除一个identifier key对应的Block，和删除所有Block，同样，都要加锁保证线程安全：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;_lock);</span><br><span class="line"><span class="comment">// 删除某个identifier对应的Block</span></span><br><span class="line">[_tasksDict removeObjectForKey:identifierNumber];</span><br><span class="line"><span class="comment">// 或删除所有</span></span><br><span class="line">[_tasksDict removeAllObjects];</span><br><span class="line"><span class="comment">// 解除锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;_lock);</span><br></pre></td></tr></table></figure><h3 id="dealloc执行Block"><a href="#dealloc执行Block" class="headerlink" title="dealloc执行Block"></a>dealloc执行Block</h3><p>最终在TaskModel被释放的时候，要批量执行所有添加的Block：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="comment">// 批量执行Block</span></span><br><span class="line">    [_tasksDict enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSNumber</span> *identifier, TTGDeallocTaskBlock block, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        block(_target, identifier.unsignedIntegerValue);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 销毁锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="给NSObject添加Category"><a href="#给NSObject添加Category" class="headerlink" title="给NSObject添加Category"></a>给NSObject添加Category</h3><p>上面是TaskModel的部分，接下来是NSObject的。</p><p>给NSObject添加Categor <code>NSObject (TTGDeallocTaskHelper)</code>，保存<code>TTGDeallocTaskModel</code>，封装调用。</p><h4 id="封装-添加任务Block"><a href="#封装-添加任务Block" class="headerlink" title="封装-添加任务Block"></a>封装-添加任务Block</h4><p><strong>Associated Object给对象添加TaskModel属性</strong></p><p>用<code>objc_setAssociatedObject</code>实现给任意对象添加对应的TaskModel对象。</p><p><strong>@synchronized保证多线程下TaskModel的唯一性</strong></p><p>首次添加任务Block，会创建TaskModel，为了保证多线程下的唯一性，所以创建的部分要用<code>@synchronized</code>保护起来。</p><p>所以，添加任务Block的代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)ttg_addDeallocTask:(TTGDeallocTaskBlock)taskBlock &#123;</span><br><span class="line">    <span class="keyword">if</span> (!taskBlock) &#123;</span><br><span class="line">        <span class="comment">// block为空</span></span><br><span class="line">        <span class="keyword">return</span> TTGDeallocTaskIllegalIdentifier;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TTGDeallocTaskModel *model = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程安全</span></span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        model = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;TTGDeallocTaskModelKey);</span><br><span class="line">        <span class="keyword">if</span> (!model) &#123;</span><br><span class="line">            <span class="comment">// 创建</span></span><br><span class="line">            model = [[TTGDeallocTaskModel alloc] initWithTarget:<span class="keyword">self</span>];</span><br><span class="line">            <span class="comment">// 保存</span></span><br><span class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, &amp;TTGDeallocTaskModelKey, model, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加新的Block</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> newIdentifier = [model addTask:taskBlock];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newIdentifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="封装-删除Block"><a href="#封装-删除Block" class="headerlink" title="封装-删除Block"></a>封装-删除Block</h4><p>直接获取当前对象的TaskModel对象，调用相应的方法即可，不再贴代码。</p><h2 id="限制与注意事项"><a href="#限制与注意事项" class="headerlink" title="限制与注意事项"></a>限制与注意事项</h2><p>原理和实现说完了，接下来是库的限制与注意事项。</p><h3 id="NSObject对象的dealloc过程"><a href="#NSObject对象的dealloc过程" class="headerlink" title="NSObject对象的dealloc过程"></a>NSObject对象的dealloc过程</h3><p>先来看看Associated Object在<code>dealloc</code>的什么时候释放。</p><p>NSObject对象dealloc的具体细节，sunnyxx在他的<a href="http://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/" target="_blank" rel="noopener">《ARC下dealloc过程及.cxx_destruct的探究》</a>已经说的很清楚了。简单来说，就是对象dealloc的时候，最终会调用到<code>objc_destructInstance</code>方法上：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码：objc4-706 objc-class.mm</span></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* objc_destructInstance</span></span><br><span class="line"><span class="comment">* Destroys an instance without freeing memory. </span></span><br><span class="line"><span class="comment">* Calls C++ destructors.</span></span><br><span class="line"><span class="comment">* Removes associative references.</span></span><br><span class="line"><span class="comment">* Returns `obj`. Does nothing if `obj` is nil.</span></span><br><span class="line"><span class="comment">* CoreFoundation and other clients do call this under GC.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> *objc_destructInstance(<span class="keyword">id</span> obj) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        Class isa = obj-&gt;getIsa();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isa-&gt;hasCxxDtor()) &#123;</span><br><span class="line">            <span class="comment">// 1. 释放property</span></span><br><span class="line">            object_cxxDestruct(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isa-&gt;instancesHaveAssociatedObjects()) &#123;</span><br><span class="line">            <span class="comment">// 2. 删除对象的associated objects</span></span><br><span class="line">            _object_remove_assocations(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 设置所有指向此对象的weak指针为nil</span></span><br><span class="line">        objc_clear_deallocating(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是3步：</p><ol><li><code>object_cxxDestruct</code>释放对象的ivar、property</li><li><code>_object_remove_assocations</code>释放对象的Associated Object</li><li><code>objc_clear_deallocating</code>重置所有指向对象的weak指针为空</li></ol><h3 id="不建议在Block里面调用target原对象的方法"><a href="#不建议在Block里面调用target原对象的方法" class="headerlink" title="不建议在Block里面调用target原对象的方法"></a>不建议在Block里面调用target原对象的方法</h3><p>从dealloc的流程可知，Associated Object是在第二步被释放的，这个时候，原对象的属性已被release，并且，Associated Object对象自己的dealloc不一定在什么时候会被调用（比如加到了autorelease pool里面），所以，不建议在任务Block里面调用target原对象的方法。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>什么时候Associated Object的释放能在对象属性release之前就好了=。=</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近更新了下以前写的TTGDeallocTaskHelper库，功能非常简单，就是&lt;strong&gt;在不改变原有代码的情况下，不用Runtime的Method Swizzling给任意对象添加任务Block，在对象dealloc的后期执行Block。&lt;/strong&gt;使用时：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 给object对象添加dealloc后期要执行的任务Block&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[object ttg_addDeallocTask:^(__&lt;span class=&quot;keyword&quot;&gt;unsafe_unretained&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; target, &lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt; identifier) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 执行任务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Github地址：&lt;a href=&quot;https://github.com/zekunyan/TTGDeallocTaskHelper/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/zekunyan/TTGDeallocTaskHelper&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一张图说明原理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2017/03/11/TTGDeallocTaskHelper/TTGDeallocTaskHelper_1.jpg&quot; alt=&quot;总体结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;库的详细原理、限制、注意事项，为什么说“&lt;strong&gt;后期&lt;/strong&gt;”执行，将在下文给出。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="开源" scheme="http://tutuge.me/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>用QuartzCode快速实现一个收藏动画</title>
    <link href="http://tutuge.me/2017/03/08/quartzcode-demo-star-animation/"/>
    <id>http://tutuge.me/2017/03/08/quartzcode-demo-star-animation/</id>
    <published>2017-03-07T16:00:00.000Z</published>
    <updated>2018-10-07T17:37:29.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>“工欲善其事,必先利其器”，iOS的Core Animation非常强大，可以做出非常炫酷的动画，但是实际写起来还是比较麻烦，代码不直观，需要反复的改参数、Build、运行，所以诞生了各种动画制作工具，本文就以其中比较有名的<a href="http://www.quartzcodeapp.com/" target="_blank" rel="noopener">QuartzCode</a>为例，快速实现一个收藏功能的星星动画，最终的效果如下：</p><p><img src="/2017/03/08/quartzcode-demo-star-animation/quartzcode_demo_star_animation_1.gif" alt=""></p><p>GitHub地址：<a href="https://github.com/zekunyan/QuartzCodeExample-StarAimation" target="_blank" rel="noopener">https://github.com/zekunyan/QuartzCodeExample-StarAimation</a></p><a id="more"></a><h2 id="QuartzCode简介"><a href="#QuartzCode简介" class="headerlink" title="QuartzCode简介"></a>QuartzCode简介</h2><p>QuartzCode是一款专门用来创作iOS/macOS动画的软件，基本上把整个Core Animation框架的内容都搬到了软件里面，比如各种Layer、Mask、可以用来动画的属性，基本上跟代码是一致的，完全可以当成<strong>“可视化动画编程”</strong>工具，而且制作以后可以<strong>导出代码+资源文件</strong>，直接就可以在代码里面调用，方便自定义修改。</p><p>以QuartzCode 1.54.0为例，主体界面如下：</p><p><img src="/2017/03/08/quartzcode-demo-star-animation/quartzcode_demo_star_animation_2.jpg" alt=""></p><p>简单讲下：  </p><ul><li>A: Layers，用于动画的Layer在这里显示，先后顺序、层级和StoryBoard比较像</li><li>B: Inspector，当前选中元素，如Layer的属性编辑，基本和对应CALayer类的属性一一对应</li><li>C: Animations，动画组，可以有多个动画组，每个相互独立</li><li>D: Timeline，动画时间轴，每个Layer的动画都会在时间轴上标出</li><li>E: Keyframe inspector，动画关键帧的属性编辑，也是跟Core Animation的CAAnimation类以及子类的属性一致</li><li>F: 画布，Layer的编辑区</li></ul><p>总体上来看，QuartzCode的界面跟XIB、StoryBoard的风格非常类似，还是很容易上手的，更多的教程看官网：<a href="http://www.quartzcodeapp.com/" target="_blank" rel="noopener">http://www.quartzcodeapp.com/</a></p><h2 id="整理思路"><a href="#整理思路" class="headerlink" title="整理思路"></a>整理思路</h2><p>首先整理下思路：</p><p><img src="/2017/03/08/quartzcode-demo-star-animation/quartzcode_demo_star_animation_3.jpg" alt=""></p><p>总体上可以分成两个部分，一个是动画部分，用QuartzCode实现可视化编辑创建；另一个是功能、代码API设置部分，需要在QuartzCode最后导出的代码基础上，添加、修改，封装成简单的控件库。</p><h2 id="QuartzCode实现动画"><a href="#QuartzCode实现动画" class="headerlink" title="QuartzCode实现动画"></a>QuartzCode实现动画</h2><p>先来看看动画的实现，本节只把主要步骤流程列出来，详细的参数、设置，参考<a href="https://github.com/zekunyan/QuartzCodeExample-StarAimation" target="_blank" rel="noopener">GitHub上的QuartzCode文件</a>。</p><h3 id="显示星星动画"><a href="#显示星星动画" class="headerlink" title="显示星星动画"></a>显示星星动画</h3><p>显示星星的动画由三个部分组成，分别是实心的星星从小到大出现，空心的从大到小并透明度减小消失，最后星星四周闪动圆点、短线。</p><p><strong>实心星星从小到大出现</strong></p><p><img src="/2017/03/08/quartzcode-demo-star-animation/quartzcode_demo_star_animation_4.jpg" alt=""></p><ol><li>拖入图片素材到中间的画布上，软件会自动创建一个layer，可以通过Inspector调整大小、位置</li><li>对Layers里面自动生成的layer重命名</li><li>点击Animations的“+”按钮，添加一个动画组，命名为show</li><li>选中当前的layer，点击Timeline下对应layer的“+”按钮，添加一个Bounds帧动画</li><li>Timeline里面的每一行对应帧动画的时间轴，可以在轴上双击、右键添加关键帧，这里默认就好，分别<strong>选中</strong>Bounds帧动画时间轴<strong>两端的关键点</strong>，在右边的Keyframe inspector里面设置Size值，起始是（0，0），结束时大小为原图大小</li></ol><p><strong>空心星星从大到小、透明度减小消失</strong></p><p><img src="/2017/03/08/quartzcode-demo-star-animation/quartzcode_demo_star_animation_5.jpg" alt=""></p><p>基本和上一步一样，可以先隐藏实心的layer以便于观察。</p><ol><li>添加空心的星星图片素材</li><li>命名layer</li><li>给空心的layer添加Bounds和Opacity两种动画，分别修改帧动画的起始、结束值</li><li>拖动时间轴查看效果</li></ol><p><strong>四周闪动短线、圆点</strong></p><p>短线、圆点是沿着星星的四周<strong>重复排列</strong>的，所以这里可以用<code>CAReplicatorLayer</code>来实现，对应到QuartzCode里面就是工具栏的”Replicator”类型的Layer。<code>CAReplicatorLayer</code>可以根据一定的<strong>规则重复</strong>的绘制内部的子Layer，在这里只需要按照旋转角度变化就好。</p><p><img src="/2017/03/08/quartzcode-demo-star-animation/quartzcode_demo_star_animation_6.jpg" alt=""></p><ol><li>点击”Replicator”，在中间的画布上拖动出一个layer，然后选择”Shape”里面的圆角矩形，在星星的一角拖动画出一个小的圆角矩形，<strong>保证star_layer在replicator layer的内部</strong></li><li>设置replicator的属性，实现循环重复内部的layer，这里设置”instance count”为5，”Rotation”为72，也就是360/5=72，就可以实现按照星星的五个角重复绘制</li><li>最后就是添加动画，分别是Opacity透明度从0到1，Position从内到外，Transform变化大小</li></ol><p>剩余的圆点，和短线的创建方法一致，就不再重复讲解～</p><p>至此，显示的动画就创建好了。</p><h3 id="隐藏星星动画"><a href="#隐藏星星动画" class="headerlink" title="隐藏星星动画"></a>隐藏星星动画</h3><p>再来看看隐藏星星的动画，有了上一小节的基础，隐藏星星的动画就容易多了，基本步骤都是一样的，如下：</p><p><img src="/2017/03/08/quartzcode-demo-star-animation/quartzcode_demo_star_animation_7.jpg" alt=""></p><ol><li>添加一个新的动画组hide</li><li>分别设置每个layer的动画，实心的星星从大到小、同时透明度降低，空心的相反，replicator layer一直隐藏</li></ol><h3 id="导出动画代码"><a href="#导出动画代码" class="headerlink" title="导出动画代码"></a>导出动画代码</h3><p>动画都实现了好了以后，就可以导出代码了。</p><p>依次<code>File-&gt;Export Code...</code>，就可以打开导出代码的预览界面：</p><p><img src="/2017/03/08/quartzcode-demo-star-animation/quartzcode_demo_star_animation_8.jpg" alt=""></p><p>右边的选项，按照需要选择，默认的基本可以满足要求，“Export Image Assets”最好选上，可以一同导出图片资源。选项的说明参见文档：<a href="http://www.quartzcodeapp.com/code-generation/code-options/" target="_blank" rel="noopener">http://www.quartzcodeapp.com/code-generation/code-options/</a></p><p>至此，最复杂的动画部分就完成了，不用写一行代码，全部可视化编辑～</p><h2 id="调整、封装代码"><a href="#调整、封装代码" class="headerlink" title="调整、封装代码"></a>调整、封装代码</h2><p>接着就是封装导出的代码，方便使用。</p><h3 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h3><p>首先是整个动画的API的设计，为了方便给任意UIView实例添加动画，所以设计成UIView的Category，如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  UIView+TTGStarAnimation.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> (<span class="title">TTGStarAnimation</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化动画</span></span><br><span class="line">- (<span class="keyword">void</span>)ttg_setupStarAnimation;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化动画，同时可以调整inset</span></span><br><span class="line">- (<span class="keyword">void</span>)ttg_setupStarAnimationWithEdgeInset:(<span class="built_in">UIEdgeInsets</span>)inset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示星星动画</span></span><br><span class="line">- (<span class="keyword">void</span>)ttg_showStarAnimated:(<span class="built_in">BOOL</span>)animated complete:(<span class="keyword">void</span> (^)())complete;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏星星动画</span></span><br><span class="line">- (<span class="keyword">void</span>)ttg_hideStarAnimated:(<span class="built_in">BOOL</span>)animated complete:(<span class="keyword">void</span> (^)())complete;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前是否显示</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)ttg_getStarIsShow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="AssociatedObject保存动画View实例"><a href="#AssociatedObject保存动画View实例" class="headerlink" title="AssociatedObject保存动画View实例"></a>AssociatedObject保存动画View实例</h3><p>QuartzCode导出的动画代码都在一个View上，所以为了在Category里给任意UIView实例添加动画View的Property、当前星星是否显示的Bool值，就要用到AssociatedObject，对应的set、get方法如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  UIView+TTGStarAnimation.m</span></span><br><span class="line"></span><br><span class="line">- (TTGStarAnimationView *)ttg_getStarAnimationView &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, &amp;kTTGButtonStarAnimationViewKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)ttg_getStarIsShow &#123;</span><br><span class="line">    <span class="keyword">return</span> [objc_getAssociatedObject(<span class="keyword">self</span>, &amp;kTTGButtonStarAnimationStateKey) boolValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)ttg_setStarIsShow:(<span class="built_in">BOOL</span>)isShow &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;kTTGButtonStarAnimationStateKey, @(isShow), OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改QuartzCode导出的代码-暴露内部Layer实例"><a href="#修改QuartzCode导出的代码-暴露内部Layer实例" class="headerlink" title="修改QuartzCode导出的代码 - 暴露内部Layer实例"></a>修改QuartzCode导出的代码 - 暴露内部Layer实例</h3><p>QuartzCode导出的代码，内部的动画Layer是不可见的，为了能“手动”控制动画View的实际显示状态，就要修改下导出的代码，暴露内部的动画Layer实例。</p><p>所有的Layer都在<code>NSMutableDictionary * layers</code>字典里面，通过key获取，给<code>TTGStarAnimationView.h</code>添加三个属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  TTGStarAnimationView.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TTGStarAnimationView</span> : <span class="title">UIView</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">CALayer</span> *fillLayer;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">CALayer</span> *emptyLayer;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">CALayer</span> *replicatedLayer;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>然后实现getter方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  TTGStarAnimationView.m</span></span><br><span class="line">- (<span class="built_in">CALayer</span> *)fillLayer &#123;</span><br><span class="line">    <span class="keyword">return</span> _layers[<span class="string">@"star_animation_fill"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CALayer</span> *)emptyLayer &#123;</span><br><span class="line">    <span class="keyword">return</span> _layers[<span class="string">@"star_animation_empty"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CALayer</span> *)replicatedLayer &#123;</span><br><span class="line">    <span class="keyword">return</span> _layers[<span class="string">@"replicator"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><code>ttg_setupStarAnimation</code>和<code>ttg_setupStarAnimationWithEdgeInset:</code>方法，用来初始化动画，包括创建<code>TTGStarAnimationView</code>实例，添加、保存在当前view上，设置每个动画layer的状态等操作：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  TTGStarAnimationView.m</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)ttg_setupStarAnimation &#123;</span><br><span class="line">    [<span class="keyword">self</span> ttg_setupStarAnimationWithEdgeInset:<span class="built_in">UIEdgeInsetsZero</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)ttg_setupStarAnimationWithEdgeInset:(<span class="built_in">UIEdgeInsets</span>)inset &#123;</span><br><span class="line">    <span class="comment">// 获取当前实例的动画starAnimationView</span></span><br><span class="line">    TTGStarAnimationView *starAnimationView = [<span class="keyword">self</span> ttg_getStarAnimationView];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!starAnimationView) &#123;</span><br><span class="line">        <span class="comment">// 不存在，创建新的</span></span><br><span class="line">        starAnimationView = [[TTGStarAnimationView alloc] initWithFrame:<span class="built_in">UIEdgeInsetsInsetRect</span>(<span class="keyword">self</span>.bounds, inset)];</span><br><span class="line">        <span class="comment">// 设置不可接受交互事件，防止阻断父view</span></span><br><span class="line">        starAnimationView.userInteractionEnabled = <span class="literal">NO</span>;</span><br><span class="line">        <span class="comment">// 设置AutoSizingMask</span></span><br><span class="line">        starAnimationView.autoresizingMask = <span class="built_in">UIViewAutoresizingFlexibleWidth</span> | <span class="built_in">UIViewAutoresizingFlexibleHeight</span>;</span><br><span class="line">        <span class="comment">// 添加</span></span><br><span class="line">        [<span class="keyword">self</span> addSubview:starAnimationView];</span><br><span class="line">        <span class="comment">// AssociatedObject保存实例</span></span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;kTTGButtonStarAnimationViewKey, starAnimationView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除所有动画</span></span><br><span class="line">    [starAnimationView removeAllAnimations];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置layer的初始化状态</span></span><br><span class="line">    starAnimationView.fillLayer.hidden = <span class="literal">YES</span>;</span><br><span class="line">    starAnimationView.emptyLayer.hidden = <span class="literal">NO</span>;</span><br><span class="line">    starAnimationView.replicatedLayer.hidden = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置初始化状态值</span></span><br><span class="line">    [<span class="keyword">self</span> ttg_setStarIsShow:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动画控制"><a href="#动画控制" class="headerlink" title="动画控制"></a>动画控制</h3><p>最后就是实现动画的控制，这里比较关键的是对动画的每个Layer的控制，每个Layer的初始、最终状态都要设置，<strong>保证多次调用、无论是否执行动画</strong>，最终显示都是一致的，以显示星星为例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  TTGStarAnimationView.m</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)ttg_showStarAnimated:(<span class="built_in">BOOL</span>)animated complete:(<span class="keyword">void</span> (^)())complete &#123;</span><br><span class="line">    <span class="comment">// 获取当前view的动画starAnimationView实例</span></span><br><span class="line">    TTGStarAnimationView *starAnimationView = [<span class="keyword">self</span> ttg_getStarAnimationView];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前是hide，才执行show</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> ttg_getStarIsShow]) &#123;</span><br><span class="line">        <span class="comment">// 设置状态值</span></span><br><span class="line">        [<span class="keyword">self</span> ttg_setStarIsShow:<span class="literal">YES</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先移除所有动画</span></span><br><span class="line">        [starAnimationView removeAllAnimations];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置最终状态下Layer的hidden值的Block</span></span><br><span class="line">        <span class="keyword">void</span> (^completionBlock)() = ^ &#123;</span><br><span class="line">            starAnimationView.fillLayer.hidden = <span class="literal">NO</span>;</span><br><span class="line">            starAnimationView.emptyLayer.hidden = <span class="literal">YES</span>;</span><br><span class="line">            starAnimationView.replicatedLayer.hidden = <span class="literal">YES</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 执行回调</span></span><br><span class="line">            <span class="keyword">if</span> (complete) &#123;</span><br><span class="line">                complete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (animated) &#123;</span><br><span class="line">            <span class="comment">// 如果要执行动画，则设置动画前Layer的hidden值</span></span><br><span class="line">            starAnimationView.fillLayer.hidden = <span class="literal">NO</span>;</span><br><span class="line">            starAnimationView.emptyLayer.hidden = <span class="literal">NO</span>;</span><br><span class="line">            starAnimationView.replicatedLayer.hidden = <span class="literal">NO</span>;</span><br><span class="line">            <span class="comment">// 执行动画</span></span><br><span class="line">            [starAnimationView addShowAnimationCompletionBlock:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">                completionBlock();</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不用动画，直接执行最终状态</span></span><br><span class="line">            completionBlock();</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>隐藏的代码跟显示基本一致，把各种状态、hidden的值倒过来就可以了。<br>所有代码参见<a href="https://github.com/zekunyan/QuartzCodeExample-StarAimation" target="_blank" rel="noopener">Github</a>。</p><p>要写的代码就这么多，是不是非常简单！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>“工欲善其事,必先利其器”，借助各种强大的工具软件，做动画的效率简直提升几十倍～</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;“工欲善其事,必先利其器”，iOS的Core Animation非常强大，可以做出非常炫酷的动画，但是实际写起来还是比较麻烦，代码不直观，需要反复的改参数、Build、运行，所以诞生了各种动画制作工具，本文就以其中比较有名的&lt;a href=&quot;http://www.quartzcodeapp.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QuartzCode&lt;/a&gt;为例，快速实现一个收藏功能的星星动画，最终的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2017/03/08/quartzcode-demo-star-animation/quartzcode_demo_star_animation_1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;GitHub地址：&lt;a href=&quot;https://github.com/zekunyan/QuartzCodeExample-StarAimation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/zekunyan/QuartzCodeExample-StarAimation&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="开源" scheme="http://tutuge.me/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>开源项目-拼图验证控件TTGPuzzleVerify的实现</title>
    <link href="http://tutuge.me/2016/12/25/TTGPuzzleVerify/"/>
    <id>http://tutuge.me/2016/12/25/TTGPuzzleVerify/</id>
    <published>2016-12-25T10:15:40.000Z</published>
    <updated>2018-10-07T17:37:28.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近抽空写了个拼图验证控件，用户可以通过水平、垂直，或者直接拖动拼图块，完成拼图图案，来完成验证。拼图块的形状可以自定义，默认提供了经典的拼图形状、圆形、正方形，整个拼图的图案也是支持从图片生成的。</p><p><strong>CocoaPods</strong>: <code>pod &quot;TTGPuzzleVerify&quot;</code><br><strong>Github</strong>: <a href="https://github.com/zekunyan/TTGPuzzleVerify" target="_blank" rel="noopener">https://github.com/zekunyan/TTGPuzzleVerify</a></p><p><img src="/2016/12/25/TTGPuzzleVerify/blog_TTGPuzzleVerify_gif.gif" alt=""></p><p>接下来，说说TTGPuzzleVerify的整体设计思路和实现原理。</p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><p>先直观上分析一下控件的组成部分：</p><p><img src="/2016/12/25/TTGPuzzleVerify/blog_TTGPuzzleVerify_1.png" alt="组成部分"></p><p>可以直观看出，控件应该由三个部分组成：</p><ul><li>拼图块：就是从原图上<strong>“抠”</strong>出来的拼图形状的图片块</li><li>原始图片：拼图整体图案的图片</li><li>镂空背景：从原始图片上抠出拼图块以后，给用户提示用的，透明度更低的拼图块镂空背景</li></ul><h3 id="拆解步骤"><a href="#拆解步骤" class="headerlink" title="拆解步骤"></a>拆解步骤</h3><p>分析完了控件的组成，现在就来梳理一下控件的整个创建、交互流程。</p><p><img src="/2016/12/25/TTGPuzzleVerify/blog_TTGPuzzleVerify_2.png" alt="步骤"></p><ul><li>输入：图片、拼图形状、拼图大小、镂空的位置、拼图块的起始位置</li><li>生成拼图路径：根据拼图类型，生成对应的贝塞尔曲线</li><li>从图片抠出拼图块、镂空：有了拼图路径，就可以抠出拼图块和镂空的部分</li><li>设置位置、样式：根据参数设置拼图块的初始位置、样式，如阴影、镂空的透明度等</li><li>用户拖动：响应用户的头动手势，移动拼图块，根据坐标判断是否完成拼图</li><li>回调：用户完成拼图后，要回调，让外部响应拼图完成事件</li></ul><h3 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h3><p>从上面的步骤可以整理出来几个关键的技术点，如下：</p><p><strong>拼图的路径生成</strong><br>普通的形状，如正方形、圆形之类的还好，代码实现比较方便，但是复杂的拼图图案怎么办？</p><p><strong>从图片上“抠出”拼图块、镂空</strong><br>有了拼图的形状路径，如何从图片上抠出拼图块和镂空？</p><p><strong>用户拖动拼图、完成拼图验证</strong><br>抠出了拼图块，如何将用户的手势对应到移动拼图块，最终完成验证？</p><p>下面针对这三个点着重写下实现原理。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="拼图的路径生成"><a href="#拼图的路径生成" class="headerlink" title="拼图的路径生成"></a>拼图的路径生成</h3><p>既然手写代码太难，那就从现有的图案生成代码。</p><p><strong>1. 找SVG素材</strong><br>既然要能随意改变大小，就要找矢量的图，Google “free svg”、“free icon”之类的，很容易就能找到免费的矢量图素材，例如TTGPuzzleVerify里面用的拼图形状就是从<a href="http://iconmonstr.com/puzzle-1/" target="_blank" rel="noopener">iconmonstr.com</a>找来的。</p><p><strong>2. 编辑</strong><br>直接下载回来的SVG还需要调整一下，如去除背景，我是用Sketch来编辑的。</p><p><img src="/2016/12/25/TTGPuzzleVerify/blog_TTGPuzzleVerify_3.png" alt="拼图SVG编辑"></p><p><strong>3. 生成代码</strong><br>拼图的路径本质上就是拼图的轮廓，在Sketch里面把拼图SVG的背景色等颜色删除，然后就是将其转换为代码。<br>这里可以用<a href="https://www.paintcodeapp.com/sketch" target="_blank" rel="noopener">PaintCode plugin for Sketch</a>，将Sketch的拼图矢量路径导出成代码。</p><p><strong>4. 调整代码</strong><br>直接生成的代码有时可能会不适用，可以人工调整下，然后就可以放到自己的类里面了：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">UIBezierPath</span> *)classicPuzzlePath &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">UIBezierPath</span> *puzzleShape = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        puzzleShape = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">        [puzzleShape moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">17.45</span>, <span class="number">71.16</span>)];</span><br><span class="line">        <span class="comment">// 此处省略很多行=。=，PaintCode生成的</span></span><br><span class="line">        [puzzleShape closePath];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> puzzleShape;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. UIBezierPath拼图路径的大小、位置调整</strong><br>直接导出的拼图路径的大小、位置是固定的，但是控件是要可以支持改变大小、位置的，所以，要对路径做变换，刚好<code>UIBezierPath</code>支持<code>CGAffineTransform</code>变换。</p><p>大小变换：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大小变换，path是生成的原始路径，_puzzleSize是传入的拼图块大小</span></span><br><span class="line">[path applyTransform:CGAffineTransformMakeScale(_puzzleSize.<span class="built_in">width</span> / path.bounds.<span class="built_in">size</span>.<span class="built_in">width</span>,</span><br><span class="line">                                                _puzzleSize.<span class="built_in">height</span> / path.bounds.<span class="built_in">size</span>.<span class="built_in">height</span>)];</span><br></pre></td></tr></table></figure><p>位置变换：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 位置变换，<span class="built_in">path</span>是生成的原始路径，_puzzleBlankPosition是传入的拼图块、镂空位置</span><br><span class="line">[<span class="built_in">path</span> applyTransform:CGAffineTransformMakeTranslation(</span><br><span class="line">            _puzzleBlankPosition.x - <span class="built_in">path</span>.bounds.origin.x,</span><br><span class="line">            _puzzleBlankPosition.y - <span class="built_in">path</span>.bounds.origin.y)];</span><br></pre></td></tr></table></figure><p>至此，拼图的路径就写好了。</p><h3 id="从图片上“抠出”拼图块、镂空"><a href="#从图片上“抠出”拼图块、镂空" class="headerlink" title="从图片上“抠出”拼图块、镂空"></a>从图片上“抠出”拼图块、镂空</h3><p><strong>1. 拼图块</strong><br>有了UIBezierPath路径，抠出拼图块还是比较容易的，直接用<code>CAShapeLayer</code>来<strong>“mask”</strong>图片即可：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拼图路径</span></span><br><span class="line"><span class="built_in">UIBezierPath</span> *puzzlePath = [<span class="keyword">self</span> getNewScaledPuzzledPath];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建mask layer</span></span><br><span class="line"><span class="built_in">CAShapeLayer</span> *puzzleMaskLayer = [<span class="built_in">CAShapeLayer</span> new];</span><br><span class="line">puzzleMaskLayer.frame = <span class="keyword">self</span>.bounds;</span><br><span class="line">puzzleMaskLayer.path = puzzlePath.CGPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mask到图片imageView上</span></span><br><span class="line">_puzzleImageView.layer.mask = puzzleMaskLayer;</span><br></pre></td></tr></table></figure><p>效果就是：</p><p><img src="/2016/12/25/TTGPuzzleVerify/blog_TTGPuzzleVerify_4.png" alt="拼图块"></p><p><strong>2. 镂空图片</strong><br>抠出拼图块还是很容易的，但是“镂空”怎么办？<br>其实道理是一样的，都是<strong>mask</strong>，只不过mask的区域反过来而已。<br><code>CAShapeLayer</code>的<code>fillRule</code>就可以调整“填充的规则”，此处用<code>kCAFillRuleEvenOdd</code>就可以了，文档的解释如下：</p><blockquote><p>Specifies the even-odd winding rule. Count the total number of path crossings. If the number of crossings is even, the point is outside the path. If the number of crossings is odd, the point is inside the path and the region containing it should be filled.</p></blockquote><p>理解过来就是：区域内一点，往外划一条线，经过奇数个数的交点，则点在区域内，偶数个数的交点，则在区域外。</p><p>所以，只要在拼图路径的基础上，补充最外部的边框的路径即可：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建矩形边框路径</span></span><br><span class="line"><span class="built_in">UIBezierPath</span> *maskPath = [<span class="built_in">UIBezierPath</span> bezierPathWithRect:<span class="keyword">self</span>.bounds];</span><br><span class="line"><span class="comment">// 添加拼图路径</span></span><br><span class="line">[maskPath appendPath:[<span class="built_in">UIBezierPath</span> bezierPathWithCGPath:puzzlePath.CGPath]];</span><br><span class="line"><span class="comment">// 设置规则</span></span><br><span class="line">maskPath.usesEvenOddFillRule = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建mask的layer</span></span><br><span class="line"><span class="built_in">CAShapeLayer</span> *frontMaskLayer = [<span class="built_in">CAShapeLayer</span> new];</span><br><span class="line">frontMaskLayer.frame = <span class="keyword">self</span>.bounds;</span><br><span class="line">frontMaskLayer.path = maskPath.CGPath;</span><br><span class="line">frontMaskLayer.fillRule = kCAFillRuleEvenOdd; <span class="comment">// 填充规则</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置mask</span></span><br><span class="line">_frontImageView.layer.mask = frontMaskLayer;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="/2016/12/25/TTGPuzzleVerify/blog_TTGPuzzleVerify_5.png" alt="镂空"></p><p><strong>3. 镂空背景</strong><br>有了拼图块、镂空，还差一块，就是镂空的“半透明背景”，其实这个“半透明背景”和拼图块是一模一样的，所以不再重复代码，唯一增加的就是设置其透明度。</p><p><strong>4. 组合</strong><br>将上面的组合到一起，就能形成最终的效果，从Reveal里面看到分层结构如下：</p><p><img src="/2016/12/25/TTGPuzzleVerify/blog_TTGPuzzleVerify_6.png" alt="分层"></p><p>其实就是三张一样的图片，按照不同的mask规则做了处理，叠加起来。</p><h3 id="用户拖动拼图、完成拼图验证"><a href="#用户拖动拼图、完成拼图验证" class="headerlink" title="用户拖动拼图、完成拼图验证"></a>用户拖动拼图、完成拼图验证</h3><p><strong>1. 拖动图片</strong><br>有了上面的结构，拖动拼图的处理也就容易多了，只要移动最上层的拼图块就行了，这里直接用<code>UIPanGestureRecognizer</code>实现，移动的时候基于拼图的中心移动。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建手势</span></span><br><span class="line"><span class="built_in">UIPanGestureRecognizer</span> *panGestureRecognizer = [<span class="built_in">UIPanGestureRecognizer</span> new];</span><br><span class="line">[panGestureRecognizer addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(onPanGesture:)];</span><br><span class="line">[<span class="keyword">self</span> addGestureRecognizer:panGestureRecognizer];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手势处理</span></span><br><span class="line">- (<span class="keyword">void</span>)onPanGesture:(<span class="built_in">UIPanGestureRecognizer</span> *)panGestureRecognizer &#123;</span><br><span class="line">    <span class="comment">// 获取坐标</span></span><br><span class="line">    <span class="built_in">CGPoint</span> panLocation = [panGestureRecognizer locationInView:<span class="keyword">self</span>];</span><br><span class="line">    <span class="comment">// 拼图中心偏移</span></span><br><span class="line">    <span class="built_in">CGPoint</span> position = <span class="built_in">CGPointZero</span>;</span><br><span class="line">    position.x = panLocation.x - _puzzleSize.width / <span class="number">2</span>;</span><br><span class="line">    position.y = panLocation.y - _puzzleSize.height / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 设置坐标</span></span><br><span class="line">    [<span class="keyword">self</span> setPuzzlePosition:position];</span><br><span class="line">    <span class="comment">// 判断、回调。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 验证用户的拼图是否完成</strong><br>用户移动拼图时，只要判断拼图的坐标和镂空的位置是否一致就行。但是如果完全精确的判断，用户很难准确的把拼图拼对上，所以还要增加一定的<strong>“tolerance”</strong>，让拼图更加容易，同时暴漏出让外部设置：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> verificationTolerance; <span class="comment">// Verification tolerance, default is 8</span></span><br></pre></td></tr></table></figure><p>判断的逻辑如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// puzzlePosition是当前拼图块的位置，_puzzleBlankPosition是拼图镂空的位置</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isVerified &#123;</span><br><span class="line">    <span class="keyword">return</span> fabsf([<span class="keyword">self</span> puzzlePosition].x - _puzzleBlankPosition.x) &lt;= _verificationTolerance &amp;&amp;</span><br><span class="line">           fabsf([<span class="keyword">self</span> puzzlePosition].y - _puzzleBlankPosition.y) &lt;= _verificationTolerance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 完成拼图</strong><br>当用户完成拼图后，外部会得到<code>delegate</code>、<code>block</code>的回调响应，接着就可以“完成拼图验证”，对此向外提供一个方法：<code>- (void)completeVerificationWithAnimation:(BOOL)withAnimation</code>，调用后拼图块将会移动回镂空位置，模拟出拼图完成的效果。</p><p>至此，TTGPuzzleVerify的关键实现技术点就是这些了～</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>嗯，圣诞节快乐！ – 2016-12-25</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近抽空写了个拼图验证控件，用户可以通过水平、垂直，或者直接拖动拼图块，完成拼图图案，来完成验证。拼图块的形状可以自定义，默认提供了经典的拼图形状、圆形、正方形，整个拼图的图案也是支持从图片生成的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CocoaPods&lt;/strong&gt;: &lt;code&gt;pod &amp;quot;TTGPuzzleVerify&amp;quot;&lt;/code&gt;&lt;br&gt;&lt;strong&gt;Github&lt;/strong&gt;: &lt;a href=&quot;https://github.com/zekunyan/TTGPuzzleVerify&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/zekunyan/TTGPuzzleVerify&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2016/12/25/TTGPuzzleVerify/blog_TTGPuzzleVerify_gif.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;接下来，说说TTGPuzzleVerify的整体设计思路和实现原理。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="开源" scheme="http://tutuge.me/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>Swift开源Mac App - BingWallPaper</title>
    <link href="http://tutuge.me/2016/08/28/TTGBingWallPaper/"/>
    <id>http://tutuge.me/2016/08/28/TTGBingWallPaper/</id>
    <published>2016-08-28T14:37:02.000Z</published>
    <updated>2018-10-07T17:37:29.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><ul><li>2016-09-05: <a href="https://github.com/zekunyan/TTGBingWallPaper/releases/download/0.3/BingWallPaper.app.zip" target="_blank" rel="noopener">新版0.3</a>增加子Menu，整理选项；增加“History Wallpapers”打开历史图片文件夹；增加“Launch at startup”开机启动。</li><li>2016-09-03: <a href="https://github.com/zekunyan/TTGBingWallPaper/releases/download/0.2.0/BingWallPaper.app.zip" target="_blank" rel="noopener">新版0.2.0！</a>增加“Auto Update”选项；增加“Random”随机选择设置壁纸；修复自动更新不准的Bug。</li></ul><p><img src="/2016/08/28/TTGBingWallPaper/BingWallPaper_banner.png" alt="Banner"></p><p>极简的壁纸Mac App，每天<strong>自动</strong>下载最新微软Bing的每日壁纸并设置为桌面背景。</p><p><img src="/2016/08/28/TTGBingWallPaper/BingWallPaper_screenshot_2.png" alt="ScreenShot1"></p><p>Github: <a href="https://github.com/zekunyan/TTGBingWallPaper" target="_blank" rel="noopener">https://github.com/zekunyan/TTGBingWallPaper</a></p><a id="more"></a><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>其实最开始只是很喜欢Bing的首页的壁纸图片，然后手动下载回来做壁纸，后来发现手动太麻烦，作为一个程序员，自己动手丰衣足食！=。= 然后花了个周末写了这个超简单的Mac App。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>到Github的项目页面，即<a href="https://github.com/zekunyan/TTGBingWallPaper" target="_blank" rel="noopener">https://github.com/zekunyan/TTGBingWallPaper</a>，从<code>release</code>里面下载最新的<code>BingWallPaper.app.zip</code>压缩包，解压出<code>BingWallPaper.app</code>，拖到<code>Applications</code>应用程序文件夹里面，打开即可。</p><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p>用Swift 2.2写的，目前唯一依赖的库是<a href="https://github.com/SwiftyJSON/SwiftyJSON" target="_blank" rel="noopener">SwiftyJSON/SwiftyJSON</a>，需要<a href="https://github.com/Carthage/Carthage" target="_blank" rel="noopener">Carthage</a>。</p><ul><li><code>git clone git@github.com:zekunyan/TTGBingWallPaper.git</code></li><li><code>cd TTGBingWallPaper</code></li><li><code>carthage update</code></li><li><code>open BingWallPaper.xcodeproj</code></li><li>编译、安装、运行</li></ul><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>还有很多点可以做，一点一点来吧=。=</p><p><strong>TODO</strong></p><ul><li>支持多国地区的Bing每日图片壁纸的获取</li><li>支持多语言</li><li>支持浏览历史图片</li><li>导出图片</li><li>…</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;更新&quot;&gt;&lt;a href=&quot;#更新&quot; class=&quot;headerlink&quot; title=&quot;更新&quot;&gt;&lt;/a&gt;更新&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;2016-09-05: &lt;a href=&quot;https://github.com/zekunyan/TTGBingWallPaper/releases/download/0.3/BingWallPaper.app.zip&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;新版0.3&lt;/a&gt;增加子Menu，整理选项；增加“History Wallpapers”打开历史图片文件夹；增加“Launch at startup”开机启动。&lt;/li&gt;
&lt;li&gt;2016-09-03: &lt;a href=&quot;https://github.com/zekunyan/TTGBingWallPaper/releases/download/0.2.0/BingWallPaper.app.zip&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;新版0.2.0！&lt;/a&gt;增加“Auto Update”选项；增加“Random”随机选择设置壁纸；修复自动更新不准的Bug。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/2016/08/28/TTGBingWallPaper/BingWallPaper_banner.png&quot; alt=&quot;Banner&quot;&gt;&lt;/p&gt;
&lt;p&gt;极简的壁纸Mac App，每天&lt;strong&gt;自动&lt;/strong&gt;下载最新微软Bing的每日壁纸并设置为桌面背景。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2016/08/28/TTGBingWallPaper/BingWallPaper_screenshot_2.png&quot; alt=&quot;ScreenShot1&quot;&gt;&lt;/p&gt;
&lt;p&gt;Github: &lt;a href=&quot;https://github.com/zekunyan/TTGBingWallPaper&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/zekunyan/TTGBingWallPaper&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mac" scheme="http://tutuge.me/categories/Mac/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="开源" scheme="http://tutuge.me/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="Mac" scheme="http://tutuge.me/tags/Mac/"/>
    
      <category term="Swift" scheme="http://tutuge.me/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>有趣的Autolayout示例4-Masonry实现</title>
    <link href="http://tutuge.me/2016/08/06/autolayout-example-with-masonry4/"/>
    <id>http://tutuge.me/2016/08/06/autolayout-example-with-masonry4/</id>
    <published>2016-08-06T13:41:17.000Z</published>
    <updated>2018-10-07T17:37:29.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第四篇来了。<br>还是3个小例子，仍然是主要部分用Masonry手写代码实现，其它的约束在storyboard里面直接拖拽搭建。<br>三个例子分别是：  </p><ol><li>用约束优先级保证可移动View的内容可见</li><li>Autolayout的约束=控件间位置关系的“绑定”</li><li>利用<code>layoutIfNeeded</code>控制约束的生效时机</li></ol><p>前三篇：  </p><ul><li>第一篇：<a href="http://tutuge.me/2015/05/23/autolayout-example-with-masonry/">有趣的Autolayout示例-Masonry实现</a>  </li><li>第二篇：<a href="http://tutuge.me/2015/08/08/autolayout-example-with-masonry2/">有趣的Autolayout示例2-Masonry实现</a>  </li><li>第三篇：<a href="http://tutuge.me/2015/12/14/autolayout-example-with-masonry3/">有趣的Autolayout示例3-Masonry实现</a></li></ul><p>Github地址：<br><a href="https://github.com/zekunyan/AutolayoutExampleWithMasonry" target="_blank" rel="noopener">https://github.com/zekunyan/AutolayoutExampleWithMasonry</a></p><p><img src="/2016/08/06/autolayout-example-with-masonry4/blog_autolayout_example_with_masonry4_1.gif" alt="Gif示例"></p><a id="more"></a><h2 id="Case-1-用约束优先级保证可移动View的内容可见性"><a href="#Case-1-用约束优先级保证可移动View的内容可见性" class="headerlink" title="Case 1: 用约束优先级保证可移动View的内容可见性"></a>Case 1: 用约束优先级保证可移动View的内容可见性</h2><h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><p>Case 1实现的功能就是，可以用手指拖动一个灰色的Tip控件，在红框containerView内移动，并且保持移动到红框边缘时，Tip控件的内容不会超出红框，保证内容的可见性。</p><h3 id="Frame-VS-Autolayout"><a href="#Frame-VS-Autolayout" class="headerlink" title="Frame VS Autolayout"></a>Frame VS Autolayout</h3><p>如果不用Autolayout的话，直接计算、设定frame，那么可能的步骤如下：</p><ol><li>获取手指当前触摸点在红框containerView内的坐标</li><li>计算Tip控件的宽高</li><li>根据宽高，计算、判断Tip控件会不会在新的位置上超出边界</li><li>调整新的Tip位置坐标</li><li>设置Tip控件的frame，指定新的坐标</li></ol><p>这样去实现的话，代码将会比较“丑”=。。=，有大量的判断、数值计算，而且容易出错。</p><p>而用Autolayout的话，<strong>只需要两步</strong>：</p><ol><li>设置约束</li><li>根据手指坐标，更新left、top两个约束，即更新Tip的位置</li></ol><p>至于保证Tip内容在可见范围内，就交给Autolayout处理吧~</p><h3 id="关键原理"><a href="#关键原理" class="headerlink" title="关键原理"></a>关键原理</h3><p>用Autolayout实现的关键，就是<strong>善于利用约束的优先级</strong>。先看看设置的约束示意图：</p><p><img src="/2016/08/06/autolayout-example-with-masonry4/blog_autolayout_example_with_masonry4_2.png" alt="Case 1: 用约束优先级保证可移动View的内容可见性"></p><p>中间的tipLabel就是被移动的控件  </p><ul><li>褐色的两个约束，分别是Tip控件的centerX和centerY，与上级View的left和top的约束，用来对Tip定位</li><li>四个蓝色的约束，则是确保Tip内容不超出边界的约束</li></ul><p>重点其实就在于，<strong>蓝色的约束的优先级比褐色的优先级高，这样，在移动中，系统会优先满足Tip的内容保持在边界内</strong>。</p><h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>具体的设置约束代码如下：</p><h4 id="左边和顶部的约束-控制位置"><a href="#左边和顶部的约束-控制位置" class="headerlink" title="左边和顶部的约束 - 控制位置"></a>左边和顶部的约束 - 控制位置</h4><p>首先设置两个属性，保存左边和顶部的约束，用于在移动时调整位置：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span><span class="title"> </span>(nonatomic, strong) MASConstraint *leftConstraint;</span><br><span class="line">@<span class="keyword">property</span><span class="title"> </span>(nonatomic, strong) MASConstraint *topConstraint;</span><br></pre></td></tr></table></figure><p>然后就是设置具体的left、top约束，并设置优先级为750，也就是High</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">_tipLabel</span> mas_makeConstraints:^(<span class="name">MASConstraintMaker</span> *make) &#123;</span><br><span class="line">    // 优先级要比边界条件低</span><br><span class="line">    _leftConstraint = make.centerX.equalTo(<span class="name">_containerView.mas_left</span>).with.offset(<span class="name">50</span>).priorityHigh()<span class="comment">; </span></span><br><span class="line">    // 优先级要比边界条件低</span><br><span class="line">    _topConstraint = make.centerY.equalTo(<span class="name">_containerView.mas_top</span>).with.offset(<span class="name">50</span>).priorityHigh()<span class="comment">;</span></span><br><span class="line">    // ...</span><br><span class="line">&#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="四周的约束-保证内容在边界内"><a href="#四周的约束-保证内容在边界内" class="headerlink" title="四周的约束 - 保证内容在边界内"></a>四周的约束 - 保证内容在边界内</h4><p>然后就是上下左右四个边界的约束：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[_tipLabel mas_makeConstraints:^(<span class="name">MASConstraintMaker</span> *make) &#123;</span><br><span class="line">    // 边界条件约束，保证内容可见，优先级<span class="number">1000</span></span><br><span class="line">    make.left.greaterThanOrEqualTo(<span class="name">_containerView.mas_left</span>)<span class="comment">;</span></span><br><span class="line">    make.right.lessThanOrEqualTo(<span class="name">_containerView.mas_right</span>)<span class="comment">;</span></span><br><span class="line">    make.top.greaterThanOrEqualTo(<span class="name">_containerView.mas_top</span>)<span class="comment">;</span></span><br><span class="line">    make.bottom.lessThanOrEqualTo(<span class="name">_containerView.mas_bottom</span>)<span class="comment">;</span></span><br><span class="line">    // ...</span><br><span class="line">&#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这个地方要注意是<code>lessThanOrEqualTo</code>还是<code>greaterThanOrEqualTo</code>。</p><h4 id="滑动时更新Tip位置"><a href="#滑动时更新Tip位置" class="headerlink" title="滑动时更新Tip位置"></a>滑动时更新Tip位置</h4><p>这一点比较简单，直接将当前触摸的坐标赋值给<code>leftConstraint</code>和<code>rightConstraint</code>就好：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">_leftConstraint.offset</span> = touchPoint.x<span class="comment">;</span></span><br><span class="line"><span class="attr">_topConstraint.offset</span> = touchPoint.y<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p>对比起来，明显是用Autolayout的方法比计算设置frame的方法要“优雅”的多=。=，灵活运用约束的优先级，往往可以减少很多工作量。</p><h2 id="Case-2-Autolayout的约束-控件间位置关系的“动态绑定”"><a href="#Case-2-Autolayout的约束-控件间位置关系的“动态绑定”" class="headerlink" title="Case 2: Autolayout的约束=控件间位置关系的“动态绑定”"></a>Case 2: Autolayout的约束=控件间位置关系的“动态绑定”</h2><h3 id="实现功能-1"><a href="#实现功能-1" class="headerlink" title="实现功能"></a>实现功能</h3><p>Case 2的功能其实是在Case 1的基础上实现的，就是在移动一个View的时候，另一个Attachment附件View，始终保持跟这个View的相对位置不变，就像是“附着”、“捆绑”在这个View上一样。</p><h3 id="关键概念：约束-“动态的绑定”"><a href="#关键概念：约束-“动态的绑定”" class="headerlink" title="关键概念：约束 = “动态的绑定”"></a>关键概念：约束 = “动态的绑定”</h3><p>之所以写这个例子，主要是想从概念上更加深入的理解Autolayout与传统的设置Frame的不同，即Autolayout里面的约束，其实是“动态的绑定”，是控件相互之间的位置关系绑定，约束是可以<strong>实时</strong>保证这种绑定关系的。</p><p>传统的设置Frame，在View的内容、位置要变化时，是要手动设置的，是“一次性”的，而Autolayout，在确定了约束后，会实时的用约束的规则去更新Frame，所以可以避免这种手动设置。</p><p>所以，对于本例子来说，设置Frame的方式和Autolayout的方式对比如下：</p><p><img src="/2016/08/06/autolayout-example-with-masonry4/blog_autolayout_example_with_masonry4_3.png" alt="Case 2: Autolayout的约束=控件间位置关系的“绑定”"></p><p>用Autolayout的话，只要把Attachment的位置设置为相对于TipLabel就可以了。</p><h3 id="实现细节-1"><a href="#实现细节-1" class="headerlink" title="实现细节"></a>实现细节</h3><p>代码比较简单，如下：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">attachmentView</span> mas_makeConstraints:^(<span class="name">MASConstraintMaker</span> *make) &#123;</span><br><span class="line">    // 依附在tipLabel上</span><br><span class="line">    make.left.equalTo(<span class="name">_tipLabel.mas_left</span>).with.offset(<span class="name">20</span>).priorityHigh()<span class="comment">;</span></span><br><span class="line">    make.bottom.equalTo(<span class="name">_tipLabel.mas_top</span>).with.offset(<span class="name">-2</span>).priorityHigh()<span class="comment">;</span></span><br><span class="line">&#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>移动Tip的相关代码看Case 1的就行~</p><h3 id="小节-1"><a href="#小节-1" class="headerlink" title="小节"></a>小节</h3><p>本小节的Case比较简单，主要是为了着重点出“Autolayout约束=动态位置绑定”这个点，理解了这一点，才能更好地运用Autolayout~</p><h2 id="Case-3-利用layoutIfNeeded控制约束的生效时机"><a href="#Case-3-利用layoutIfNeeded控制约束的生效时机" class="headerlink" title="Case 3: 利用layoutIfNeeded控制约束的生效时机"></a>Case 3: 利用layoutIfNeeded控制约束的生效时机</h2><h3 id="实现功能-2"><a href="#实现功能-2" class="headerlink" title="实现功能"></a>实现功能</h3><p>Case 3的例子，是一个灰色的View，初始时在屏幕中央，然后按下“执行动画”后，从左边滑入。</p><h3 id="步骤分析"><a href="#步骤分析" class="headerlink" title="步骤分析"></a>步骤分析</h3><p>直观上看，感觉是在按下按钮时，修改View的水平方向上的某个约束，然后用UIView的动画执行变化就好了。  </p><p>但是仔细分析，应该是先设置View的位置到屏幕的左边看不见的区域，然后用动画平滑的再让View移动回原位。</p><p>就是说，只是从左边移动回来时，才让动画生效！问题就变成了，如何让<strong>约束分段执行</strong>，或者说，<strong>控制约束的生效时机</strong>。</p><p>步骤可以由下图表示：</p><p><img src="/2016/08/06/autolayout-example-with-masonry4/blog_autolayout_example_with_masonry4_4.png" alt="Case 3: 利用layoutIfNeeded控制约束的生效时机"></p><h3 id="实现关键"><a href="#实现关键" class="headerlink" title="实现关键"></a>实现关键</h3><p>步骤分析清楚了，那么问题就是如何让约束在修改后，“立即”生效，而不是等到系统自动在下次更新布局时被动的生效。</p><p>答案就是：利用<strong><code>layoutIfNeeded</code></strong>  </p><p>在更改了约束后，调用<code>layoutIfNeeded</code>，就可以通知系统立即刷新布局，从而更新Frame。如果要更加“保险”，可以在调用<code>layoutIfNeeded</code>前，加上调用<code>setNeedsUpdateConstraints</code>、<code>setNeedsLayout</code>，系统刷新布局时，就会先更新约束，然后根据约束重新计算相关View的Frame，想了解具体的过程的，可以参考：<a href="https://developer.apple.com/videos/play/wwdc2015/218/" target="_blank" rel="noopener">Mysteries of Auto Layout, Part 1 - WWDC 2015</a>、<a href="https://developer.apple.com/videos/play/wwdc2015/219/" target="_blank" rel="noopener">Mysteries of Auto Layout, Part 2</a></p><h3 id="实现细节-2"><a href="#实现细节-2" class="headerlink" title="实现细节"></a>实现细节</h3><p>具体的实现代码如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置初始状态，移动View到屏幕左边不可见区域</span></span><br><span class="line"><span class="selector-tag">_centerXConstraint</span><span class="selector-class">.equalTo</span>(@(-CGRectGetWidth(self.view.frame)));</span><br><span class="line"><span class="comment">// 立即让约束生效,刷新Frame</span></span><br><span class="line"><span class="selector-attr">[self.view layoutIfNeeded]</span>;</span><br><span class="line"><span class="comment">// 设置要动画的约束，移回原位</span></span><br><span class="line"><span class="selector-tag">_centerXConstraint</span><span class="selector-class">.equalTo</span>(<span class="variable">@0</span>);</span><br><span class="line"><span class="comment">// 执行动画</span></span><br><span class="line"><span class="selector-attr">[UIView animateWithDuration:0.3f animations:^&#123;</span></span><br><span class="line"><span class="selector-attr">    [self.view layoutIfNeeded]</span>; </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="小节-2"><a href="#小节-2" class="headerlink" title="小节"></a>小节</h3><p>之前在实现<a href="https://github.com/zekunyan/TTGSnackbar" target="_blank" rel="noopener">TTGSnackbar</a>的时候，就大量的使用了<code>layoutIfNeeded</code>来立即刷新View的Frame，然后才让产生动画的约束变动生效，也就是分阶段的让约束生效，非常管用~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不知不觉已经第四篇了，一共12个Case，都是平时开发时总结出来的点，以及对Autolayout的理解，希望可以一直将这个系列坚持下去~~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;第四篇来了。&lt;br&gt;还是3个小例子，仍然是主要部分用Masonry手写代码实现，其它的约束在storyboard里面直接拖拽搭建。&lt;br&gt;三个例子分别是：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用约束优先级保证可移动View的内容可见&lt;/li&gt;
&lt;li&gt;Autolayout的约束=控件间位置关系的“绑定”&lt;/li&gt;
&lt;li&gt;利用&lt;code&gt;layoutIfNeeded&lt;/code&gt;控制约束的生效时机&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;前三篇：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一篇：&lt;a href=&quot;http://tutuge.me/2015/05/23/autolayout-example-with-masonry/&quot;&gt;有趣的Autolayout示例-Masonry实现&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;第二篇：&lt;a href=&quot;http://tutuge.me/2015/08/08/autolayout-example-with-masonry2/&quot;&gt;有趣的Autolayout示例2-Masonry实现&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;第三篇：&lt;a href=&quot;http://tutuge.me/2015/12/14/autolayout-example-with-masonry3/&quot;&gt;有趣的Autolayout示例3-Masonry实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Github地址：&lt;br&gt;&lt;a href=&quot;https://github.com/zekunyan/AutolayoutExampleWithMasonry&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/zekunyan/AutolayoutExampleWithMasonry&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2016/08/06/autolayout-example-with-masonry4/blog_autolayout_example_with_masonry4_1.gif&quot; alt=&quot;Gif示例&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="Autolayout" scheme="http://tutuge.me/tags/Autolayout/"/>
    
      <category term="Masonry" scheme="http://tutuge.me/tags/Masonry/"/>
    
  </entry>
  
  <entry>
    <title>翻译-为什么objc_msgSend必须用汇编实现</title>
    <link href="http://tutuge.me/2016/06/19/translation-why-objcmsgsend-must-be-written-in-assembly/"/>
    <id>http://tutuge.me/2016/06/19/translation-why-objcmsgsend-must-be-written-in-assembly/</id>
    <published>2016-06-18T16:19:23.000Z</published>
    <updated>2018-10-07T17:37:28.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="译者前言"><a href="#译者前言" class="headerlink" title="译者前言"></a>译者前言</h2><p>总是看到有人说用汇编实现<code>objc_msgSend</code>是为了速度快，当然这个不可否认。但是难道没有别的原因？于是就看到了这篇文章，遂翻译之！=。=  </p><p>我自己的理解就是，用汇编实现，是为了应对不同的“<a href="https://en.wikipedia.org/wiki/Calling_convention" target="_blank" rel="noopener">Calling convention</a>”，把函数调用前的栈和寄存器的参数、状态设置，交给编译器去处理。<br>先看看原文吧。</p><blockquote><p>原作者: <a href="https://www.linkedin.com/in/ari-grant-789a1015" target="_blank" rel="noopener">Ari Grant</a><br>原文链接: <a href="http://arigrant.com/blog/2014/2/12/why-objcmsgsend-must-be-written-in-assembly" target="_blank" rel="noopener">Why objc_msgSend Must be Written in Assembly</a></p></blockquote><a id="more"></a><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>对于Objective-C来说，调用一个对象实例的方法，也叫作向这个对象实例<strong>“发送消息”</strong>，而每条“消息”，在编译阶段都会转变为一次对<code>objc_msgSend</code>函数的调用，调用的参数不仅有原本消息的所有参数，还有消息的接收者<code>receiver</code>和对应的方法<code>selector</code>。举个例子，下面的语句：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[receiver <span class="string">message:</span>foo <span class="string">beforeDate:</span>bar];</span><br></pre></td></tr></table></figure><p>将会被编译成：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">objc_msgSend</span>(receiver, <span class="variable">@selector</span>(<span class="attribute">message</span>:<span class="attribute">beforeDate</span>:), foo, bar);</span><br></pre></td></tr></table></figure><p>对于<code>objc_msgSend</code>函数的实现原理，前人已经做了大量的探索。所以，本文将会把重点放在<code>objc_msgSend</code>的一个之前没有太受到关注的点上，那就是：</p><p><strong><code>objc_msgSend</code>是不可能用Objective-C、C或者C++实现的。</strong></p><h2 id="THE-RETURN-TYPE-返回类型"><a href="#THE-RETURN-TYPE-返回类型" class="headerlink" title="THE RETURN TYPE - 返回类型"></a>THE RETURN TYPE - 返回类型</h2><p>先看看如下两行代码： </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">NSUInteger n</span> = [array count];</span><br><span class="line"><span class="attribute">id obj</span> = [array objectAtIndex:6];</span><br></pre></td></tr></table></figure><p>直观上看，将会被编译成：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSUInteger n = objc_msgSend(<span class="name">array</span>,  @selector(<span class="name">count</span>))<span class="comment">;</span></span><br><span class="line">id obj = objc_msgSend(<span class="name">array</span>, @selector(<span class="name">objectAtIndex</span>:), <span class="number">6</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>但是实际上这是不可能的，因为没有函数可以同时满足这两个调用。而且它的返回值也不能同时是<code>NSUInteger</code>和<code>id</code>。</p><p>而且，上面的代码也是无法编译通过的。那么，加上类型转换怎么样？</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSUInteger n = (<span class="name">NSUInteger</span> (<span class="name">*</span>)(<span class="name">id</span>, SEL))objc_msgSend(<span class="name">array</span>,  @selector(<span class="name">count</span>))<span class="comment">;</span></span><br><span class="line">id obj = (<span class="name">id</span> (<span class="name">*</span>)(<span class="name">id</span>, SEL, NSUInteger))objc_msgSend(<span class="name">array</span>, @selector(<span class="name">objectAtIndex</span>:), <span class="number">6</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这下可以编译通过了，虽然看起来不直观。。。  </p><p><code>objc_msgSend</code>是一个Public的函数，在<code>&lt;objc/message.h&gt;</code>里声明，如果你想直接调用它，就必须按照上面的格式加上强制类型转换，要不然是无法编译通过的。但是<code>objc_msgSend</code>到底是如何实现，来支持各种返回类型的？本文后面会讲到。</p><h2 id="THE-IMP-方法对应的函数指针"><a href="#THE-IMP-方法对应的函数指针" class="headerlink" title="THE IMP - 方法对应的函数指针"></a>THE IMP - 方法对应的函数指针</h2><p><code>objc_msgSend</code>函数的本质很简单，传入一个接受者对象实例<code>receiver</code>和方法名<code>selector</code>，它就会按照以下步骤执行：（译者注：只是最粗略的步骤=。=）</p><ul><li>获取<code>receiver</code>得类Class</li><li>在Class的方法列表method table里面查找对应<code>selector</code>的方法实现</li><li>找到的话就调用，返回</li><li>找不到就在其父类中找，重复前面的步骤（直到没有父类为止）</li></ul><p>整个流程很简单，沿着继承链，向上找到方法<code>selector</code>对应的函数指针即可，也就是<code>IMP</code>。同时，在每层Class中都有缓存，加快后续的方法查找。但是，这也只是<code>objc_msgSend</code>的实现细节，所以，接着往下看。</p><h2 id="THE-ARG-TYPES-AND-COUNT-参数类型和数量"><a href="#THE-ARG-TYPES-AND-COUNT-参数类型和数量" class="headerlink" title="THE ARG TYPES AND COUNT - 参数类型和数量"></a>THE ARG TYPES AND COUNT - 参数类型和数量</h2><p>简单来说，当<code>objc_msgSend</code>找到对应的函数指针后，只要用传入的参数调用这个函数即可。剩下来的就是找到一种方法，可以调用任意参数类型、数量的任意函数。  </p><p>参数的数量很容易计算。然后我们可以把所有的参数都放入<code>varargs</code>，然后调用函数时传入即可。但是这样的话，每个Objective-C的方法都必须在其<code>prologue</code>（译者注：函数执行具体的“任务”前，所做的准备环节）里面把所有的参数从<code>varargs</code>里面提取出来。  </p><p>这种把参数打包到<code>varargs</code>里面然后又取出来的办法显然是非常糟糕的，同时也是不必要的。</p><p>在C语言中，调用一个函数会被编译成对应的汇编语言指令，首先是设置参数（把参数放到寄存器、栈上），然后用如<code>jump</code>或者<code>call</code>的指令，跳到具体的函数代码地址处。如果我们想支持任意类型的函数类型，我们就必须写一个<code>switch</code>语句，把所有的参数组合情况都包含起来，这样才能正确的为任何形式的函数设置参数（译者注：即按照某种<strong>“规范”、“约定”</strong>，把参数依次存放到“约定”的寄存器、栈上），这显然是没有扩展性的，更是不可能的。</p><h2 id="UNWINDING-THE-CALL-拆解调用"><a href="#UNWINDING-THE-CALL-拆解调用" class="headerlink" title="UNWINDING THE CALL - 拆解调用"></a>UNWINDING THE CALL - 拆解调用</h2><p><code>objc_msgSend</code>的解决办法，主要依据的是：<strong>当objc_msgSend被调用时，所有的参数已经被设置好了</strong>。  </p><p>换一种方式来说，就是：<strong>在objc_msgSend开始执行时，栈帧（stack frame）的状态、数据，和各个寄存器的组合形式、数据，跟调用具体的函数指针（IMP）时所需的状态、数据，是完全一致的！</strong></p><p>如下这行代码：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id obj = objc_msgSend(<span class="name">array</span>, @selector(<span class="name">objectAtIndex</span>:), <span class="number">6</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>在调用<code>objc_msgSend</code>时，需要设置三个参数，分别是被调用方<code>receiver</code>、方法名<code>selector</code>和最后一个整型参数6。这和具体的方法函数IMP的参数顺序、类型是完全一致的，也就是说，<strong>调用<code>objc_msgSend</code>前，设置的栈、寄存器的状态、数据正是调用具体的方法函数时需要的状态！</strong>  </p><p>所以，当<code>objc_msgSend</code>找到要调用的函数实现IMP后，只需要把所有的对栈、寄存器的操作“倒”回到<code>objc_msgSend</code>执行开始的状态（类似于函数执行完成return返回前，做的“收尾处理”工作一样，即epilogue），直接<code>jump/call</code>到IMP函数指针对应的地址，执行指令即可，因为所有的参数已经被设置好了。</p><p>同时，当<code>selector</code>对应的IMP执行完成后，返回值也被正确的设置好了（在x86平台上，返回值被设置到了指定的寄存器<code>eax/rax</code>里，在arm上，则是<code>r0</code>寄存器），所以，我们也不必担心前文提到的不同类型的返回值问题了。</p><h2 id="WRAP-UP-总结"><a href="#WRAP-UP-总结" class="headerlink" title="WRAP UP - 总结"></a>WRAP UP - 总结</h2><p>把上面提到的所有解释综合起来，就是：在C语言里面调用函数，必须在编译时就知道调用的“状态”；而这些“状态”在运行时是无法得出或正确处理的，所以必须往底层走，用汇编处理。（译者注：这里不知道咋翻译好=。=，原文是：calling a function in C requires the signature to be known for each call-site at compile-time；doing so at run-time is not possible and so one must drop down into assembly and party there instead.）</p><h2 id="UPDATE-后续"><a href="#UPDATE-后续" class="headerlink" title="UPDATE - 后续"></a>UPDATE - 后续</h2><p>有人指出<code>objc_msgSend</code>有可能是用GCC的扩展方法<code>__builtin_apply_args</code>，<code>__builtin_apply</code>，和<code>__builtin_return</code>实现的。这也正指出了一个事实，就是这些builtins方法是非常有必要的，因为单靠语言本身无法实现这些功能。实现<code>objc_msgSend</code>所需要的技巧，也正是实现这些builtins方法所需要的技巧。本文的目的并不是非要将什么是真正的C、什么不是真正的C分个清楚，只是为了指出<code>objc_msgSend</code>特殊罢了。</p><h2 id="译者总结"><a href="#译者总结" class="headerlink" title="译者总结"></a>译者总结</h2><p>开头也说了，我的理解是：用汇编实现，是为了应对不同的“<a href="https://en.wikipedia.org/wiki/Calling_convention" target="_blank" rel="noopener">Calling convention</a>”，把函数调用前的栈和寄存器的参数、状态设置，交给编译器去处理。  </p><p>嗯，以后不要再说用汇编实现只是为了快了=。=</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;译者前言&quot;&gt;&lt;a href=&quot;#译者前言&quot; class=&quot;headerlink&quot; title=&quot;译者前言&quot;&gt;&lt;/a&gt;译者前言&lt;/h2&gt;&lt;p&gt;总是看到有人说用汇编实现&lt;code&gt;objc_msgSend&lt;/code&gt;是为了速度快，当然这个不可否认。但是难道没有别的原因？于是就看到了这篇文章，遂翻译之！=。=  &lt;/p&gt;
&lt;p&gt;我自己的理解就是，用汇编实现，是为了应对不同的“&lt;a href=&quot;https://en.wikipedia.org/wiki/Calling_convention&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Calling convention&lt;/a&gt;”，把函数调用前的栈和寄存器的参数、状态设置，交给编译器去处理。&lt;br&gt;先看看原文吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原作者: &lt;a href=&quot;https://www.linkedin.com/in/ari-grant-789a1015&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ari Grant&lt;/a&gt;&lt;br&gt;原文链接: &lt;a href=&quot;http://arigrant.com/blog/2014/2/12/why-objcmsgsend-must-be-written-in-assembly&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Why objc_msgSend Must be Written in Assembly&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="翻译" scheme="http://tutuge.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>API返回结果设计经验与总结</title>
    <link href="http://tutuge.me/2016/05/02/design-json-api-respoense/"/>
    <id>http://tutuge.me/2016/05/02/design-json-api-respoense/</id>
    <published>2016-05-02T02:44:49.000Z</published>
    <updated>2018-10-07T17:37:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RESTful API的设计已经很成熟了，大家也都比较认可。本文也不再过多介绍RESTful API相关的知识，而是针对JSON型API的返回结果设计，总结下自己的经验。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>先来看看返回结果的结构示例：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">data </span>: &#123; <span class="comment">// 请求数据，对象或数组均可</span></span><br><span class="line">        <span class="attribute">user_id</span>: <span class="number">123</span>,</span><br><span class="line">        <span class="attribute">user_name</span>: <span class="string">"tutuge"</span>,</span><br><span class="line">        <span class="attribute">user_avatar_url</span>: <span class="string">"http://tutuge.me/avatar.jpg"</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attribute">msg </span>: <span class="string">"done"</span>, <span class="comment">// 请求状态描述，调试用</span></span><br><span class="line">    <span class="attribute">code</span>: <span class="number">1001</span>, <span class="comment">// 业务自定义状态码</span></span><br><span class="line">    <span class="attribute">extra </span>: &#123; <span class="comment">// 全局附加数据，字段、内容不定</span></span><br><span class="line">        <span class="attribute">type</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attribute">desc</span>: <span class="string">"签到成功！"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="data字段-请求数据"><a href="#data字段-请求数据" class="headerlink" title="data字段 - 请求数据"></a>data字段 - 请求数据</h3><p>首先是本次请求结果的数据<code>data</code>字段，其值为对象（字典）或数组均可以，根据业务而定。</p><p>如请求的是某个用户的个人profile信息，就可以是对象，对象里面是用户profile的键值对数据，如<code>user_id: 123</code>、<code>user_name: &quot;tutuge&quot;</code>等。</p><p>如果请求的是列表数据，就可以是数组，如请求用户列表：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">data:</span> [</span><br><span class="line">    &#123;<span class="string">user_id:</span> <span class="number">123</span>, <span class="string">user_name:</span> <span class="string">"tutuge"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">user_id:</span> <span class="number">321</span>, <span class="string">user_name:</span> <span class="string">"zekunyan"</span>&#125;,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>数组、对象，相互嵌套，灵活组合即可。</p><p>对于iOS来说，解析<code>data</code>字段是对象还是数组也很容易，在接收到JSON数据字典后，如AFNetworking的返回结果，对<code>data</code>判断其类型即可：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([jsonDict[@<span class="string">"data"</span>] <span class="string">isKindOfClass:</span>[NSDictionary <span class="class"><span class="keyword">class</span>]]) &#123;</span></span><br><span class="line">    <span class="comment">// JSON对象</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([jsonDict[@<span class="string">"data"</span>] <span class="string">isKindOfClass:</span>[NSArray <span class="class"><span class="keyword">class</span>]]) &#123;</span></span><br><span class="line">    <span class="comment">// JSON数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="msg字段-请求状态描述，调试用"><a href="#msg字段-请求状态描述，调试用" class="headerlink" title="msg字段 - 请求状态描述，调试用"></a>msg字段 - 请求状态描述，调试用</h3><p><code>msg</code>字段是本次请求的业务、状态描述信息，主要用于调试、测试等。</p><p>如“done”、“请求缺少参数！”</p><p>服务端可以自由发挥，开发人员看得懂就好。 -_-|||</p><h3 id="code字段-业务自定义状态码"><a href="#code字段-业务自定义状态码" class="headerlink" title="code字段 - 业务自定义状态码"></a>code字段 - 业务自定义状态码</h3><p><code>code</code>字段，业务自定义的状态码。</p><p>其实是否要在API里面自定义业务状态码，<strong>非常有争议</strong>=。=，因为Http请求本身已经有了完备的状态码，再定义一套状态码直观上感受却是不对劲。但是实际开发中，确实发现自定义业务状态码的必要性，如一次成功的Http status 200的请求，可能由于用户未登录、登录过期而有不同的返回结果和处理方式，所以还是保留了<code>code</code>。</p><p>状态码的定义也最好有一套规范，如按照用户相关、授权相关、各种业务，做简单的分类：</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Code 业务自定义状态码定义示例</span><br><span class="line"></span><br><span class="line">// 授权相关</span><br><span class="line"><span class="attribute">1001</span>: 无权限访问</span><br><span class="line"><span class="attribute">1002</span>: access_token过期</span><br><span class="line"><span class="attribute">1003</span>: unique_token无效</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// 用户相关</span><br><span class="line"><span class="attribute">2001</span>: 未登录</span><br><span class="line"><span class="attribute">2002</span>: 用户信息错误</span><br><span class="line"><span class="attribute">2003</span>: 用户不存在</span><br><span class="line"></span><br><span class="line">// 业务1</span><br><span class="line"><span class="attribute">3001</span>: 业务1XXX</span><br><span class="line"><span class="attribute">3002</span>: 业务1XXX</span><br><span class="line"></span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p><code>Code</code>业务状态码最好是用常量定义的，当然有能力的动态配置更新更好，这里就不再详细说明。</p><p>Http的状态码参考：<a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank" rel="noopener">List of HTTP status codes</a></p><h3 id="extra字段-全局附加数据"><a href="#extra字段-全局附加数据" class="headerlink" title="extra字段 - 全局附加数据"></a>extra字段 - 全局附加数据</h3><p><code>extra</code>字段，用来表示全局的附加数据。</p><p>这个字段来源于之前做项目时，用户的操作（数据请求），会导致用户的等级、经验变化，而具体什么时候产生不确定，由服务端的规则决定，并且客户端要及时向用户展示变化，所以加上了<code>extra</code>字段。</p><p>在设计<code>extra</code>字段的时候，并没有对其结构内容做限制，所以比较灵活，但是还是要有个<code>type</code>字段，来做约束，如：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 升级</span></span><br><span class="line"><span class="symbol">type:</span> <span class="number">1</span>,</span><br><span class="line"><span class="symbol">show_msg:</span> <span class="string">"恭喜您升级到XXX"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成任务</span></span><br><span class="line"><span class="symbol">type:</span> <span class="number">2</span>,</span><br><span class="line"><span class="symbol">task_desc:</span> <span class="string">"达成XXX成就"</span></span><br></pre></td></tr></table></figure><p>总的来说就是自由发挥，只要服务端、客户端相互沟通好即可。当然，也要避免乱用，保证真的需要全局附加数据才使用这个字段。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>总结几点最佳实践。</p><h3 id="规范统一的命名"><a href="#规范统一的命名" class="headerlink" title="规范统一的命名"></a>规范统一的命名</h3><p><strong>命名风格统一</strong></p><p>不管是驼峰式还是下划线式，统一就好。当然，按照目前的“大众规范”，还是统一小写加下划线比较好=。=<br>如：<code>user_id</code>，<code>user_name</code>，<code>user_age</code>等。</p><p><strong>语义清晰，遵守常用缩写</strong></p><p>字段的名字最好能体现字段的类型，遵守一些“常用”的缩写，如：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">user<span class="number">_n</span>ame, task<span class="number">_</span>desc, date<span class="number">_</span>str, article<span class="number">_</span>title, feed<span class="number">_</span>content 等</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字</span></span><br><span class="line">user<span class="number">_</span>id, users<span class="number">_</span>count, task<span class="number">_n</span>um, xxx<span class="number">_</span>offset 等</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日期</span></span><br><span class="line">login<span class="number">_</span>at, create<span class="number">_</span>date, logout<span class="number">_</span>time 等</span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔</span></span><br><span class="line"><span class="keyword">is</span><span class="number">_</span>done, <span class="keyword">is</span><span class="number">_</span>vip, protected, can<span class="number">_</span>read 等</span><br><span class="line"></span><br><span class="line"><span class="comment">// URL</span></span><br><span class="line">user<span class="number">_</span>avatar<span class="number">_u</span>rl, thumb<span class="number">_u</span>rl 等</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line">users, profiles, thumb<span class="number">_</span>imgs 等</span><br></pre></td></tr></table></figure><h3 id="空值、空字段的处理"><a href="#空值、空字段的处理" class="headerlink" title="空值、空字段的处理"></a>空值、空字段的处理</h3><p>空值、空字段的处理也是比较容易出问题。</p><p><strong>统一空值用null</strong></p><p>除了布尔类型的，其余的空值统一用<code>null</code>表示，客户端保证每种字段的<code>null</code>可以被正常处理。</p><p><strong>给不同类型设置默认空值</strong></p><p>除了<code>null</code>，还可以对字段设置“默认值”，如数字就是<code>0</code>，字符串就是空字符串<code>&quot;&quot;</code>，数组就是空数组<code>[]</code>，对象就是空对象<code>{}</code>，这样有个好处就是可以避免很多客户端（Java、OC）处理空值（Null、nil、null）产生的异常。但是危害就是容易语义不明。还是要根据具体业务、前后端约定而定。</p><p>以前写过一篇<a href="http://tutuge.me/2015/07/08/fill-nil-property-of-object/">用Runtime的手段填充任意NSObject对象的nil属性</a>，其实就是为对象空值统一设置默认值的=。=，可以参考。</p><h3 id="布尔boolean值的处理"><a href="#布尔boolean值的处理" class="headerlink" title="布尔boolean值的处理"></a>布尔boolean值的处理</h3><p>说实话，我见过各种布尔值表示方式，如：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">is_login:</span> <span class="literal">true</span>,</span><br><span class="line"><span class="string">is_login:</span> <span class="string">"true"</span>,</span><br><span class="line"><span class="string">is_login:</span> <span class="number">1</span></span><br><span class="line"><span class="string">is_login:</span> <span class="string">"TRUE"</span></span><br><span class="line"><span class="string">is_login:</span> <span class="string">"YES"</span></span><br><span class="line"><span class="comment">// ...天啊</span></span><br></pre></td></tr></table></figure><p>由于语言本身的限制、框架的处理方式，不对布尔类型的值做限制总觉得不踏实，像C、C++、Objective-C里面的布尔就是数字0和1，其它语言也都各自不一样，还有从数据库读写导致的布尔值类型不一致等。</p><p>所以，如果可以的话，最好一开始就对所有请求参数、结果的布尔值类型做限定，个人觉得<strong>统一成数字0和1</strong>最好。</p><p>然后在客户端和服务端统一设置常量、宏定义，定义布尔的类型，所有的参数、结果的布尔字段全部做强制约束。</p><h3 id="时间、日期字段"><a href="#时间、日期字段" class="headerlink" title="时间、日期字段"></a>时间、日期字段</h3><p>时间的处理也是非常容易出错的，特别是遇上时区转换的时候。</p><p><strong>强制GMT/UTC时间戳</strong></p><p>一种做法就是强制所有时间参数只能传Unix时间戳，也就是标准GMT/UTC时间戳，然后由各自的客户端根据自己的时区、显示要求做处理后显示。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从服务器接收的时间数据</span></span><br><span class="line"><span class="symbol">login_at:</span> <span class="number">1462068610</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据时区、显示要求转换，如北京时间</span></span><br><span class="line">显示：<span class="number">2016</span>年<span class="number">5</span>月<span class="number">1</span>日下午<span class="number">1</span>点、<span class="number">1</span>天前等</span><br></pre></td></tr></table></figure><p>这样的话，客户端、服务端存储、读取时间都相当于处理纯数字。</p><p><strong>使用ISO 8601带时区的时间日期字符串</strong></p><p>使用Unix时间戳有个坏处，就是：</p><ul><li>最早只能到<code>1970/1/1 0:0:0</code>GMT时间，一旦需求早于这个时间，时间戳就成了负数=。=</li><li>不方便人阅读。调试API的时候，开发人员不能直观看出具体时间，很不方便</li></ul><p>所以，可以按照<a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank" rel="noopener">ISO 8601</a>标准，用字符串保存、传输时间。</p><p>如果以<code>YYYY-MM-DDThh:mm:ssTZD</code>格式为准, 时间的形式就是<code>1997-07-16T19:20:30+01:00</code>，保存了时区信息，也方便阅读。</p><h3 id="type类型的处理"><a href="#type类型的处理" class="headerlink" title="type类型的处理"></a>type类型的处理</h3><p>API数据中免不了各种类型字段，如用户类型<code>user_type</code>、登录类型<code>login_type</code>等，类型的表示也可以分为数字、字符串两种。</p><p><strong>数字表示类型</strong></p><p>这个应该是最直接的方式了，客户端和服务端共同维护某个API下、某个数据类型中的type常量，靠文档约束。</p><p><strong>字符串表示类型</strong></p><p>数字的类型毕竟不利于直观阅读，如果可以的话，用字符串也是不错的，当然坏处就是代码里面就不能用<code>Switch</code>语句了（除了强大的Swift=。=）</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如登录类型，QQ、微信、微博等</span></span><br><span class="line"><span class="symbol">login_type:</span> <span class="string">"qq"</span>,</span><br><span class="line"><span class="symbol">login_type:</span> <span class="string">"wechat"</span>,</span><br><span class="line"><span class="symbol">login_type:</span> <span class="string">"sina_weibo"</span>,</span><br></pre></td></tr></table></figure><h3 id="完整的URL"><a href="#完整的URL" class="headerlink" title="完整的URL"></a>完整的URL</h3><p>API里面的数据也会有URL类型的，一般来说如用户的头像、各种图片、音频等资源，都是以URL链接的形式返回的。</p><p>返回的URL一定要“完整”，主要指的是不要忘记URL里面的<strong>协议</strong>部分，也就是<code>scheme</code>部分。</p><p>像<code>tutuge.me/imgs/1.jpg</code>这种URL值，就是不完整的，没有指明网络协议，难道靠猜=。=<br>应该是<code>http://tutuge.me/imgs/1.jpg</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>嗯，规范非常重要。:-D</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;RESTful API的设计已经很成熟了，大家也都比较认可。本文也不再过多介绍RESTful API相关的知识，而是针对JSON型API的返回结果设计，总结下自己的经验。&lt;/p&gt;
&lt;h2 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; title=&quot;结构&quot;&gt;&lt;/a&gt;结构&lt;/h2&gt;&lt;p&gt;先来看看返回结果的结构示例：&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;data &lt;/span&gt;: &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 请求数据，对象或数组均可&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attribute&quot;&gt;user_id&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attribute&quot;&gt;user_name&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;tutuge&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attribute&quot;&gt;user_avatar_url&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;http://tutuge.me/avatar.jpg&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;msg &lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;done&quot;&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 请求状态描述，调试用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;code&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1001&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 业务自定义状态码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;extra &lt;/span&gt;: &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 全局附加数据，字段、内容不定&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attribute&quot;&gt;type&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attribute&quot;&gt;desc&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;签到成功！&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="服务端" scheme="http://tutuge.me/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>结合访问Out Parameters出现EXC_BAD_ACCESS的例子，反编译汇编解读__autoreleasing</title>
    <link href="http://tutuge.me/2016/04/30/autoreleasing-meet-autoreleasepool/"/>
    <id>http://tutuge.me/2016/04/30/autoreleasing-meet-autoreleasepool/</id>
    <published>2016-04-30T11:19:23.000Z</published>
    <updated>2018-10-07T17:37:29.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>2016-05-01: 补充了一点本文涉及的汇编知识</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文结合一段访问<code>Out Parameters</code>出现了<code>EXC_BAD_ACCESS</code>错误的代码，通过反编译等手段验证Objective-C中<code>__autoreleasing</code>的一些特点。</p><a id="more"></a><h2 id="2016-05-01更新-关于本文的反编译汇编代码"><a href="#2016-05-01更新-关于本文的反编译汇编代码" class="headerlink" title="2016-05-01更新 - 关于本文的反编译汇编代码"></a>2016-05-01更新 - 关于本文的反编译汇编代码</h2><p>本文的反编译基于MachO 64bits，即System V X86_64，读懂本文需要的最简单Calling convention如下：</p><p>函数参数顺序：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rdi, rsi, rdx, rcx等寄存器</span><br><span class="line">对应到</span><br><span class="line">id objc_msgSend ( id object, SEL cmd, arg1, arg2 ... );</span><br><span class="line">就是</span><br><span class="line">rdi = object <span class="comment"># 被调用对象</span></span><br><span class="line">rsi = cmd <span class="comment"># 方法selector</span></span><br><span class="line">rdx = arg1 <span class="comment"># 方法第一个参数</span></span><br><span class="line">rcx = arg2 <span class="comment"># 方法第二个参数</span></span><br></pre></td></tr></table></figure><p>函数返回值：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">本文只涉及: rax寄存器</span></span><br></pre></td></tr></table></figure><p>详细可参考：</p><ul><li><a href="https://developer.apple.com/library/ios/documentation/Xcode/Conceptual/iPhoneOSABIReference/Introduction/Introduction.html" target="_blank" rel="noopener">iOS ABI Function Call Guide</a></li><li><a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/LowLevelABI/000-Introduction/introduction.html#//apple_ref/doc/uid/TP40002437-SW1" target="_blank" rel="noopener">OS X ABI Function Call Guide</a></li><li><a href="http://wiki.osdev.org/Calling_Conventions" target="_blank" rel="noopener">OS DEV Calling Conventions</a></li></ul><h2 id="Out-Parameters-指针的指针"><a href="#Out-Parameters-指针的指针" class="headerlink" title="Out Parameters - 指针的指针"></a>Out Parameters - 指针的指针</h2><p>所谓<code>Out Parameters</code>，其实就是<strong>指针的指针</strong>，熟悉C/C++的朋友应该不陌生，通过指针的指针可以改变指针的值，在Objective-C里面很多地方用到了这种方法，来在函数、方法内部改变参数的原始值，如：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSFileManager的方法</span></span><br><span class="line">- (<span class="keyword">BOOL</span>)removeItemAtURL:(NSURL *)URL <span class="built_in">error</span>:(NSError **)<span class="built_in">error</span></span><br></pre></td></tr></table></figure><p>第二个参数<code>(NSError **)error</code>，就是<code>Out Parameters</code>，调用时传递NSError类型指针的地址即可：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSError *<span class="built_in">error</span> = nil;</span><br><span class="line">[[NSFileManager defaultManager] removeItemAtURL:url <span class="built_in">error</span>:&amp;<span class="built_in">error</span>];</span><br><span class="line">// 处理<span class="built_in">error</span>...</span><br></pre></td></tr></table></figure><h2 id="出现EXC-BAD-ACCESS的代码示例"><a href="#出现EXC-BAD-ACCESS的代码示例" class="headerlink" title="出现EXC_BAD_ACCESS的代码示例"></a>出现EXC_BAD_ACCESS的代码示例</h2><p>假设有如下遍历数组检查数值零的方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)checkZeroInArray:(<span class="built_in">NSArray</span> &lt;<span class="built_in">NSNumber</span> *&gt; *)array error:(<span class="built_in">NSError</span> **)error &#123;</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    [array enumerateObjectsUsingBlock:^(<span class="built_in">NSNumber</span> * _Nonnull number, <span class="built_in">NSUInteger</span> index, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (number.integerValue == <span class="number">0</span>) &#123; <span class="comment">// 检查</span></span><br><span class="line">            <span class="keyword">if</span> (error) &#123; <span class="comment">// 指针是否有效</span></span><br><span class="line">                *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"me.tutuge"</span> code:<span class="number">100</span> userInfo:<span class="literal">nil</span>]; <span class="comment">// 创建NSError实例</span></span><br><span class="line">            &#125;</span><br><span class="line">            *stop = <span class="literal">TRUE</span>; <span class="comment">// 停止遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的时候如下：</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSError</span> *<span class="keyword">error</span> = nil;</span><br><span class="line">[self checkZeroInArray:numbers <span class="keyword">error</span>:&amp;<span class="keyword">error</span>]; <span class="comment">// 取地址</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">error</span>) &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">"Error: %@"</span>, <span class="keyword">error</span>); <span class="comment">// EXC_BAD_ACCESS错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得出，<code>NSLog(@&quot;Error: %@&quot;, error)</code>访问<code>error</code>的时候，<code>error</code>的地址指向的内存空间已经被释放，所以才会出现<code>EXC_BAD_ACCESS</code>错误。</p><p>但是为什么会被释放？什么时候被释放的？经过一番查证，发现跟<code>__autoreleasing</code>和<code>@autoreleasepool</code>有关。</p><p>下面先对<code>__autoreleasing</code>做点研究=。=</p><h2 id="autoreleasing-变量所有权-ownership-修饰符"><a href="#autoreleasing-变量所有权-ownership-修饰符" class="headerlink" title="__autoreleasing - 变量所有权(ownership)修饰符"></a>__autoreleasing - 变量所有权(ownership)修饰符</h2><p>先看看<code>__autoreleasing</code>的定义及一些特点。</p><p><code>__autoreleasing</code>是变量所有权修饰符的一种，除了它，还有<code>__strong</code>、<code>__weak</code>和<code>__unsafe_unretained</code>，详细的说明可以参考：<a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#ownership-qualification" target="_blank" rel="noopener">Clang文档-Objective-C Automatic Reference Counting (ARC)</a></p><p>简单来说，就是被<code>__autoreleasing</code>修饰的变量会被加入到当前的autoreleasepool中，可以理解为如下两段分别在ARC和MRC中的代码等价：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ARC</span></span><br><span class="line"><span class="keyword">id</span> __autoreleasing obj = someObj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MRC</span></span><br><span class="line"><span class="keyword">id</span> obj = [[someObj <span class="keyword">retain</span>] autorelease];</span><br></pre></td></tr></table></figure><p>再进一步，除开各种影响因素，假设有如下函数：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)funcWithObj:(<span class="keyword">id</span>)someObj &#123;</span><br><span class="line">    <span class="keyword">id</span> __autoreleasing obj = someObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用Hopper Disassembler反编译后为如下汇编代码(MachO 64bits)：</p><p><img src="/2016/04/30/autoreleasing-meet-autoreleasepool/autoreleasing-meet-autoreleasepool_1.jpg" alt="funcWithObj:反汇编"></p><p><strong><code>var_18</code>就是obj变量：</strong></p><p><code>lea rax, qword [ss:rbp+var_18]</code>和<code>mov rdi, rax</code>取了var_18的地址放在<code>rdi</code>寄存器中，<code>mov rsi, rdx</code>将<code>someObj</code>值放到了rsi寄存器中，然后调用<code>id objc_storeStrong(id *object, id value)</code>函数最终将<code>someObj</code>值保存在<code>var_18</code>变量中。</p><p><strong><code>__autoreleasing</code>导致了<code>id objc_retainAutorelease(id value)</code>函数的调用：</strong></p><p><code>call imp___stubs__objc_retainAutorelease</code>，就是对<code>obj</code>变量，也就是<code>var_18</code>，调用了<code>objc_retainAutorelease</code>函数，先retain然后autorelease了一次，其实现大致如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_retainAutorelease</span>(<span class="params">id <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> objc_autorelease(objc_retain(<span class="keyword">value</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>objc_storeStrong</code>和<code>objc_retainAutorelease</code>可参考：<a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-retainautorelease" target="_blank" rel="noopener">Clang文档-Objective-C Automatic Reference Counting (ARC)</a></p><p>可验证，用<code>__autoreleasing</code>修饰的变量会被添加到当前的autoreleasepool中。</p><h2 id="方法的Out-Parameters参数会自动添加-autoreleasing属性"><a href="#方法的Out-Parameters参数会自动添加-autoreleasing属性" class="headerlink" title="方法的Out Parameters参数会自动添加__autoreleasing属性"></a>方法的Out Parameters参数会自动添加__autoreleasing属性</h2><p>当方法参数里面有Out Parameters参数时，就是有指针的指针类型时，编译器会自动为参数加上<code>__autoreleasing</code>属性，如以下两个方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)generateError1:(NSError **)<span class="keyword">error</span> &#123;</span><br><span class="line">    *<span class="keyword">error</span> = [NSError <span class="keyword">new</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)generateError2:(NSError * __autoreleasing *)<span class="keyword">error</span> &#123;</span><br><span class="line">    *<span class="keyword">error</span> = [NSError <span class="keyword">new</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时，<code>generateError1:</code>会对参数<code>error</code>自动添加<code>__autoreleasing</code>，然后就跟<code>generateError2:</code>的实现完全一致了。</p><p>通过反汇编也可看出两者完全一致：</p><p><img src="/2016/04/30/autoreleasing-meet-autoreleasepool/autoreleasing-meet-autoreleasepool_2.jpg" alt="Out Parameters参数会自动添加__autoreleasing属性"></p><p>在<code>call imp___stubs__objc_msgSend</code>完成后，<code>rax</code>寄存器保存了<code>[NSError new]</code>的对象，然后<code>mov rdi, rax</code>，转移到<code>rdi</code>寄存器，作为<code>objc_autorelease</code>函数的参数被调用，<code>*error</code>被加到了当前的autoreleasepool中。</p><h2 id="如果传给Out-Parameters参数的变量没有用-autoreleasing修饰，编译器会创建一个临时变量并以-autoreleasing修饰再传入"><a href="#如果传给Out-Parameters参数的变量没有用-autoreleasing修饰，编译器会创建一个临时变量并以-autoreleasing修饰再传入" class="headerlink" title="如果传给Out Parameters参数的变量没有用__autoreleasing修饰，编译器会创建一个临时变量并以__autoreleasing修饰再传入"></a>如果传给Out Parameters参数的变量没有用__autoreleasing修饰，编译器会创建一个临时变量并以__autoreleasing修饰再传入</h2><p>根据苹果的<a href="https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="noopener">Transitioning to ARC Release Notes</a>文档可知，如果有如下调用:</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSError *<span class="built_in">error</span>; <span class="comment">// 默认__strong类型</span></span><br><span class="line">[self generateError1:&amp;<span class="built_in">error</span>]；</span><br></pre></td></tr></table></figure><p>编译器检测到<code>generateError1:</code>方法的Out Parameters类型参数，但是调用时的<code>error</code>又不是<code>__autoreleasing</code>修饰的，就会自动创建一个<code>__autoreleasing</code>修饰的临时变量，用来代替<code>error</code>传入，编译器重写后如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> * error; <span class="comment">// 默认__strong类型</span></span><br><span class="line"><span class="built_in">NSError</span> * __autoreleasing tmp = error;</span><br><span class="line">[<span class="keyword">self</span> generateError1:&amp;tmp]；</span><br></pre></td></tr></table></figure><p>通过汇编来验证一下：</p><p>假如有如下调用：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)runTest &#123;</span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    [<span class="keyword">self</span> generateError1:&amp;error]; <span class="comment">// 就是上面的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编后，如下：</p><p><img src="/2016/04/30/autoreleasing-meet-autoreleasepool/autoreleasing-meet-autoreleasepool_3.jpg" alt="自动添加__autoreleasing临时变量"></p><p>代码有点多=。=，从图中汇编可知：<code>var_20</code>就是自动生成的临时变量，<code>var_18</code>是我们定义的<code>error</code>变量。</p><p><code>mov qword [ss:rbp+var_18], 0x0</code>对<code>var_18</code>做初始化，也就是赋<code>nil</code>值，然后<code>mov rdi, qword [ss:rbp+var_18]</code>和<code>mov qword [ss:rbp+var_20], rdi</code>就是用<code>var_18</code>初始化了<code>var_20</code>临时变量。</p><p><code>lea rdx, qword [ss:rbp+var_20]</code>将<code>var_20</code>临时变量的地址存到了<code>rdx</code>寄存器中，作为<code>objc_msgSend</code>实现<code>generateError1:</code>调用时的第三个参数，也就是<code>(NSError **):error</code>参数，完成调用。</p><p>调用完成后，通过如下调用，将临时变量<code>var_20</code>的值保存到<code>var_18</code>，即<code>error</code>变量中。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lea</span> <span class="built_in">rdx</span>, <span class="built_in">qword</span> [<span class="built_in">ss</span>:<span class="built_in">rbp</span>+var_18] # var_18为objc_storeStrong第一个参数</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">rsi</span>, <span class="built_in">qword</span> [<span class="built_in">ss</span>:<span class="built_in">rbp</span>+var_20] # var_20为objc_storeStrong第二个参数</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">rdi</span>, <span class="built_in">rdx</span></span><br><span class="line"><span class="keyword">call</span> imp___stubs__objc_storeStrong</span><br></pre></td></tr></table></figure><h2 id="开头例子出现EXC-BAD-ACCESS错误的原因"><a href="#开头例子出现EXC-BAD-ACCESS错误的原因" class="headerlink" title="开头例子出现EXC_BAD_ACCESS错误的原因"></a>开头例子出现EXC_BAD_ACCESS错误的原因</h2><p>经过上面一番对<code>__autoreleasing</code>的总结，再来看看开头例子的错误原因就比较容易懂了。</p><p><strong>enumerateObjectsUsingBlock会在循环内部自动添加autoreleasepool</strong></p><p>首先应该明确的就是<code>enumerateObjectsUsingBlock:</code>在用block迭代遍历NSArray的元素时，会自动添加autoreleasepool，对于例子来说，相当于：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举遍历</span></span><br><span class="line">[array enumerateObjectsUsingBlock:^(<span class="built_in">NSNumber</span> * _Nonnull number, <span class="built_in">NSUInteger</span> index, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (number.integerValue == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"me.tutuge"</span> code:<span class="number">100</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        *stop = <span class="literal">TRUE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>结合<code>__autoreleasing</code>后，重写为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *number = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">BOOL</span> stop = <span class="literal">FALSE</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> index = <span class="number">0</span>; index &lt; array.count &amp;&amp; !stop; index++) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123; <span class="comment">// 自动添加</span></span><br><span class="line">        number = array[index];</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [[<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"me.tutuge"</span> code:<span class="number">100</span> userInfo:<span class="literal">nil</span>] autorelease]; <span class="comment">// 注意这个autorelease !</span></span><br><span class="line">        &#125;</span><br><span class="line">        stop = <span class="literal">TRUE</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>autorelease</code>对应的函数<code>id objc_autorelease(id value)</code>的官方解释：</p><blockquote><p>If value is null, this call has no effect. Otherwise, it adds the object to the innermost autorelease pool exactly as if the object had been sent the autorelease message.</p></blockquote><p>其中的<strong>innermost autorelease pool</strong>表示的就是“最内层”的autoreleasepool，对于例子来说就是<code>*error</code>被添加到了循环内的autoreleasepool中，当然，导致的结果就是本次循环结束后，<code>*error</code>也随着一起被释放了。</p><p>最终导致了外部访问了已经被释放的<code>*error</code>，出现了EXC_BAD_ACCESS错误。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很多时候不能想当然的写代码=。=，要不然出了问题找都找不到，每个细节都很重要。<br>嗯，现在读汇编快多了。。。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html" target="_blank" rel="noopener">Clang document: Objective-C Automatic Reference Counting (ARC)</a></li><li><a href="https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="noopener">Transitioning to ARC Release Notes</a></li><li><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">黑幕背后的Autorelease</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;更新&quot;&gt;&lt;a href=&quot;#更新&quot; class=&quot;headerlink&quot; title=&quot;更新&quot;&gt;&lt;/a&gt;更新&lt;/h2&gt;&lt;p&gt;2016-05-01: 补充了一点本文涉及的汇编知识&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文结合一段访问&lt;code&gt;Out Parameters&lt;/code&gt;出现了&lt;code&gt;EXC_BAD_ACCESS&lt;/code&gt;错误的代码，通过反编译等手段验证Objective-C中&lt;code&gt;__autoreleasing&lt;/code&gt;的一些特点。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>总结一些iOS项目中组织代码的方法</title>
    <link href="http://tutuge.me/2016/04/10/summary-of-code-organization/"/>
    <id>http://tutuge.me/2016/04/10/summary-of-code-organization/</id>
    <published>2016-04-10T12:10:56.000Z</published>
    <updated>2018-10-07T17:37:29.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>总结一些组织代码的方法，大到各个子项目模块之间，小到单个文件内部，涉及到了CocoaPods私有库、Carthage构建私有Framework、项目内Group和文件夹、类内用Category组织、文件内的#pragam mark、// MARK -。虽然有些老生常谈，就当是重新梳理一遍吧=。=。</p><a id="more"></a><h2 id="多个子项目-CocoaPods加私有仓库"><a href="#多个子项目-CocoaPods加私有仓库" class="headerlink" title="多个子项目 - CocoaPods加私有仓库"></a>多个子项目 - CocoaPods加私有仓库</h2><p>感觉目前CocoaPods已经成了搞iOS开发的标配了，基本上所有的第三方库和组件都可以通过CocoaPods来集成管理。但是CocoaPods的功能其实不止管理第三方库和组件，团队内部的拆分出来的子项目和子模块，同样可以用CocoaPods来集成管理。</p><p>先看看如下Podfile的示例：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 源配置 #</span></span><br><span class="line">source <span class="string">'git@gitlab.xxx.com:cocoapods/specs.git'</span> <span class="comment"># 团队内部Gitlab源</span></span><br><span class="line">source <span class="string">'https://git.coding.net/xxx/specs.git'</span> <span class="comment"># Coding等私有Git托管平台</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># iOS版本支持 #</span></span><br><span class="line">platform <span class="symbol">:ios</span>, <span class="string">'7.0'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发中的子项目 #</span></span><br><span class="line">pod <span class="string">'XXXCommonUI'</span>, <span class="symbol">:path=&gt;</span> <span class="string">'/Users/tutuge/projects/Xcode/XXXCommonUI'</span> <span class="comment"># 本地路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 依赖的内部子项目 #</span></span><br><span class="line">pod <span class="string">'XXXModuleA'</span>, <span class="symbol">:git=&gt;</span> <span class="string">'git@gitlab.xxx.com:cocoapods/XXXModuleA'</span>, <span class="symbol">:branch=&gt;<span class="string">'develop'</span></span></span><br><span class="line">pod <span class="string">'XXXModuleB'</span>, <span class="string">'1.0.1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 依赖的开源第三方库 #</span></span><br><span class="line">pod <span class="string">'AFNetworking'</span>,<span class="string">'3.0.0'</span></span><br><span class="line">pod <span class="string">'DTCoreText'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 额外的脚本 #</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p><strong>私有Git仓库</strong>  </p><p>虽然我们有万能的Github了，但是还是有些代码是不能公开的=。=，所以需要一个私有的Git仓库。  </p><p>有自己服务器的，完全可以用<a href="https://about.gitlab.com/" target="_blank" rel="noopener">Gitlab</a>(或者<a href="https://gogs.io/" target="_blank" rel="noopener">Gogs</a>)搭建一个功能强大的私有Git仓库，管理项目代码，搭建CocoaPods私有源都很不错。  </p><p>当然，懒得折腾的，也可以用第三方的私有Git服务，如：<a href="https://bitbucket.org/" target="_blank" rel="noopener">Bitbucket</a>、<a href="https://coding.net/" target="_blank" rel="noopener">Coding</a>等。</p><p><strong>私有CocoaPods源</strong></p><p>搭建一个私有CocoaPods源其实就是创建一个私有的<code>Spec Repo</code>，说白了就是一个存放了所有私有Pods的<code>Podspec</code>文件的，按照特定结构组织的目录，然后把这个目录推到私有Git仓库就成了一个私有的CocoaPods源。  </p><p><code>Spec Repo</code>的目录结构示例如下：  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── <span class="selector-tag">Specs</span></span><br><span class="line">    └── <span class="selector-attr">[XXXModuleA]</span></span><br><span class="line">        └── <span class="selector-attr">[0.0.1]</span></span><br><span class="line">            └── <span class="selector-attr">[XXXModuleA]</span><span class="selector-class">.podspec</span><span class="selector-class">.json</span></span><br><span class="line">        └── <span class="selector-attr">[0.0.2]</span></span><br><span class="line">            └── <span class="selector-attr">[XXXModuleA]</span><span class="selector-class">.podspec</span><span class="selector-class">.json</span></span><br></pre></td></tr></table></figure><p>然后添加私有源即可：  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo add XXXSpecRepo https:<span class="regexp">//gi</span>t.coding.net<span class="regexp">/xxx/</span>specs.git</span><br></pre></td></tr></table></figure><p><strong>创建私有CocoaPods项目的具体步骤</strong>  </p><p>至于具体的创建步骤，CocoaPods的官方文档和一些优秀的博客已经说得很清楚了，我就不再重复了。推荐阅读：<a href="https://guides.cocoapods.org/" target="_blank" rel="noopener">CocoaPods Guides</a>，还有<a href="http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/" target="_blank" rel="noopener">使用Cocoapods创建私有podspec</a>，这篇很详细！</p><p><strong>引用正在本地开发的子项目</strong></p><p>主工程依赖的子项目也是可以同时开发的，用<code>path</code>指定路径即可，如<code>pod &#39;XXXCommonUI&#39;, :path=&gt; &#39;/Users/tutuge/projects/Xcode/XXXCommonUI&#39;</code>，然后<code>pod install</code>一下，依赖的本地工程就会集成到主工程的<code>Development Pods</code>目录下，开发时，就可以同时修改主项目和子项目了。</p><h2 id="构建私有Framework-Carthage"><a href="#构建私有Framework-Carthage" class="headerlink" title="构建私有Framework - Carthage"></a>构建私有Framework - Carthage</h2><p>除了抽离出子项目，用Framework的方式来管理公共代码也是不错的选择，Framework的好处也是多多的:</p><ul><li>本质上是个bundle，不仅可以打包代码，还可以打包资源Assets、视图XIB等</li><li>可以有选择的开放头文件、接口，避免了用CocoaPods集成子项目时，所有代码全部暴露的问题，只暴露需要的，代码更加清晰。</li><li>从iOS 8开始支持的Cocoa Touch Framework可以支持动态Framework，能在主App和各种Extension之间共享一份二进制目标代码，加快应用加载速度，减小体积，加快编译速度等。</li></ul><p>基于Cocoa Touch Framework动态框架的种种优点，“去中心化”的轻量级依赖包管理工具<a href="https://github.com/Carthage/Carthage" target="_blank" rel="noopener">Carthage</a>也越来越受欢迎。 </p><p>总的来说，Carthage没有CocoaPods那样的<code>Spec Repo</code>中心，不会对现有项目工程修改，只是完成了拉取代码、构建Framework的工作，非常的轻量级，所以用来构建团队内公用的Framework非常不错~</p><p><strong>创建Framework</strong>  </p><p>这里的Framework指的是Cocoa Touch Framework动态框架，静态Framework的缺点不少(如不能共享已加载到内存的二进制目标代码、构建麻烦等)，如果项目可以从iOS 8开始支持，为啥不用动态框架呢~</p><p>创建Framework的过程非常简单，Xcode 6以后就有了Framework项目模板，直接选中”Cocoa Touch Framework”模板，按照提示来即可。记得在<code>TARGETS-&gt;Build Phases-&gt;Headers-&gt;Public&quot;</code>加入要暴露的头文件（Swift的话，将要暴露的类、方法标记public）就好。</p><p><strong>用Carthage构建Framework</strong></p><p>Carthage只支持构建标记为“Shared”的项目Target，所以创建好了Framework工程后，还要设置Scheme为“Shared”，可以在当前Scheme的<code>Edit Scheme</code>里面设置，也可以在Xcode的菜单<code>Product-&gt;Scheme-&gt;Manage Schemes</code>里面设置。</p><p>然后就可以将Framework工程推送到Git仓库中，可以是Github，也可以是私有Git仓库，如上一节提到的Coding、Bitbucket等，只要本机可以正常访问即可。记住打上版本号tag。</p><p>然后就可以在一个测试工程中创建一个<code>Cartfile</code>文件，输入Framework的Git路径，按照官方文档设置一下”Run Script”，运行<code>carthage update</code>生成对应的Framework，就可以集成测试。</p><p><strong>最终的Cartfile</strong></p><p>由于Carthage的去中心化，用Carthage管理项目的Framework依赖就非常灵活，一个简单的示例如下：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 开发中的本地Framework</span></span><br><span class="line">git <span class="string">"file:///directory/to/project"</span> <span class="string">"develop"</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 依赖的私有Framework</span></span><br><span class="line">git <span class="string">"git@gitlab.xxx.com:cocoapods/XXXFramework.git"</span> <span class="string">"development"</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 第三方开源库</span></span><br><span class="line">github <span class="string">"Mantle/Mantle"</span> ~&gt; <span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>所以，Carthage可以方便的管理构建本地、私有、第三方的Framework库，而且更加方便~  </p><p>详细的创建流程Google一下就有很多，如<a href="https://medium.com/@PyBaig/build-your-own-cocoa-touch-frameworks-in-swift-d4ea3d1f9ca3#.z38fy8psd" target="_blank" rel="noopener">Build your own Cocoa Touch Frameworks, in pure Swift</a>、<a href="https://robots.thoughtbot.com/creating-your-first-ios-framework" target="_blank" rel="noopener">Creating your first iOS Framework</a>、<a href="http://blog.mat.tc/how-to-make-a-carthage-compatible-framework/" target="_blank" rel="noopener">How to Make a Carthage-compatible Framework in Swift</a>。 </p><p><strong>和CocoaPods混用</strong></p><p>Carthage是没有任何侵入性的，不会对项目工程有修改，只是构建出了Framework文件，所以完全可以把Carthage当做纯粹的Framework构建工具，跟CocoaPods一起愉快的使用=。=</p><h2 id="项目内文件组织-Group和文件夹"><a href="#项目内文件组织-Group和文件夹" class="headerlink" title="项目内文件组织 - Group和文件夹"></a>项目内文件组织 - Group和文件夹</h2><p>项目内的代码组织，其实就是代码文件的组织，总的来说，其实有以下三种：</p><ol><li>具有物理文件夹结构的Folder reference</li><li>从Xcode创建的逻辑上的Group</li><li>具有物理文件夹结构的Group</li></ol><p><strong>排除Folder reference</strong></p><p>Folder reference说白了就是硬盘上一个文件夹的逻辑引用，有点像Linux文件系统里面的软连接=。=，图标是蓝色的，将一个文件夹拖到Xcode中时，<code>Create folder references</code>选项创建的就是。  </p><p>虽然编译时也会被打包到程序中，更能同步真正文件夹内部的修改，但是遗憾是的里面的代码文件是不能自动的加入到Xcode的编译中的，要手动一个一个加，而且图片资源也不能在IB里面使用，代码里面使用也要加上路径，所以一般是纯资源文件夹用Folder reference的方式引用，对于组织代码文件，就可以排除Folder reference的方式。</p><p><strong>纯逻辑Group文件平铺，脱离Xcode不方便查看</strong></p><p>首先要明确的是，Group是Xcode对文件的一种逻辑上的引用，并且在编译时Xcode会把所有的Group展开，所以代码里面也就不用像Folder reference一样加上路径，还可以针对Target作区分，很方便。  </p><p>但是Xcode中创建的Group并没有对应到文件系统中的文件夹，导致一旦脱离Xcode看代码，所有的文件都平铺在了根目录下，非常不方便。</p><p>难道没有办法了？</p><p><strong>有物理文件夹结构的Group最好</strong></p><p>还有一种Group是可以有物理文件夹结构的，其实将一个文件夹拖到Xcode中，选择<code>Create groups for any added folders</code>创建的Group就是既有Group的有点，又可以保持物理文件夹结构。这样无意是最好的~</p><p>手动创建:<br>可以<code>Add Files To XXXX</code>，然后选择<code>New Folder</code>创建文件夹，然后把代码文件拖进去，再添加回Xcode。</p><p>自动创建：<br>对于现有的大量的Group，手动一个一个创建实在不方便，还好有个命令行工具：<a href="https://github.com/venmo/synx" target="_blank" rel="noopener">synx</a>，直接在工程根目录运行<code>synx XXX.xcodeproj</code>就可以自动为Group创建物理文件夹。<br>当然，CocoaPods管理的库要重新<code>pod install</code>一次，手动添加的Framework也要重新添加。</p><h2 id="类内代码组织-Category"><a href="#类内代码组织-Category" class="headerlink" title="类内代码组织 - Category"></a>类内代码组织 - Category</h2><p>Objective-C中的Category实在是太方便了，可以灵活的为现有的类增加方法，甚至是系统的类。  </p><p>但是其实Category也可以拿来组织一个类的实现，将类的Property、方法按照业务、功能拆分到不同的Category里面，使类的结构更加清晰。 </p><p>系统API本身就有大量的例子，如UIViewController的：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> UIViewController (UIContainerViewControllerCallbacks)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> UIViewController(UIViewControllerTransitioning)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>实现的时候还可以每个Category对应一个头文件和.m文件，类的结构更加清晰：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">XXXClass.h</span><br><span class="line">XXXClass.m</span><br><span class="line">XXXClass+XXXModuleA.h</span><br><span class="line">XXXClass+XXXModuleA.m</span><br><span class="line">XXXClass+XXXModuleB.h</span><br><span class="line">XXXClass+XXXModuleB.m</span><br></pre></td></tr></table></figure><h2 id="文件内代码组织-pragam-mark、-MARK"><a href="#文件内代码组织-pragam-mark、-MARK" class="headerlink" title="文件内代码组织 - #pragam mark、// MARK -"></a>文件内代码组织 - #pragam mark、// MARK -</h2><p>整理文件内的代码时，最好的手段就是用<code>#pragam mark</code>宏定义，Swift的话就是<code>// MARK -</code>。  </p><p>Objective-C冗长的语法注定了一个代码文件的行数不会少=。=，如果没有一定的规范，实在是难以迭代，所以最好就是开发前约定一种规则，对主要的类的实现都约定出一套规范，如UIViewController的子类、UIView的子类、UITableViewCell的子类等，然后开发人员按照这个规范写代码，这样才能使代码更好维护。</p><p>如，UIViewController的子类实现时，可以按照如下顺序组织代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@implementation XXXViewController</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存相关</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Memory manager</span></span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类生命周期相关的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Life cycle</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">void</span>)viewDidLoad</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的Public方法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Public methods</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的Actions</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Actions</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didTapCancelButton:(UIButton *button)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知回调，具体可以细分</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Notifications - XXX</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统的Delegate</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - UITableViewDelegate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类的Delegate</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - XXXDelegate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义View、初始化等</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Custom views</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类私有方法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Private methods</span></span><br><span class="line"></span><br><span class="line">@<span class="built_in">end</span></span><br></pre></td></tr></table></figure><p>当然，具体的组织方法还要根据项目本身的架构、模式决定，上面的只是参考。</p><p><strong>进一步：创建项目专属文件模板</strong></p><p>既然定下了文件内的组织顺序，每次写代码手工输入也还是有点麻烦，所以更进一步的话就是创建自定义的Xcode文件模板，把不同类的<code>#pragma mark</code>顺序规则直接写到模板里面，以后开发人员创建文件时直接用项目专属的模板就可以了~</p><p>具体的创建Xcode模板的步骤不在本文范畴=。=，不过倒是发现了一个Xcode插件，专门用来创建模板的：<a href="https://github.com/samdods/Stencil" target="_blank" rel="noopener">Stencil: A plugin for Xcode allowing you to easily create custom file templates</a>，以及对应的文章：<a href="http://sam.dods.co/blog/2015/05/02/stencil-xcode-plugin/" target="_blank" rel="noopener">Introducing Stencil</a>，还有一些教程：<a href="http://www.telerik.com/blogs/how-to-create-custom-project-templates-in-xcode-7" target="_blank" rel="noopener">How to Create Custom Project Templates in Xcode 7</a>，<a href="https://robots.thoughtbot.com/creating-custom-xcode-templates" target="_blank" rel="noopener">Creating Custom Xcode Templates</a>，读者可自行阅读~</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>一切为了更加干净整洁的代码，“May the clean code be with you”</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://cocoapods.org/" target="_blank" rel="noopener">CocoaPods</a></li><li><a href="https://github.com/Carthage/Carthage" target="_blank" rel="noopener">Carthage</a></li><li><a href="http://vocaro.com/trevor/blog/2012/10/21/xcode-groups-vs-folder-references/" target="_blank" rel="noopener">Xcode Groups vs. Folder References</a></li><li><a href="http://www.knowstack.com/framework-vs-library-cocoa-ios/" target="_blank" rel="noopener">Framework vs Library (Static &amp; Shared) in (Cocoa/OSX, Cocoa Touch/iOS)</a></li><li><a href="https://onevcat.com/2016/01/create-framework/" target="_blank" rel="noopener">onevcat-如何打造一个让人愉快的框架</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;总结一些组织代码的方法，大到各个子项目模块之间，小到单个文件内部，涉及到了CocoaPods私有库、Carthage构建私有Framework、项目内Group和文件夹、类内用Category组织、文件内的#pragam mark、// MARK -。虽然有些老生常谈，就当是重新梳理一遍吧=。=。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>对组件化与模块化的思考与总结</title>
    <link href="http://tutuge.me/2016/03/29/modular-and-component-summary/"/>
    <id>http://tutuge.me/2016/03/29/modular-and-component-summary/</id>
    <published>2016-03-29T14:19:54.000Z</published>
    <updated>2018-10-07T17:37:29.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间反复研读了<a href="http://limboy.me/ios/2016/03/10/mgj-components.html" target="_blank" rel="noopener">蘑菇街 App 的组件化之路</a>、<a href="http://limboy.me/ios/2016/03/14/mgj-components-continued.html" target="_blank" rel="noopener">蘑菇街 App 的组件化之路·续</a>和<a href="http://casatwy.com/iOS-Modulization.html" target="_blank" rel="noopener">iOS应用架构谈 组件化方案</a>，然后又找到了其它一些研究组件化、模块化方案的文章，但是总觉得差点什么，所以还是决定从头开始思考。文章的标题起的好宽泛，感觉给自己挖了个深坑-。-，其实只是自己对组件化、模块化的一些看法、总结。</p><a id="more"></a><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>先总结下为什么要大动干戈的对代码分模块、拆组件。   </p><p><strong>代码量膨胀，不利于维护，更不利于新功能的开发</strong>  </p><p> 现在随便开发一个App的代码行数都是数以万计的，如果不对代码做合理的拆分，那简直就是灾难性的，估计只有最初的开发人员知道如何维护修改，如果换人开发的话，难以下手，更不用说开发新功能了。</p><p><strong>不同业务代码耦合严重，难以多人合作，职责不分明</strong>  </p><p>多人一起开发时，如果代码结构、模块化的不好，就很难对不同业务划分出分界线，难以明确各自的职责，牵一发动全身，出了问题更是容易相互扯皮（这个时候只能说一句“怪我咯o(╯□╰)o”），更不用提合并代码时的冲突了。</p><p>所以，合理的组织代码，划分模块、拆分组件是项目可以高效迭代的基础。</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>那到底什么是模块化、组件化？查资料的时候一会儿模块，一会儿组件，有什么联系，有什么区别？有人说这只是叫法习惯问题，知道大概意思就好，不用咬文嚼字，但是总觉得没有个“定义”感觉不踏实，所以还是求助了万能的维基百科=。=</p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>维基百科的<a href="https://en.wikipedia.org/wiki/Modular_programming" target="_blank" rel="noopener">Modular programming</a>的开头定义如下:</p><blockquote><p>Modular programming is a software design technique that emphasizes separating the functionality of a program into independent, interchangeable modules, such that each contains everything necessary to execute only one aspect of the desired functionality.</p></blockquote><p>接着，在<strong>Key aspects</strong>部分的开头也说了:</p><blockquote><p>With modular programming, concerns are separated such that modules perform logically discrete functions, interacting through well-defined interfaces. </p></blockquote><p>可以总结为：模块化的目的在于将一个程序按照其功能做拆分，分成相互独立的模块，以便于每个模块只包含与其功能相关的内容，模块之间通过接口调用。</p><p>当然，模块化编程的具体概念是包含了很多内容的，读者可以详细阅读下维基百科的定义。</p><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>关于组件化，能找到的比较接近的就是维基百科的<a href="https://en.wikipedia.org/wiki/Component-based_software_engineering" target="_blank" rel="noopener">Component-based software engineering</a>，其开头内容如下：</p><blockquote><p>Component-based software engineering (CBSE), also known as component-based development (CBD), is a branch of software engineering that emphasizes the separation of concerns in respect of the wide-ranging functionality available throughout a given software system. It is a reuse-based approach to defining, implementing and composing loosely coupled independent components into systems.</p></blockquote><p>乍一看，这不是跟模块化<strong>Modular programming</strong>的定义很相似嘛=。=<br>的确，文中也提到组件化跟模块化是很类似的，都是主要为了对一个系统做拆分，比如文中提到：  </p><blockquote><p>All system processes are placed into separate components so that all of the data and functions inside each component are semantically related (just as with the contents of classes). Because of this principle, it is often said that components are modular and cohesive.</p></blockquote><p>同时，组件还具有其他属性，如可替代性(substitutable)，通过接口(interface)访问，可重用性(Reusability)等，读者可自行阅读。</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>难道模块化跟组件化真的是完全一样的？的确，很多时候两者的概念完全可以相互替换，在实践中更是经常混用。  </p><p>在求助谷歌，甚至阅读了大量的前端技术等其它技术领域的组件化、模块化的文章后，我觉得如果真要将它们两者做个对比，大概总结如下：</p><ul><li>模块化强调的是<strong>拆分</strong>，无论是从业务角度还是从架构、技术角度，模块化首先意味着将代码、数据等内容按照其职责不同分离，使其变得更加容易维护、迭代，使开发人员可以分而治之。</li><li>组件化则着重于<strong>可重用性</strong>，不管是界面上反复使用的用户头像按钮，还是处理数据的流程中的某个部件，只要可以被反复使用，并且进行了高度封装，只能通过接口访问，就可以称其为“组件”。</li></ul><p>当然，并不是说模块就不能被复用，还是要根据实际情况来看，使系统更加容易维护，开发更加方便，才是最终目的。</p><h2 id="如何拆分"><a href="#如何拆分" class="headerlink" title="如何拆分"></a>如何拆分</h2><p>无论是模块化还是组件化，首先肯定是做拆分，但是如何拆分？怎么下手？依照什么标准？<br>下面简单总结一些方法。</p><h4 id="横向拆分业务、功能模块"><a href="#横向拆分业务、功能模块" class="headerlink" title="横向拆分业务、功能模块"></a>横向拆分业务、功能模块</h4><p>很多时候，一个完整的软件程序是同时为多种业务服务的，所有可以优先按照业务的不同，将整个系统进行拆分。  </p><p>如一个电商类型的App，就可以分出商品浏览模块、订单模块、购物车模块、消息模块、支付模块等。又如微信这种社交型应用，可以拆分出联系人模块、朋友圈模块、聊天模块、消息模块等。  </p><p>其实就是从用户使用的角度，按照功能的不同划分模块，当然，这种业务模块是要由各种技术模块作支撑的。</p><p><img src="/2016/03/29/modular-and-component-summary/modular_and_component_summary_1.jpg" alt="横向拆分业务模块示例"></p><h4 id="纵向拆分技术、架构模块"><a href="#纵向拆分技术、架构模块" class="headerlink" title="纵向拆分技术、架构模块"></a>纵向拆分技术、架构模块</h4><p>如果脱离业务，只从技术角度来看，则可以尝试纵向对系统拆分模块。</p><p>其实这里的纵向拆分跟对系统的架构做分层有点像=。=，现如今只要需要联网请求API的App都免不了有网络请求、数据缓存、数据加工处理、数据展示、反馈用户操作等行为，所有这些环节层层递进才能完成一个功能。  </p><p>当开始着手规划一个完整软件系统，或者说App时，就可以按照这些环节划分模块，纵向分层次的组合，搭建出一个以技术模块组成的简易系统架构图，方便后续的开发，如下图。</p><p><img src="/2016/03/29/modular-and-component-summary/modular_and_component_summary_2.jpg" alt="纵向拆分技术模块示例"></p><p>大体上的技术模块划分好以后，就可以按照具体的需求，实现每个技术模块，乃至细分出更多的子模块，如缓存模块可能由键值对缓存（NSUserDefaults）、数据库缓存（SQLite、Realm）、图片缓存等子模块组成，根据具体情况而定。</p><h4 id="从界面入手，拆分可视化组件"><a href="#从界面入手，拆分可视化组件" class="headerlink" title="从界面入手，拆分可视化组件"></a>从界面入手，拆分可视化组件</h4><p>现在再来看看如何从界面入手拆分可复用的组件。假如有如下布局的界面：</p><p><img src="/2016/03/29/modular-and-component-summary/modular_and_component_summary_3.jpg" alt="从界面入手拆分可视化组件"></p><p>很多时候，像界面里面的“搜索框”、“头像按钮”、“内容框”和显示提示用的“加载中”HUD，甚至整个内容的Cell，都是可能在很多地方出现的，而且本身的样式、功能比较集中。<br>如头像可能要支持点击跳转，头像图片圆角，内容框有特定的Padding和字体大小等，所以可以将这些界面上的元素“提”出来，单独封装成一个组件，供整个App复用。或者直接用第三方的组件，如图中的“加载中”HUD，就可以用SVProgressHUD、MBProgressHUD等开源库。</p><p>其实这里的组件有种sunnyxx大大提到过的“Self-Manager”的味道=。=，组件本身负责自己的所有功能、样式，参考：<a href="http://blog.sunnyxx.com/2015/12/19/self-manager-pattern-in-ios/" target="_blank" rel="noopener">iOS 开发中的 Self-Manager 模式</a>。当然跟前端的组件化也挺像的，如React里面的component，样式、功能都封装到component里面，以便更好地解耦复用。</p><h4 id="从数据入手，拆分数据加工组件"><a href="#从数据入手，拆分数据加工组件" class="headerlink" title="从数据入手，拆分数据加工组件"></a>从数据入手，拆分数据加工组件</h4><p>再来看看从数据入手，拆分可复用的组件。假如有如下数据处理流程：</p><p><img src="/2016/03/29/modular-and-component-summary/modular_and_component_summary_4.jpg" alt="一数据处理流程示例"></p><p>其实大部分时候，拆分模块、组件都是以清晰的流程、逻辑为基础的，就如上图的过程，当流程清晰后，可以拆分复用的组件也就“出来了”。 </p><p>如从JSON数据实例化出对应的Entity对象，这个功能就是一个完整独立的组件，当然实际开发中会用Mantle、JSONModel等库实现。  </p><p>以此类推，校验、格式化日期（如“几秒钟前、几天前”）、多语言等环节，都可以独立成一个个的组件。  </p><p>当然，这里的组件一般是指能在多个模块使用的功能组件，如果只是在某个界面上才用的，倒不如放到ViewModel、Presenter等这些直接跟界面有关的类里面。</p><h4 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h4><p>上面的几种方法比较适合不知道如何下手时使用=。=，真正的开发中，还是要根据实际情况考虑，情况也会复杂些。不过倒是可以总结几点原则：</p><ul><li><strong>单一职责</strong>，意味着一个模块、一个组件只做一件事，绝不多做。</li><li><strong>正交性</strong>，意思是不重复，一个模块跟另一个模块的职责是正交的，没有重叠，组件也是一样。</li><li><strong>单向依赖</strong>，模块之间最多是单向的依赖，如果出现A依赖B，B也依赖A，那么要么是A、B应该属于一个模块，要么就是整体的拆分有问题。一个完整的软件系统的模块依赖应该是一张有向无环图。（当然这是最终理想=。=）</li><li><strong>紧凑性</strong>，模块、组件对外暴露的接口、属性应该尽可能的少，接口的参数个数也要少。</li><li><strong>面向接口</strong>，模块、组件对外提供服务时最好是面向接口的，以便后期可以灵活的变更实现。</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>一切为了更加干净整洁的代码，“May the clean code be with you”</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://en.wikipedia.org/wiki/Component-based_software_engineering" target="_blank" rel="noopener">Component-based software engineering</a></li><li><a href="https://en.wikipedia.org/wiki/Modular_programming" target="_blank" rel="noopener">Modular programming</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间反复研读了&lt;a href=&quot;http://limboy.me/ios/2016/03/10/mgj-components.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;蘑菇街 App 的组件化之路&lt;/a&gt;、&lt;a href=&quot;http://limboy.me/ios/2016/03/14/mgj-components-continued.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;蘑菇街 App 的组件化之路·续&lt;/a&gt;和&lt;a href=&quot;http://casatwy.com/iOS-Modulization.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iOS应用架构谈 组件化方案&lt;/a&gt;，然后又找到了其它一些研究组件化、模块化方案的文章，但是总觉得差点什么，所以还是决定从头开始思考。文章的标题起的好宽泛，感觉给自己挖了个深坑-。-，其实只是自己对组件化、模块化的一些看法、总结。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>开源项目-TTGTagCollectionView</title>
    <link href="http://tutuge.me/2015/12/31/TTGTagCollectionView/"/>
    <id>http://tutuge.me/2015/12/31/TTGTagCollectionView/</id>
    <published>2015-12-31T13:56:04.000Z</published>
    <updated>2018-10-07T17:37:29.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><ul><li>2017-02-27: 增加两种Alignment布局类型；增加点击前的回调判断；增加选中Tag上限</li><li>2016-12-25: 不再依赖UICollectionView，减少了位置刷新次数，提高性能；增加了alignment属性，可以靠左中右排列</li><li>2016-10-29: 增加Tag的阴影和ContentInset的设置，更新了Demo</li><li>2016-10-17: 增加了水平滑动；Autolayout适配；UITableViewCell例子等</li><li>2016-02-18: 修复了超长标签导致排版错误的Bug</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这段时间做项目的时候，总是需要显示一些“标签”样式的内容，但是又找不到用的顺手的库，所以琢磨了几天，自己实现了出来，就有了这个库：TTGTagCollectionView。如果只需要显示文字标签的话，直接使用<code>TTGTextTagCollectionView</code>，需要自己定义标签的话，就用<code>TTGTagCollectionView</code>，效果如下:</p><p><img src="/2015/12/31/TTGTagCollectionView/TTGTagCollectionView_screenshot.png" alt="ScreenShot"></p><p>支持五种布局排版：</p><p><img src="/2015/12/31/TTGTagCollectionView/TTGTagCollectionView_alignment_type_1.png" alt="Alignment"></p><p>CocoaPods: <code>pod &quot;TTGTagCollectionView&quot;</code><br>Carthage: <code>github &quot;zekunyan/TTGTagCollectionView&quot;</code></p><p>Github地址: <a href="https://github.com/zekunyan/TTGTagCollectionView" target="_blank" rel="noopener">https://github.com/zekunyan/TTGTagCollectionView</a></p><a id="more"></a><h2 id="只显示文字标签-TTGTextTagCollectionView"><a href="#只显示文字标签-TTGTextTagCollectionView" class="headerlink" title="只显示文字标签 - TTGTextTagCollectionView"></a>只显示文字标签 - TTGTextTagCollectionView</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>只显示文字标签的话，直接用<code>TTGTextTagCollectionView</code>类就可以了：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">TTGTextTagCollectionView</span> *tagCollectionView = [[<span class="symbol">TTGTextTagCollectionView</span> alloc] initWithFrame:<span class="symbol">CGRectMake</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">200</span>, <span class="number">200</span>)];</span><br><span class="line">[self.view addSubview:tagCollectionView];</span><br><span class="line">[tagCollectionView addTags:@[@<span class="string">"TTG"</span>, @<span class="string">"Tag"</span>, @<span class="string">"collection"</span>, @<span class="string">"view"</span>]];</span><br></pre></td></tr></table></figure><h3 id="接收点击事件-实现Delegate"><a href="#接收点击事件-实现Delegate" class="headerlink" title="接收点击事件 - 实现Delegate"></a>接收点击事件 - 实现Delegate</h3><p>如果想在标签被点击时得到通知，实现对应的Protocol即可，定义如下:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@protocol</span> TTGTextTagCollectionViewDelegate &lt;NSObject&gt;</span><br><span class="line"><span class="variable">@optional</span></span><br><span class="line"><span class="comment">// 是否可以点击某个Tag</span></span><br><span class="line">- (BOOL)<span class="attribute">textTagCollectionView</span>:(TTGTextTagCollectionView *)textTagCollectionView <span class="attribute">canTapTag</span>:(NSString *)tagText <span class="attribute">atIndex</span>:(NSUInteger)index <span class="attribute">currentSelected</span>:(BOOL)currentSelected;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击了某个Tag</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">textTagCollectionView</span><span class="selector-pseudo">:(TTGTextTagCollectionView</span> *)<span class="selector-tag">textTagCollectionView</span> <span class="selector-tag">didTapTag</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">tagText</span> <span class="selector-tag">atIndex</span><span class="selector-pseudo">:(NSUInteger)index</span> <span class="selector-tag">selected</span><span class="selector-pseudo">:(BOOL)selected</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内容大小更新</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">textTagCollectionView</span><span class="selector-pseudo">:(TTGTextTagCollectionView</span> *)<span class="selector-tag">textTagCollectionView</span> <span class="selector-tag">updateContentSize</span><span class="selector-pseudo">:(CGSize)contentSize</span>;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><h3 id="自定义文字标签样式"><a href="#自定义文字标签样式" class="headerlink" title="自定义文字标签样式"></a>自定义文字标签样式</h3><p>如果想对标签的样式做定制，可以设置以下属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标签是否可以被选中</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> enableTagSelection;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字体</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIFont</span> *tagTextFont;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文字颜色</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIColor</span> *tagTextColor;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIColor</span> *tagSelectedTextColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标签背景颜色</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIColor</span> *tagBackgroundColor;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIColor</span> *tagSelectedBackgroundColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆角值</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> tagCornerRadius;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> tagSelectedCornerRadius;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边框</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> tagBorderWidth;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> tagSelectedBorderWidth;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIColor</span> *tagBorderColor;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIColor</span> *tagSelectedBorderColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阴影</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">UIColor</span> *tagShadowColor;    <span class="comment">// Default is [UIColor black]</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGSize</span> tagShadowOffset;   <span class="comment">// Default is (2, 2)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> tagShadowRadius;  <span class="comment">// Default is 2f</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> tagShadowOpacity; <span class="comment">// Default is 0.3f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 滚动方向，默认垂直方向</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) TTGTagCollectionScrollDirection scrollDirection;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 布局类型，默认靠左</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) TTGTagCollectionAlignment alignment;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行数，默认0，不限制</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> numberOfLines;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选中的数量限制</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> selectionLimit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标签宽高的扩展值，可以理解为padding</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGSize</span> extraSpace;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 水平间隔</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> horizontalSpacing;</span><br><span class="line"><span class="comment">// 行距</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> verticalSpacing;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体的Inset</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UIEdgeInsets</span> contentInset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有标签大小</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">CGSize</span> contentSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否显示滚动条</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> showsHorizontalScrollIndicator;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> showsVerticalScrollIndicator;</span><br></pre></td></tr></table></figure><h3 id="增加、删除标签"><a href="#增加、删除标签" class="headerlink" title="增加、删除标签"></a>增加、删除标签</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加一个标签</span></span><br><span class="line">- (<span class="keyword">void</span>)addTag:(<span class="built_in">NSString</span> *)tag;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addTags:(<span class="built_in">NSArray</span> &lt;<span class="built_in">NSString</span> *&gt; *)tags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 删除标签</span></span><br><span class="line">- (<span class="keyword">void</span>)removeTag:(<span class="built_in">NSString</span> *)tag;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeTagAtIndex:(<span class="built_in">NSUInteger</span>)index;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeAllTags;</span><br></pre></td></tr></table></figure><h3 id="在代码里控制标签的选中状态"><a href="#在代码里控制标签的选中状态" class="headerlink" title="在代码里控制标签的选中状态"></a>在代码里控制标签的选中状态</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>setTagAtIndex:<span class="params">(NSUInteger)</span>index selected:<span class="params">(BOOL)</span>selected;</span><br></pre></td></tr></table></figure><h3 id="获取所有、选中、未选中标签"><a href="#获取所有、选中、未选中标签" class="headerlink" title="获取所有、选中、未选中标签"></a>获取所有、选中、未选中标签</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="name">NSArray</span> &lt;NSString *&gt; *)allTags<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">- (<span class="name">NSArray</span> &lt;NSString *&gt; *)allSelectedTags<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">- (<span class="name">NSArray</span> &lt;NSString *&gt; *)allNotSelectedTags<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="重新加载-Reload"><a href="#重新加载-Reload" class="headerlink" title="重新加载 - Reload"></a>重新加载 - Reload</h3><p>用<code>- (void)reload</code>方法重新加载所有标签。</p><h2 id="显示自定义的标签控件View-TTGTagCollectionView"><a href="#显示自定义的标签控件View-TTGTagCollectionView" class="headerlink" title="显示自定义的标签控件View - TTGTagCollectionView"></a>显示自定义的标签控件View - TTGTagCollectionView</h2><p>如果想自己定义标签View，如同时显示图像、文字、按钮，可以用<code>TTGTagCollectionView</code>类实现。</p><h3 id="基本要求-实现DataSource和Delegate"><a href="#基本要求-实现DataSource和Delegate" class="headerlink" title="基本要求 - 实现DataSource和Delegate"></a>基本要求 - 实现DataSource和Delegate</h3><p>DataSource的定义如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@protocol</span> TTGTagCollectionViewDataSource &lt;NSObject&gt;</span><br><span class="line"><span class="variable">@required</span></span><br><span class="line"><span class="comment">// 返回标签数量</span></span><br><span class="line">- (NSUInteger)<span class="attribute">numberOfTagsInTagCollectionView</span>:(TTGTagCollectionView *)tagCollectionView;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对应标签View</span></span><br><span class="line"><span class="selector-tag">-</span> (UIView *)<span class="selector-tag">tagCollectionView</span><span class="selector-pseudo">:(TTGTagCollectionView</span> *)<span class="selector-tag">tagCollectionView</span> <span class="selector-tag">tagViewForIndex</span><span class="selector-pseudo">:(NSUInteger)index</span>;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><p>Delegate的定义如下:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@protocol</span> TTGTagCollectionViewDelegate &lt;NSObject&gt;</span><br><span class="line"><span class="variable">@required</span></span><br><span class="line"><span class="comment">// 必须实现：返回对应的标签Size</span></span><br><span class="line">- (CGSize)<span class="attribute">tagCollectionView</span>:(TTGTagCollectionView *)tagCollectionView <span class="attribute">sizeForTagAtIndex</span>:(NSUInteger)index;</span><br><span class="line"></span><br><span class="line"><span class="variable">@optional</span></span><br><span class="line"><span class="comment">// 是否可以点击Tag</span></span><br><span class="line">- (BOOL)<span class="attribute">tagCollectionView</span>:(TTGTagCollectionView *)tagCollectionView <span class="attribute">shouldSelectTag</span>:(UIView *)tagView <span class="attribute">atIndex</span>:(NSUInteger)index;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击标签时回调</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">tagCollectionView</span><span class="selector-pseudo">:(TTGTagCollectionView</span> *)<span class="selector-tag">tagCollectionView</span> <span class="selector-tag">didSelectTag</span><span class="selector-pseudo">:(UIView</span> *)<span class="selector-tag">tagView</span> <span class="selector-tag">atIndex</span><span class="selector-pseudo">:(NSUInteger)index</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有标签总体Size更新</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">tagCollectionView</span><span class="selector-pseudo">:(TTGTagCollectionView</span> *)<span class="selector-tag">tagCollectionView</span> <span class="selector-tag">updateContentSize</span><span class="selector-pseudo">:(CGSize)contentSize</span>;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><p>跟UITableView的思路一致~</p><h3 id="设置标签的行距、间隔"><a href="#设置标签的行距、间隔" class="headerlink" title="设置标签的行距、间隔"></a>设置标签的行距、间隔</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动方向</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) TTGTagCollectionScrollDirection scrollDirection;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 布局方式，默认靠左</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) TTGTagCollectionAlignment alignment;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行数，默认0，不限制</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> numberOfLines;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 水平间隔</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> horizontalSpacing;</span><br><span class="line"><span class="comment">// 行距</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> verticalSpacing;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体Inset</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UIEdgeInsets</span> contentInset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有标签总体Size</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">CGSize</span> contentSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否显示滚动条</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> showsHorizontalScrollIndicator;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> showsVerticalScrollIndicator;</span><br></pre></td></tr></table></figure><h3 id="重新加载-Reload-1"><a href="#重新加载-Reload-1" class="headerlink" title="重新加载 - Reload"></a>重新加载 - Reload</h3><p>用<code>- (void)reload</code>方法重新加载所有标签。</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>2015最后一天~<br>新年快乐~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;更新&quot;&gt;&lt;a href=&quot;#更新&quot; class=&quot;headerlink&quot; title=&quot;更新&quot;&gt;&lt;/a&gt;更新&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;2017-02-27: 增加两种Alignment布局类型；增加点击前的回调判断；增加选中Tag上限&lt;/li&gt;
&lt;li&gt;2016-12-25: 不再依赖UICollectionView，减少了位置刷新次数，提高性能；增加了alignment属性，可以靠左中右排列&lt;/li&gt;
&lt;li&gt;2016-10-29: 增加Tag的阴影和ContentInset的设置，更新了Demo&lt;/li&gt;
&lt;li&gt;2016-10-17: 增加了水平滑动；Autolayout适配；UITableViewCell例子等&lt;/li&gt;
&lt;li&gt;2016-02-18: 修复了超长标签导致排版错误的Bug&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这段时间做项目的时候，总是需要显示一些“标签”样式的内容，但是又找不到用的顺手的库，所以琢磨了几天，自己实现了出来，就有了这个库：TTGTagCollectionView。如果只需要显示文字标签的话，直接使用&lt;code&gt;TTGTextTagCollectionView&lt;/code&gt;，需要自己定义标签的话，就用&lt;code&gt;TTGTagCollectionView&lt;/code&gt;，效果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2015/12/31/TTGTagCollectionView/TTGTagCollectionView_screenshot.png&quot; alt=&quot;ScreenShot&quot;&gt;&lt;/p&gt;
&lt;p&gt;支持五种布局排版：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2015/12/31/TTGTagCollectionView/TTGTagCollectionView_alignment_type_1.png&quot; alt=&quot;Alignment&quot;&gt;&lt;/p&gt;
&lt;p&gt;CocoaPods: &lt;code&gt;pod &amp;quot;TTGTagCollectionView&amp;quot;&lt;/code&gt;&lt;br&gt;Carthage: &lt;code&gt;github &amp;quot;zekunyan/TTGTagCollectionView&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Github地址: &lt;a href=&quot;https://github.com/zekunyan/TTGTagCollectionView&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/zekunyan/TTGTagCollectionView&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="开源" scheme="http://tutuge.me/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>有趣的Autolayout示例3-Masonry实现</title>
    <link href="http://tutuge.me/2015/12/14/autolayout-example-with-masonry3/"/>
    <id>http://tutuge.me/2015/12/14/autolayout-example-with-masonry3/</id>
    <published>2015-12-14T13:36:08.000Z</published>
    <updated>2018-10-07T17:37:29.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><ul><li>2016-06-02: 感谢<a href="http://weibo.com/u/2953626141" target="_blank" rel="noopener">我不是蜡笔小新但是我有小白</a>，发现了Case 2的最后两个cell展开动画问题，原来是tableView的<code>estimatedRowHeight</code>会跟展开动画冲突的缘故。  </li><li>2015-12-23: 感谢<a href="https://github.com/XVXVXXX" target="_blank" rel="noopener">XVXVXXX</a>的PR,Case 1不再需要Fake Header View，直接用contentInset就好~  </li><li>2015-12-17：Case3的等间距，用UIStackView实现最优雅，但是无奈只有iOS9以上支持。兼容方案如OAStackView也可以，但是在UITableViewCell里面用，或者需要频繁的增减内部View的数量时，性能损耗有点厉害，会卡。所以，还是要看需求=。=</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第三篇来了。<br>依然是3个小例子，主要部分用Masonry手写代码实现，其它的约束在storyboard里面直接拖拽搭建。<br>至于为啥不用VFL，主要是因为它的“描述性”的写法很容易出错，没有补全、不好调试，写起来没有“代码”的感觉=。=。当然，这个仁者见仁智者见智~<br>三个例子分别是：<strong>Parallax Header</strong>，<strong>动态变高度的UITableViewCell</strong>，以及<strong>两种方式实现等间距</strong>。原理其实都很简单，例子也都是平时积累起来的。</p><p>前两篇：</p><ul><li>第一篇：<a href="http://tutuge.me/2015/05/23/autolayout-example-with-masonry/">有趣的Autolayout示例-Masonry实现</a></li><li>第二篇：<a href="http://tutuge.me/2015/08/08/autolayout-example-with-masonry2/">有趣的Autolayout示例2-Masonry实现</a></li><li>第四篇：<a href="http://tutuge.me/2016/08/06/autolayout-example-with-masonry4/">有趣的Autolayout示例4-Masonry实现</a></li></ul><p>Github地址：<br><a href="https://github.com/zekunyan/AutolayoutExampleWithMasonry" target="_blank" rel="noopener">https://github.com/zekunyan/AutolayoutExampleWithMasonry</a></p><p><img src="/2015/12/14/autolayout-example-with-masonry3/blog_autolayout_example_with_masonry3_1.gif" alt="Gif示例"></p><a id="more"></a><h2 id="Case-1-Parallax-Header"><a href="#Case-1-Parallax-Header" class="headerlink" title="Case 1: Parallax Header"></a>Case 1: Parallax Header</h2><p>Parallax翻译过来就是“视差”，我个人觉得就是一种“联动”的效果，在许多应用里面都能见到。当前这个例子，就是最简单的一种。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>原理其实就是根据UITableView当前下拉的位移值，同步改变Parallax Header的高度，即<code>NSLayoutConstraint</code>的<code>constant</code>属性，对应到Masonry里面就是重新让约束<code>equalTo()</code>一次。</p><h3 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h3><p>主要的步骤如下：</p><ol><li>设置UITableView背景透明。</li><li>在UITableView正下方放置一个UIImageView，作为我们的Parallax Header，设置<code>contentMode</code>为<code>UIViewContentModeScaleAspectFill</code>，并加上<strong>上左右</strong>的固定约束，使其与UITableView对其，然后加上一个固定高度的约束，并在代码里面保存。</li><li>设置UITableView的<code>contentInset</code>跟Parallax Header等高，使UITableView的头部“撑开”，让后面的Parallax Header露出来。</li><li>在代码里面监听UITableView的<code>contentOffset</code>属性，当y小于0时，增加Parallax Header高度，使其产生联动效果。</li></ol><p>约束示意图如下：<br><img src="/2015/12/14/autolayout-example-with-masonry3/blog_autolayout_example_with_masonry3_6.png" alt="Parallax Header"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>创建Parallax Header的代码如下：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">_parallaxHeaderView</span> = [UIImageView new];</span><br><span class="line"><span class="comment">// 把Parallax Header放在UITableView的下面</span></span><br><span class="line">[self.view insertSubview:<span class="variable">_parallaxHeaderView</span> belowSubview:<span class="variable">_tableView</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置contentMode</span></span><br><span class="line"><span class="variable">_parallaxHeaderView</span>.contentMode = UIViewContentModeScaleAspectFill;</span><br><span class="line"><span class="variable">_parallaxHeaderView</span>.<span class="built_in">image</span> = [UIImage imageNamed:@<span class="string">"parallax_header_back"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加约束</span></span><br><span class="line">[<span class="variable">_parallaxHeaderView</span> mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.left.<span class="built_in">and</span>.right.equalTo(self.view);</span><br><span class="line">    make.top.equalTo(self.mas_topLayoutGuideBottom);</span><br><span class="line">    <span class="comment">// 保存高度约束</span></span><br><span class="line">    <span class="variable">_parallaxHeaderHeightConstraint</span> = make.height.equalTo(@(ParallaxHeaderHeight));</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>设置UITableView的<code>contentInset</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">_tableView.contentInset</span> = UIEdgeInsetsMake(ParallaxHeaderHeight, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="监听contentOffset属性的两种方法"><a href="#监听contentOffset属性的两种方法" class="headerlink" title="监听contentOffset属性的两种方法"></a>监听<code>contentOffset</code>属性的两种方法</h3><h4 id="方法1：直接实现scrollViewDidScroll"><a href="#方法1：直接实现scrollViewDidScroll" class="headerlink" title="方法1：直接实现scrollViewDidScroll:"></a>方法1：直接实现<code>scrollViewDidScroll:</code></h4><p>这种方法应该是最直接的：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">scrollViewDidScroll</span><span class="selector-pseudo">:(UIScrollView</span> *)<span class="selector-tag">scrollView</span> &#123;</span><br><span class="line">    <span class="selector-tag">if</span> (scrollView.contentOffset.y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 增加Parallax Header对应的高度，y是负数，所以减去</span></span><br><span class="line">        <span class="selector-tag">_parallaxHeaderHeightConstraint</span><span class="selector-class">.equalTo</span>(@(ParallaxHeaderHeight - scrollView.contentOffset.y));</span><br><span class="line">    &#125; <span class="selector-tag">else</span> &#123;</span><br><span class="line">        <span class="selector-tag">_parallaxHeaderHeightConstraint</span><span class="selector-class">.equalTo</span>(@(ParallaxHeaderHeight));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法2：KVO监听contentOffset变化"><a href="#方法2：KVO监听contentOffset变化" class="headerlink" title="方法2：KVO监听contentOffset变化"></a>方法2：KVO监听<code>contentOffset</code>变化</h4><p>用KVO的好处就是不用要求当前类实现UITableView的delegate，对于代码的拆分有好处。</p><p>增加KVO：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[_tableView <span class="string">addObserver:</span>self <span class="string">forKeyPath:</span>@<span class="string">"contentOffset"</span> <span class="string">options:</span>NSKeyValueObservingOptionNew <span class="string">context:</span>nil];</span><br></pre></td></tr></table></figure><p>实现监听:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:<span class="string">@"contentOffset"</span>]) &#123;</span><br><span class="line">        <span class="comment">// 取出contentOffset值</span></span><br><span class="line">        <span class="built_in">CGPoint</span> contentOffset = ((<span class="built_in">NSValue</span> *)change[<span class="built_in">NSKeyValueChangeNewKey</span>]).CGPointValue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 改变高度</span></span><br><span class="line">        <span class="keyword">if</span> (contentOffset.y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            _parallaxHeaderHeightConstraint.equalTo(@(ParallaxHeaderHeight - contentOffset.y));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _parallaxHeaderHeightConstraint.equalTo(@(ParallaxHeaderHeight));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后别忘了取消KVO:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [_tableView <span class="string">removeObserver:</span>self <span class="string">forKeyPath:</span>@<span class="string">"contentOffset"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p><code>NSLayoutConstraint</code>的<code>constant</code>属性非常有用，既可以做动画，也可以方便的调整现有布局，大家多多挖掘哈~</p><h2 id="Case-2-动态变高度的UITableViewCell"><a href="#Case-2-动态变高度的UITableViewCell" class="headerlink" title="Case 2: 动态变高度的UITableViewCell"></a>Case 2: 动态变高度的UITableViewCell</h2><p>嗯，又是UITableViewCell=。=<br>只不过这次的是“动态改变高度”，就是类似于微信朋友圈里面的“全文”那种效果。</p><p>单纯的不定高UITableViewCell不是本例子的重点，详细请看<a href="http://tutuge.me/2015/08/08/autolayout-example-with-masonry2/">有趣的Autolayout示例2-Masonry实现</a>里面的Case1。</p><p>先说一点我觉得在代码设计上比较重要的地方：<strong>Cell只负责显示内容，不应该保存具体的状态信息</strong>。  </p><p>我们都知道，UITableViewCell是会被重用的，也就是说，不能保证UITableView里面的哪一行一定由哪一个UITableViewCell实例展示。<br>动态展开、收回Cell的时候，我们需要一个BOOL变量，用于保存当前Cell的展开、收回的状态。这个BOOL变量就是所谓的“<strong>状态</strong>”，这个状态应该保存在当前Cell的数据里面，如Entity、ViewModel里面。对Cell填充数据的时候，再根据这个“状态”，修改对应的约束。</p><h3 id="主要步骤-1"><a href="#主要步骤-1" class="headerlink" title="主要步骤"></a>主要步骤</h3><p>先看看大致的步骤：</p><ol><li>通过点击的Cell找到对应的数据Entity。</li><li>改变这一行数据Entity用于保存状态的BOOL变量的值。</li><li>让UITableView刷新这一行。</li><li>刷新的时候，Cell根据这个BOOL变量重新调整约束、填充数据，得到新的高度。</li><li>最后就是Cell的高度变化。（此时的这一行的Cell实例并不一定是之前的那个实例）</li></ol><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>为了尽量简单，例子里面的Cell只有三个子控件，第一个UILabel是标题等调试信息，第二个UILabel用来显示多行文本，最后一个UIButton用来切换展开、收回的状态。大致的布局如下：</p><p><img src="/2015/12/14/autolayout-example-with-masonry3/blog_autolayout_example_with_masonry3_3.png" alt="Case2 UITableViewCell布局示意"></p><h4 id="布局的代码"><a href="#布局的代码" class="headerlink" title="布局的代码"></a>布局的代码</h4><p><strong>标题UIlabel</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">_titleLabel</span> = [UILabel new]<span class="comment">;</span></span><br><span class="line"><span class="section">[self.contentView addSubview:_titleLabel]</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[_titleLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span></span><br><span class="line"><span class="section">    make.height.equalTo(@21);</span></span><br><span class="line"><span class="section">    make.left.and.right.and.top.equalTo(self.contentView).with.insets(UIEdgeInsetsMake(4, 8, 4, 8));</span></span><br><span class="line"><span class="section">&#125;]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>底部“More”按钮</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_moreButton = [UIButton <span class="string">buttonWithType:</span>UIButtonTypeSystem];</span><br><span class="line">[_moreButton <span class="string">setTitle:</span>@<span class="string">"More"</span> <span class="string">forState:</span>UIControlStateNormal];</span><br><span class="line">[_moreButton <span class="string">addTarget:</span>self <span class="string">action:</span><span class="meta">@selector</span>(<span class="string">switchExpandedState:</span>) <span class="string">forControlEvents:</span>UIControlEventTouchUpInside];</span><br><span class="line">[self.contentView <span class="string">addSubview:</span>_moreButton];</span><br><span class="line"></span><br><span class="line">[_moreButton <span class="string">mas_makeConstraints:</span>^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.height.equalTo(@<span class="number">32</span>);</span><br><span class="line">    make.left.and.right.and.bottom.equalTo(self.contentView);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p><strong>正文UIlabel</strong></p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CGFloat preferredMaxWidth = [UIScreen mainScreen].bounds.<span class="built_in">size</span>.width - <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Content - 多行</span></span><br><span class="line"><span class="variable">_contentLabel</span> = [UILabel new];</span><br><span class="line"><span class="variable">_contentLabel</span>.numberOfLines = <span class="number">0</span>;</span><br><span class="line"><span class="variable">_contentLabel</span>.lineBreakMode = NSLineBreakByCharWrapping;</span><br><span class="line"><span class="variable">_contentLabel</span>.clipsToBounds = YES;</span><br><span class="line"><span class="variable">_contentLabel</span>.preferredMaxLayoutWidth = preferredMaxWidth; <span class="comment">// 多行时必须设置</span></span><br><span class="line">[self.contentView addSubview:<span class="variable">_contentLabel</span>];</span><br><span class="line"></span><br><span class="line">[<span class="variable">_contentLabel</span> mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.left.<span class="built_in">and</span>.right.equalTo(self.contentView).<span class="keyword">with</span>.insets(UIEdgeInsetsMake(<span class="number">4</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">8</span>));</span><br><span class="line">    make.top.equalTo(<span class="variable">_titleLabel</span>.mas_bottom).<span class="keyword">with</span>.offset(<span class="number">4</span>);</span><br><span class="line">    make.bottom.equalTo(<span class="variable">_moreButton</span>.mas_top).<span class="keyword">with</span>.offset(-<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 先加上高度的限制</span></span><br><span class="line">    <span class="variable">_contentHeightConstraint</span> = make.height.equalTo(@<span class="number">64</span>).<span class="keyword">with</span>.priorityHigh(); <span class="comment">// 优先级只设置成High,比正常的高度约束低一些,防止冲突</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="为什么要加正文UIlabel高度约束"><a href="#为什么要加正文UIlabel高度约束" class="headerlink" title="为什么要加正文UIlabel高度约束"></a>为什么要加正文UIlabel高度约束</h4><p><a href="http://tutuge.me/2015/08/08/autolayout-example-with-masonry2/">有趣的Autolayout示例2-Masonry实现</a>里面的Case1也讲过，获取Cell的高度的方法是<code>systemLayoutSizeFittingSize:</code>，如果不对正文UILabel加上高度约束，获取的高度就是根据正文的内容计算出来的，这与之前的例子里面一致。</p><p>为了使高度固定，就需要加上一个高度约束，使得<code>systemLayoutSizeFittingSize:</code>计算时按照这个约束去计算。</p><h4 id="为什么正文UILabel的高度约束的优先级要调整为High"><a href="#为什么正文UILabel的高度约束的优先级要调整为High" class="headerlink" title="为什么正文UILabel的高度约束的优先级要调整为High"></a>为什么正文UILabel的高度约束的优先级要调整为<code>High</code></h4><p>在UITableView刷新时，会先计算高度，即先调用<code>tableView: heightForRowAtIndexPath:</code>方法，如果高度约束为默认的1000最高的话，会产生冲突。</p><p>因为在计算的时候，我们的高度是由一个“template cell”填充内容后计算得来，这个时候的高度已经是展开以后的高度，当前的Cell还来不及调整约束（甚至不会调整，如果只用<code>beginUpdates和endUpdates</code>更新的话，Cell不会reload），所以降低这个高度约束的优先级，去掉冲突。</p><h3 id="使用install和uninstall控制约束"><a href="#使用install和uninstall控制约束" class="headerlink" title="使用install和uninstall控制约束"></a>使用install和uninstall控制约束</h3><p>为了能得正确高度，Cell需要根据具体的数据、状态更新约束。<br>这里可以使用<code>install</code>和<code>uninstall</code>来控制正文UILabel高度约束是否生效。在填充Cell的数据时，就可以根据状态BOOL值来选择调用：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">setEntity</span><span class="selector-pseudo">:(Case8DataEntity</span> *)<span class="selector-tag">entity</span> <span class="selector-tag">indexPath</span><span class="selector-pseudo">:(NSIndexPath</span> *)<span class="selector-tag">indexPath</span> &#123;</span><br><span class="line">    <span class="comment">// 设置数据...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变约束</span></span><br><span class="line">    <span class="selector-tag">if</span> (_entity.expanded) &#123;</span><br><span class="line">        <span class="selector-attr">[_contentHeightConstraint uninstall]</span>;</span><br><span class="line">    &#125; <span class="selector-tag">else</span> &#123;</span><br><span class="line">        <span class="selector-attr">[_contentHeightConstraint install]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建Delegate，使得Cell的事件得以回传到ViewController"><a href="#创建Delegate，使得Cell的事件得以回传到ViewController" class="headerlink" title="创建Delegate，使得Cell的事件得以回传到ViewController"></a>创建Delegate，使得Cell的事件得以回传到ViewController</h3><p>在点击Cell的“More”按钮时，需要改变当前的展开收回状态BOOL值，还需要让UITableView刷新。<br>直接在Cell里面修改Entity数据，或者持有UITableView实例都是不恰当的，这个时候可以用Delegate模式实现。</p><p>Delegate如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@protocol</span> Case8CellDelegate &lt;NSObject&gt;</span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">case8Cell:</span>(Case8Cell *)cell <span class="string">switchExpandedStateWithIndexPath:</span>(NSIndexPath *)index;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure><p>然后ViewController实现这个Protocol</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="keyword">case</span><span class="number">8</span>Cell:(Case<span class="number">8</span>Cell *)cell switchExpandedStateWithIndexPath:(NSIndexPath *)index &#123;</span><br><span class="line">    <span class="comment">// 取出对应数据</span></span><br><span class="line">    Case<span class="number">8</span>DataEntity *<span class="keyword">case</span><span class="number">8</span>DataEntity = <span class="number">_</span>data[(NSUInteger) index.row];</span><br><span class="line">    <span class="comment">// 修改状态</span></span><br><span class="line">    <span class="keyword">case</span><span class="number">8</span>DataEntity.expanded = !<span class="keyword">case</span><span class="number">8</span>DataEntity.expanded; <span class="comment">// 切换展开还是收回</span></span><br><span class="line">    <span class="keyword">case</span><span class="number">8</span>DataEntity.cellHeight = <span class="number">0</span>; <span class="comment">// 重置高度缓存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新UITableView</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cell保存ViewController这个delegate，然后在按钮点击时回调</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cellb保存delegate，注意weak</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">id</span> &lt;Case8CellDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cell的“More”按钮点击</span></span><br><span class="line">- (<span class="keyword">void</span>)switchExpandedState:(<span class="built_in">UIButton</span> *)button &#123;</span><br><span class="line">    [_delegate case8Cell:<span class="keyword">self</span> switchExpandedStateWithIndexPath:_indexPath];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="刷新的方式"><a href="#刷新的方式" class="headerlink" title="刷新的方式"></a>刷新的方式</h3><p>UITableView的刷新可以用以下几种方法：</p><h4 id="1-reloadData"><a href="#1-reloadData" class="headerlink" title="1. reloadData"></a>1. reloadData</h4><p>用<code>reloadData</code>刷新，其实就是把所有Cell都刷新了一次，代价有点大，不推荐。</p><h4 id="2-reloadRowsAtIndexPaths-withRowAnimation"><a href="#2-reloadRowsAtIndexPaths-withRowAnimation" class="headerlink" title="2. reloadRowsAtIndexPaths:withRowAnimation:"></a>2. reloadRowsAtIndexPaths:withRowAnimation:</h4><p>这个方法的好处就是可以指定要刷新的哪几行，而且可以指定刷新时的动画形式，一般来说用<code>UITableViewRowAnimationFade</code>就不错。<br>刷新的时候，<code>tableView:cellForRowAtIndexPath:</code>会被调用，原来的Cell实例会被替换。</p><h4 id="3-beginUpdates和endUpdates"><a href="#3-beginUpdates和endUpdates" class="headerlink" title="3. beginUpdates和endUpdates"></a>3. beginUpdates和endUpdates</h4><p>这两个方法一般都是成对使用的，在中间可以执行插入、删除等调整Cell的操作，改变Cell的高度也可以用它。<br>不过要注意的是，这两个方法并不会重新加载Cell，只是单纯的改变了高度，所以如果Cell原来的约束里面有高度约束这种，而又保持默认的优先级，就会产生约束冲突。</p><p>从效果上来讲，我个人觉得用<code>reloadRowsAtIndexPaths:withRowAnimation:</code>会更好一些~</p><h3 id="小节-1"><a href="#小节-1" class="headerlink" title="小节"></a>小节</h3><p>想用好Autolayout不容易啊，要仔细研究UITableView的机制=。=</p><h2 id="Case-3-两种方式实现等间距"><a href="#Case-3-两种方式实现等间距" class="headerlink" title="Case 3: 两种方式实现等间距"></a>Case 3: 两种方式实现等间距</h2><p>等间距，也就是View之间的X或Y轴上的坐标等差，在这里我只举出水平方向上的等间距，垂直方向上一个道理。</p><h3 id="方法1：利用透明等宽的占位View填充空白处，实现等间距"><a href="#方法1：利用透明等宽的占位View填充空白处，实现等间距" class="headerlink" title="方法1：利用透明等宽的占位View填充空白处，实现等间距"></a>方法1：利用透明等宽的占位View填充空白处，实现等间距</h3><p>步骤很简单，就是循环创建真正要展示的View和占位View，布局如下：</p><p><img src="/2015/12/14/autolayout-example-with-masonry3/blog_autolayout_example_with_masonry3_4.png" alt="利用占位View实现等间距"></p><p>说明一下：</p><ul><li>占位View的宽度不能定死，这样外部的父级View宽度变化时，内部的View仍然可以保持等间距。</li><li>既然占位View宽度不定，总得有个宽度的参照，这个参照就是其它的占位View，也就是说，要给占位View加上两两宽度相等的约束。</li></ul><p>代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先创建第一个占位View</span></span><br><span class="line">UIView *lastSpaceView = [UIView <span class="built_in">new</span>];</span><br><span class="line">lastSpaceView.backgroundColor = [UIColor greenColor]; <span class="comment">// 用绿色标出</span></span><br><span class="line">[_containerView1 addSubview:lastSpaceView];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加上左下三个约束</span></span><br><span class="line">[lastSpaceView mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) &#123;</span><br><span class="line">    <span class="built_in">make</span>.left.and.top.and.bottom.equalTo(_containerView1);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环创建</span></span><br><span class="line"><span class="keyword">for</span> (NSUInteger i = <span class="number">0</span>; i &lt; ITEM_COUNT; i++) &#123;</span><br><span class="line">    <span class="comment">// 创建ItemView，即真正显示内容的View</span></span><br><span class="line">    UIView *itemView = [self getItemViewWithIndex:i];</span><br><span class="line">    [_containerView1 addSubview:itemView];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 固定宽高，左边、垂直方向中心与上一个占位View对齐。</span></span><br><span class="line">    [itemView mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) &#123;</span><br><span class="line">        <span class="built_in">make</span>.height.and.width.equalTo(@(ITEM_SIZE));</span><br><span class="line">        <span class="built_in">make</span>.left.equalTo(lastSpaceView.mas_right);</span><br><span class="line">        <span class="built_in">make</span>.centerY.equalTo(_containerView1.mas_centerY);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建下一个占位View</span></span><br><span class="line">    UIView *spaceView = [UIView <span class="built_in">new</span>];</span><br><span class="line">    spaceView.backgroundColor = [UIColor greenColor];</span><br><span class="line">    [_containerView1 addSubview:spaceView];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左边与当前ItemView对齐，上下与边界对齐，宽度与上一个占位View相等！</span></span><br><span class="line">    <span class="comment">// 但是右边的约束不能加，因为要留给下一次循环与下一个ItemView的左边界添加</span></span><br><span class="line">    [spaceView mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) &#123;</span><br><span class="line">        <span class="built_in">make</span>.left.equalTo(itemView.mas_right).with.priorityHigh(); <span class="comment">// 降低优先级，防止宽度不够出现约束冲突</span></span><br><span class="line">        <span class="built_in">make</span>.top.and.bottom.equalTo(_containerView1);</span><br><span class="line">        <span class="built_in">make</span>.width.equalTo(lastSpaceView.mas_width);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新</span></span><br><span class="line">    lastSpaceView = spaceView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为最后一个占位View添加右边约束</span></span><br><span class="line">[lastSpaceView mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) &#123;</span><br><span class="line">    <span class="built_in">make</span>.right.equalTo(_containerView1.mas_right);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>像这种重复添加View和约束，合理使用变量保存“上一次循环”创建的占位View，就可以大大简化代码，而且可以任意调整数量~</p><h3 id="方法2：直接按比例设置multiplier"><a href="#方法2：直接按比例设置multiplier" class="headerlink" title="方法2：直接按比例设置multiplier"></a>方法2：直接按比例设置multiplier</h3><p>等间距，其实就是按比例，再进一步就是x坐标是按比例的。<br>延伸到View上，可以理解为centerX的值与父级View的宽度按比例增减。  </p><p>但是，读者可以尝试一下，直接设置一个View的边界、位置属性，如centerX，等于其父级View的宽度是会报错的。</p><p>难道就没有办法了？当然不是。</p><p><strong>始终在坐标系上考虑约束</strong></p><p>在上一篇<a href="http://tutuge.me/2015/08/08/autolayout-example-with-masonry2/">有趣的Autolayout示例2-Masonry实现</a>的开头我也提到过，Autolayout最终都是体现在坐标系上，一切都会按照<code>viewA-attribute = viewB-attribute * multiplier + constant</code>这种公式去计算，既然centerX不能跟父级的Width宽度一起加约束，那就换一个，如父级的<strong>右边界</strong>，父级View的<strong>右边界</strong>在父级本身的参照系下的Y坐标值不就等于其宽度吗~</p><p>所以，可以按照如下方式加约束：</p><p><img src="/2015/12/14/autolayout-example-with-masonry3/blog_autolayout_example_with_masonry3_5.png" alt="按比例设置multiplier实现等间距"></p><p>对应的代码也会异常简单：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环创建</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; ITEM_COUNT; i++) &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *itemView = [<span class="keyword">self</span> getItemViewWithIndex:i];</span><br><span class="line">    [_containerView2 addSubview:itemView];</span><br><span class="line"></span><br><span class="line">    [itemView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        <span class="comment">// 宽高一定</span></span><br><span class="line">        make.width.and.height.equalTo(@(ITEM_SIZE));</span><br><span class="line">        <span class="comment">// 确定Y坐标</span></span><br><span class="line">        make.centerY.equalTo(_containerView2.mas_centerY);</span><br><span class="line">        <span class="comment">// 确定X坐标，注意分子分母都要加1</span></span><br><span class="line">        make.centerX.equalTo(_containerView2.mas_right).multipliedBy(((<span class="built_in">CGFloat</span>)i + <span class="number">1</span>) / ((<span class="built_in">CGFloat</span>)ITEM_COUNT + <span class="number">1</span>));</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小节-2"><a href="#小节-2" class="headerlink" title="小节"></a>小节</h3><p>很多时候，灵活的使用multiplier能大大简化开发~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>三个例子说完了，你有啥收获呢~？:-D</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;更新&quot;&gt;&lt;a href=&quot;#更新&quot; class=&quot;headerlink&quot; title=&quot;更新&quot;&gt;&lt;/a&gt;更新&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;2016-06-02: 感谢&lt;a href=&quot;http://weibo.com/u/2953626141&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我不是蜡笔小新但是我有小白&lt;/a&gt;，发现了Case 2的最后两个cell展开动画问题，原来是tableView的&lt;code&gt;estimatedRowHeight&lt;/code&gt;会跟展开动画冲突的缘故。  &lt;/li&gt;
&lt;li&gt;2015-12-23: 感谢&lt;a href=&quot;https://github.com/XVXVXXX&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;XVXVXXX&lt;/a&gt;的PR,Case 1不再需要Fake Header View，直接用contentInset就好~  &lt;/li&gt;
&lt;li&gt;2015-12-17：Case3的等间距，用UIStackView实现最优雅，但是无奈只有iOS9以上支持。兼容方案如OAStackView也可以，但是在UITableViewCell里面用，或者需要频繁的增减内部View的数量时，性能损耗有点厉害，会卡。所以，还是要看需求=。=&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;第三篇来了。&lt;br&gt;依然是3个小例子，主要部分用Masonry手写代码实现，其它的约束在storyboard里面直接拖拽搭建。&lt;br&gt;至于为啥不用VFL，主要是因为它的“描述性”的写法很容易出错，没有补全、不好调试，写起来没有“代码”的感觉=。=。当然，这个仁者见仁智者见智~&lt;br&gt;三个例子分别是：&lt;strong&gt;Parallax Header&lt;/strong&gt;，&lt;strong&gt;动态变高度的UITableViewCell&lt;/strong&gt;，以及&lt;strong&gt;两种方式实现等间距&lt;/strong&gt;。原理其实都很简单，例子也都是平时积累起来的。&lt;/p&gt;
&lt;p&gt;前两篇：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一篇：&lt;a href=&quot;http://tutuge.me/2015/05/23/autolayout-example-with-masonry/&quot;&gt;有趣的Autolayout示例-Masonry实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;第二篇：&lt;a href=&quot;http://tutuge.me/2015/08/08/autolayout-example-with-masonry2/&quot;&gt;有趣的Autolayout示例2-Masonry实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;第四篇：&lt;a href=&quot;http://tutuge.me/2016/08/06/autolayout-example-with-masonry4/&quot;&gt;有趣的Autolayout示例4-Masonry实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Github地址：&lt;br&gt;&lt;a href=&quot;https://github.com/zekunyan/AutolayoutExampleWithMasonry&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/zekunyan/AutolayoutExampleWithMasonry&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2015/12/14/autolayout-example-with-masonry3/blog_autolayout_example_with_masonry3_1.gif&quot; alt=&quot;Gif示例&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="Autolayout" scheme="http://tutuge.me/tags/Autolayout/"/>
    
      <category term="Masonry" scheme="http://tutuge.me/tags/Masonry/"/>
    
  </entry>
  
  <entry>
    <title>Swift开源项目: TTGEmojiRate的实现</title>
    <link href="http://tutuge.me/2015/10/25/ttgemojirate-lib/"/>
    <id>http://tutuge.me/2015/10/25/ttgemojirate-lib/</id>
    <published>2015-10-25T11:32:42.000Z</published>
    <updated>2018-10-07T17:37:29.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间在Dribbble上发现了一个<a href="https://dribbble.com/shots/2211556-Rating-Version-A" target="_blank" rel="noopener">Rating控件</a>的演示动画，控件以Emoji表情为基础，结合了上下滑动手势，正好最近正在深入学习iOS动画、绘图相关的知识，就尝试着用<code>UIBezierPath</code>实现了出来。本文就是TTGEmojiRate的实现过程。</p><p>Github: <a href="https://github.com/zekunyan/TTGEmojiRate" target="_blank" rel="noopener">https://github.com/zekunyan/TTGEmojiRate</a></p><p><img src="/2015/10/25/ttgemojirate-lib/TTGEmojiRate_screenshot2.gif" alt="TTGEmojiRate Example"></p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先看看原本的效果：<a href="https://dribbble.com/shots/2211556-Rating-Version-A" target="_blank" rel="noopener">Rating Version A - Hoang Nguyen</a></p><p><img src="/2015/10/25/ttgemojirate-lib/TTGEmojiRate_Dribbble.gif" alt="Rating Version A - Hoang Nguyen"></p><p>可以看出来，主要的特点如下：</p><ul><li>可以上下拖动，改变Emoji表情嘴的弧度。</li><li>拖动的时候Rate的值也会随之变化，从0到5，并且跟表情的“喜怒”相对应。</li><li>颜色也会变化，从绿色到蓝色再到红色，也对应表情的“喜怒”。</li></ul><p>实际实现的时候，增加了眼睛元素，并且增强了自定义，如颜色的变化范围、线条的粗细等都可以设定，基本的思路还是不变的。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>开始写代码之前，先理理思路。</p><p>拖动的时候，直接影响的应该是Rate值，然后在Rate值改变的时候刷新整个控件，刷新的时候重绘。重绘的时候，嘴、眼睛的弧度，颜色的值都要根据Rate值重新计算，如下图：</p><p><img src="/2015/10/25/ttgemojirate-lib/blog_ttgemojirate_1.png" alt="Image"></p><h3 id="拖动改变Rate值"><a href="#拖动改变Rate值" class="headerlink" title="拖动改变Rate值"></a>拖动改变Rate值</h3><p>这个还是很容易实现的，直接重写<code>UIView</code>的touch相关的三个方法，在里面记录拖动在Y轴上的变化值，然后映射到Rate值上就可以了。</p><p>先声明一个CGPoint属性，用来保存手指按下时的点位置：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> touchPoint: <span class="type">CGPoint?</span> = <span class="literal">nil</span></span><br></pre></td></tr></table></figure></p><p>在手指移动的时候，在<code>touchesMoved</code>方法里面计算当前点跟上一次触摸点的Y轴上的<strong>差值</strong>，然后映射到Rate值上。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">touchesMoved</span><span class="params">(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前触摸点</span></span><br><span class="line">    <span class="keyword">let</span> currentPoint = touches.first?.locationInView(<span class="keyword">self</span>)</span><br><span class="line">    <span class="comment">// 改变Rate值</span></span><br><span class="line">    rateValue = rateValue + <span class="type">Float</span>((currentPoint!.y - touchPoint!.y) / <span class="type">CGRectGetHeight</span>(<span class="keyword">self</span>.bounds) * rateDragSensitivity)</span><br><span class="line">    <span class="comment">// 保存当前触摸点</span></span><br><span class="line">    touchPoint = currentPoint</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>计算Y轴差值的时候，除以了当前控件的高度，这是为了保证Rate值按比例增减。</li><li>增加了一个<code>rateDragSensitivity</code>属性，用来调节改变Rate值的“灵敏度”</li></ul><h3 id="UIBezierPath-贝塞尔曲线"><a href="#UIBezierPath-贝塞尔曲线" class="headerlink" title="UIBezierPath - 贝塞尔曲线"></a>UIBezierPath - 贝塞尔曲线</h3><p>控件的主要内容都是用<code>UIBezierPath</code>绘制出来的。网上关于<code>UIBezierPath</code>的讲解很多，在这里就不详细说了。</p><p>简单来说，<code>UIBezierPath</code>用来绘制矢量路径，是一种参数曲线，在使用的时候，只需要先设定好锚点、控制点，系统就可以根据贝塞尔曲线的算法，绘制出对应的线，并且保证锚点和对应的控制点的连线与曲线相切。</p><p>这里有一个演示绘制贝塞尔曲线过程的网站：<a href="http://myst729.github.io/bezier-curve/" target="_blank" rel="noopener">Bézier curve</a></p><h3 id="脸"><a href="#脸" class="headerlink" title="脸"></a>脸</h3><p>脸是最简单的，就是一个圆，直接用一个方法就可以：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">drawFaceWithRect</span><span class="params">(rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> facePath = <span class="type">UIBezierPath</span>(ovalInRect: rect)</span><br><span class="line">    rateColor.setStroke()</span><br><span class="line">    facePath.lineWidth = rateLineWidth <span class="comment">// 线粗细</span></span><br><span class="line">    facePath.stroke()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际实现的时候可以加上Margin，防止线画到View的边界之外。</p><h3 id="嘴、眼睛"><a href="#嘴、眼睛" class="headerlink" title="嘴、眼睛"></a>嘴、眼睛</h3><p>先看看<code>UIBezierPath</code>提供的可以用来绘制曲线的方法：<br><code>addCurveToPoint(_:controlPoint1:controlPoint2:)</code>和<code>addQuadCurveToPoint(_:controlPoint:)</code>，如下图:</p><p><img src="/2015/10/25/ttgemojirate-lib/blog_ttgemojirate_2.png" alt="UIBezierPath"></p><p>直观上来讲，嘴、眼睛的绘制跟<code>addQuadCurveToPoint</code>方法绘制的效果基本一致，但是这样的效果没法调整，因为只能控制唯一的一个控制点，所以还是要用<code>addCurveToPoint</code>方法，对称的绘制两条曲线，拼接起来，如下图：</p><p><img src="/2015/10/25/ttgemojirate-lib/blog_ttgemojirate_3.png" alt="Curve拼接"></p><p>这样的话，就可以通过调整两个控制点，来控制嘴、眼睛的弯曲宽度、形状。</p><p>以绘制嘴为例：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> func drawMouthWithRect(<span class="built_in">rect</span>: CGRect) &#123;</span><br><span class="line">    let <span class="built_in">width</span> = CGRectGetWidth(<span class="built_in">rect</span>)</span><br><span class="line">    let <span class="built_in">height</span> = CGRectGetWidth(<span class="built_in">rect</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左端点</span></span><br><span class="line">    let leftPoint = CGPointMake(</span><br><span class="line">        <span class="built_in">width</span> * (<span class="number">1</span> - rateMouthWidth) / <span class="number">2</span>,</span><br><span class="line">        <span class="built_in">height</span> * (<span class="number">1</span> - rateMouthVerticalPosition))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右端点</span></span><br><span class="line">    let rightPoint = CGPointMake(</span><br><span class="line">        <span class="built_in">width</span> - leftPoint.x,</span><br><span class="line">        leftPoint.y)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中间点 - Y值根据当前的Rate值计算，0.3为系数</span></span><br><span class="line">    let centerPoint = CGPointMake(</span><br><span class="line">        <span class="built_in">width</span> / <span class="number">2</span>,</span><br><span class="line">        leftPoint.y + <span class="built_in">height</span> * <span class="number">0.3</span> * (CGFloat(rateValue) - <span class="number">2.5</span>) / <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制点跟中间点在X轴上的距离</span></span><br><span class="line">    let halfLipWidth = <span class="built_in">width</span> * rateMouthWidth * rateLipWidth / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建贝塞尔曲线</span></span><br><span class="line">    let mouthPath = UIBezierPath()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动到起始点</span></span><br><span class="line">    mouthPath.moveToPoint(leftPoint)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加左半边曲线路径</span></span><br><span class="line">    mouthPath.addCurveToPoint(</span><br><span class="line">        centerPoint,</span><br><span class="line">        controlPoint1: leftPoint,</span><br><span class="line">        controlPoint2: CGPointMake(centerPoint.x - halfLipWidth, centerPoint.y))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加右半边曲线路径</span></span><br><span class="line">    mouthPath.addCurveToPoint(</span><br><span class="line">        rightPoint,</span><br><span class="line">        controlPoint1: CGPointMake(centerPoint.x + halfLipWidth, centerPoint.y),</span><br><span class="line">        controlPoint2: rightPoint)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定样式</span></span><br><span class="line">    mouthPath.lineCapStyle = CGLineCap.Round;</span><br><span class="line">    rateColor.setStroke()</span><br><span class="line">    mouthPath.lineWidth = rateLineWidth</span><br><span class="line">    mouthPath.<span class="built_in">stroke</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>所有的距离、坐标都是根据当前控件的大小计算出来的。</li><li><code>rateMouthWidth</code>为嘴的宽度与整个控件宽度的比值，即相对值。</li><li><code>rateMouthVerticalPosition</code>为嘴的左右两个端点的Y轴坐标值，也为相对值。</li><li><code>rateLipWidth</code>为中心点的两个控制点的距离与嘴宽度的比值，也是相对值。</li></ul><p>眼睛的绘制跟嘴原理一致，就不再说明。</p><h3 id="颜色的渐变"><a href="#颜色的渐变" class="headerlink" title="颜色的渐变"></a>颜色的渐变</h3><p>Dribbble的演示中，控件的线条颜色也是会变化的，从红色到蓝色再到绿色，是连续变化的。这个时候用常见的<strong>RGB色彩模式</strong>是不好控制的，效果也不好。</p><p>所以这个时候要用<strong>HSB色彩模式</strong></p><blockquote><p>HSB 色彩模式是基于人眼的一种颜色模式。是普及型设计软件中常见的色彩模式，其中H代表色相；S代表饱和度；B代表亮度。- <a href="http://baike.baidu.com/view/1006662.htm" target="_blank" rel="noopener">百度百科</a></p></blockquote><p><img src="/2015/10/25/ttgemojirate-lib/blog_ttgemojirate_4.jpg" alt="HSB色彩模式"></p><p>对应到<code>UIColor</code>类，就是下面两个方法：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建UIColor</span></span><br><span class="line">init(<span class="built_in">hue</span> <span class="built_in">hue</span>: CGFloat, <span class="built_in">saturation</span> <span class="built_in">saturation</span>: CGFloat, <span class="built_in">brightness</span> <span class="built_in">brightness</span>: CGFloat, <span class="built_in">alpha</span> <span class="built_in">alpha</span>: CGFloat)</span><br><span class="line"><span class="comment">// 获取HSB值，注意参数</span></span><br><span class="line">func getHue(_ <span class="built_in">hue</span>: UnsafeMutablePointer&lt;CGFloat&gt;, <span class="built_in">saturation</span> <span class="built_in">saturation</span>: UnsafeMutablePointer&lt;CGFloat&gt;, <span class="built_in">brightness</span> <span class="built_in">brightness</span>: UnsafeMutablePointer&lt;CGFloat&gt;, <span class="built_in">alpha</span> <span class="built_in">alpha</span>: UnsafeMutablePointer&lt;CGFloat&gt;) -&gt; Bool</span><br></pre></td></tr></table></figure><p>实现的时候，为了增加可定制性，控件颜色的变化范围是可以设置的，用以下属性保存：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> var <span class="string">rateColorRange:</span> (<span class="string">from:</span> UIColor, <span class="string">to:</span> UIColor)</span><br></pre></td></tr></table></figure><p>刷新时，就可以根据当前的Rate值，重新计算颜色的HSB和alpha值：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let rate: CGFloat = CGFloat(rateValue / <span class="number">5</span>) <span class="comment">// Rate值归一化</span></span><br><span class="line"></span><br><span class="line">self.rateColor = UIColor.init(</span><br><span class="line"><span class="symbol">    hue:</span> hueFrom + hueDelta * rate, <span class="comment">// 色相</span></span><br><span class="line"><span class="symbol">    saturation:</span> saturationFrom + saturationDelta * rate, <span class="comment">// 饱和度</span></span><br><span class="line"><span class="symbol">    brightness:</span> brightnessFrom + brightnessDelta * rate, <span class="comment">// 亮度</span></span><br><span class="line"><span class="symbol">    alpha:</span> alphaFrom + alphaDelta * rate <span class="comment">// 透明度</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>所有的颜色参数都是根据Rate值做线性增减。</li><li><code>xxxFrom</code>、<code>xxxDelta</code>分别指HSB和alpha的起始值与变化范围，在设置<code>rateColorRange</code>时计算保存下来。</li></ul><p>这样，颜色就能做到跟Rate值做连续的线性变化。</p><h3 id="善于使用didSet"><a href="#善于使用didSet" class="headerlink" title="善于使用didSet"></a>善于使用didSet</h3><p>实现控件的时候，对外暴露了很多属性，如线的宽度<code>rateLineWidth</code>、嘴的宽度<code>rateMouthWidth</code>等。为了对这些属性做校验，并且在设置后刷新控件，就要用到<code>didSet</code>。</p><p><code>didSet</code>在Swift里面，跟类的属性是一一绑定的，在对属性赋值后会被调用。</p><p>控件的大部分属性都做了校验、刷新，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Mouth width. From 0.2 to 0.7.</span></span><br><span class="line"><span class="meta">@IBInspectable</span> <span class="keyword">public</span> <span class="keyword">var</span> rateMouthWidth: <span class="type">CGFloat</span> = <span class="number">0.6</span> &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">        <span class="comment">// 判断上限</span></span><br><span class="line">        <span class="keyword">if</span> rateMouthWidth &gt; <span class="number">0.7</span> &#123;</span><br><span class="line">            rateMouthWidth = <span class="number">0.7</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断下限</span></span><br><span class="line">        <span class="keyword">if</span> rateMouthWidth &lt; <span class="number">0.2</span> &#123;</span><br><span class="line">            rateMouthWidth = <span class="number">0.2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 刷新、重绘</span></span><br><span class="line">        <span class="keyword">self</span>.setNeedsDisplay()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IBDesignable、-IBInspectable"><a href="#IBDesignable、-IBInspectable" class="headerlink" title="@IBDesignable、@IBInspectable"></a>@IBDesignable、@IBInspectable</h3><p>为了能在XIB、StoryBoard里面使用、编辑控件，就要用到<code>@IBDesignable</code>和<code>@IBInspectable</code>这两个关键字。</p><p>在类的前面加上<code>@IBDesignable</code>关键字，使IB可以预览控件：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBDesignable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmojiRateView</span>: <span class="type">UIView &#123;</span></span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在属性前面加上<code>@IBInspectable</code>，就可以在IB里面编辑属性，实时预览：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBInspectable</span> <span class="keyword">public</span> var <span class="string">rateLineWidth:</span> CGFloat = <span class="number">14</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细的使用可以参考NSHipster上的文章：<a href="http://nshipster.cn/ibinspectable-ibdesignable/" target="_blank" rel="noopener">IBInspectable / IBDesignable</a></p><p>最后，在IB里面就是下面这样：<br><img src="/2015/10/25/ttgemojirate-lib/TTGEmojiRate_IBExample.png" alt="IB example"></p><p><strong>By the way =。=</strong><br>属性名字太长，在IB里面显示不完整，咋办。。。</p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>拖动改变Rate值的时候，肯定要有回调，如下定义：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> rateValueChangeCallback: <span class="type"></span>((<span class="keyword">new</span><span class="type">RateValue</span>: <span class="keyword">Float</span>) -&gt; <span class="keyword">Void</span>)? = nil</span><br></pre></td></tr></table></figure><p>在<code>rateValue</code>的<code>didSet</code>里面回调：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBInspectable</span> <span class="keyword">public</span> <span class="keyword">var</span> rateValue: <span class="type">Float</span> = <span class="number">2.5</span> &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 回调</span></span><br><span class="line">        <span class="keyword">self</span>.rateValueChangeCallback?(newRateValue: rateValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看似简单的一个Rating控件，从构思到实现，再到完善，一点一点朝着完美去做，收获不少~</p><p>最后，Dribbble是个好地方，贝塞尔曲线好强大，XCode 7.1写Swift还是有点卡=。=</p><p>以上。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A" target="_blank" rel="noopener">维基百科 - 贝塞尔曲线</a></li><li><a href="https://developer.apple.com/library/ios/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/BezierPaths/BezierPaths.html" target="_blank" rel="noopener">Drawing Shapes Using Bézier Paths</a></li><li><a href="http://baike.baidu.com/view/1006662.htm" target="_blank" rel="noopener">HSB色彩模式</a></li><li><a href="http://nshipster.cn/ibinspectable-ibdesignable/" target="_blank" rel="noopener">IBInspectable / IBDesignable</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间在Dribbble上发现了一个&lt;a href=&quot;https://dribbble.com/shots/2211556-Rating-Version-A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Rating控件&lt;/a&gt;的演示动画，控件以Emoji表情为基础，结合了上下滑动手势，正好最近正在深入学习iOS动画、绘图相关的知识，就尝试着用&lt;code&gt;UIBezierPath&lt;/code&gt;实现了出来。本文就是TTGEmojiRate的实现过程。&lt;/p&gt;
&lt;p&gt;Github: &lt;a href=&quot;https://github.com/zekunyan/TTGEmojiRate&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/zekunyan/TTGEmojiRate&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2015/10/25/ttgemojirate-lib/TTGEmojiRate_screenshot2.gif&quot; alt=&quot;TTGEmojiRate Example&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="开源" scheme="http://tutuge.me/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="Swift" scheme="http://tutuge.me/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift写的库-TTGSnackbar</title>
    <link href="http://tutuge.me/2015/10/09/ttgsnackbar-lib/"/>
    <id>http://tutuge.me/2015/10/09/ttgsnackbar-lib/</id>
    <published>2015-10-09T11:49:09.000Z</published>
    <updated>2018-10-07T17:37:29.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><ul><li>2016-12-25: 增加多行文本的支持，增加阴影</li><li>2016-10-20: 增加ContentInset，也就是Padding的属性；增加自定义内容View; 版本1.3.0</li><li>2016-10-17: 支持Swift3；增加的顶部Top位置动画；增加同时两个Action按钮；增加带图片icon显示</li><li>2016-03-25: 版本更新到了0.5.1，补充些说明、示例</li></ul><h2 id="TTGSnackbar"><a href="#TTGSnackbar" class="headerlink" title="TTGSnackbar"></a>TTGSnackbar</h2><p>用Swift写了个简单的控件库：TTGSnackbar，模仿Android的Snackbar。目前更新到了版本1.3.0。支持多种动画，增强了自定义。</p><p>Github: <a href="https://github.com/zekunyan/TTGSnackbar" target="_blank" rel="noopener">https://github.com/zekunyan/TTGSnackbar</a></p><p><img src="/2015/10/09/ttgsnackbar-lib/TTGSnackbar_screen_shot.png" alt="Screenshot"></p><p><strong>Gif</strong></p><p><img src="/2015/10/09/ttgsnackbar-lib/TTGSnackbar_example.gif" alt="Screenshot"></p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>需要Swift3, Xcode8, iOS 8+  </p><h3 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">platform <span class="symbol">:ios</span>, <span class="string">'8.0'</span></span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">pod <span class="string">"TTGSnackbar"</span></span><br></pre></td></tr></table></figure><h3 id="Carthage"><a href="#Carthage" class="headerlink" title="Carthage"></a>Carthage</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">github</span> <span class="string">"zekunyan/TTGSnackbar"</span></span><br></pre></td></tr></table></figure><h2 id="简单的使用案例"><a href="#简单的使用案例" class="headerlink" title="简单的使用案例"></a>简单的使用案例</h2><h3 id="只显示文字"><a href="#只显示文字" class="headerlink" title="只显示文字"></a>只显示文字</h3><p><img src="/2015/10/09/ttgsnackbar-lib/TTGSnackbar_2.png" alt="Example"></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let snackbar = TTGSnackbar.init(<span class="string">message:</span> <span class="string">"Message"</span>, <span class="string">duration:</span> .Short)</span><br><span class="line">snackbar.show()</span><br></pre></td></tr></table></figure><h3 id="显示文字和一个动作按钮"><a href="#显示文字和一个动作按钮" class="headerlink" title="显示文字和一个动作按钮"></a>显示文字和一个动作按钮</h3><p><img src="/2015/10/09/ttgsnackbar-lib/TTGSnackbar_3.png" alt="Example"></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> snackbar = TTGSnackbar.init(message: <span class="string">"Message"</span>, duration: .Middle, actionText: <span class="string">"Action"</span>)</span><br><span class="line">&#123; <span class="function"><span class="params">(snackbar)</span> -&gt;</span> Void <span class="keyword">in</span></span><br><span class="line">    NSLog(<span class="string">"Click action!"</span>)</span><br><span class="line">&#125;      </span><br><span class="line">snackbar.show()</span><br></pre></td></tr></table></figure><h3 id="显示文字和一个耗时操作按钮"><a href="#显示文字和一个耗时操作按钮" class="headerlink" title="显示文字和一个耗时操作按钮"></a>显示文字和一个耗时操作按钮</h3><p><img src="/2015/10/09/ttgsnackbar-lib/TTGSnackbar_5.png" alt="Example"></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let snackbar = TTGSnackbar.<span class="keyword">init</span>(message: <span class="string">"Message"</span>, duration: .Forever, actionText: <span class="string">"Action"</span>)</span><br><span class="line">&#123; (snackbar) -&gt; <span class="built_in">Void</span> <span class="keyword">in</span></span><br><span class="line">    NSLog(<span class="string">"Click action!"</span>)</span><br><span class="line">    <span class="comment">// Dismiss manually after 3 seconds</span></span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, Int64(<span class="number">3</span> * <span class="built_in">Double</span>(NSEC_PER_SEC))), dispatch_get_main_queue()) &#123; () -&gt; <span class="built_in">Void</span> <span class="keyword">in</span></span><br><span class="line">        snackbar.dismiss()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;      </span><br><span class="line">snackbar.show()</span><br></pre></td></tr></table></figure><h3 id="显示文字和两个动作按钮"><a href="#显示文字和两个动作按钮" class="headerlink" title="显示文字和两个动作按钮"></a>显示文字和两个动作按钮</h3><p><img src="/2015/10/09/ttgsnackbar-lib/TTGSnackbar_9.png" alt="Example"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let snackbar: TTGSnackbar = TTGSnackbar.init(message: <span class="string">"Two actions !"</span>, duration: .Long)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Action 1</span></span><br><span class="line">snackbar<span class="selector-class">.actionText</span> = <span class="string">"Yes"</span></span><br><span class="line">snackbar<span class="selector-class">.actionTextColor</span> = UIColor.greenColor()</span><br><span class="line">snackbar<span class="selector-class">.actionBlock</span> = &#123; (snackbar) <span class="keyword">in</span> NSLog(<span class="string">"Click Yes !"</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Action 2</span></span><br><span class="line">snackbar<span class="selector-class">.secondActionText</span> = <span class="string">"No"</span></span><br><span class="line">snackbar<span class="selector-class">.secondActionTextColor</span> = UIColor.yellowColor()</span><br><span class="line">snackbar<span class="selector-class">.secondActionBlock</span> = &#123; (snackbar) <span class="keyword">in</span> NSLog(<span class="string">"Click No !"</span>) &#125;</span><br><span class="line"></span><br><span class="line">snackbar.show()</span><br></pre></td></tr></table></figure><h2 id="显示文字和图片ICON"><a href="#显示文字和图片ICON" class="headerlink" title="显示文字和图片ICON"></a>显示文字和图片ICON</h2><p><img src="https://github.com/zekunyan/TTGSnackbar/raw/master/Resources/snackbar_5.jpg" alt="Example"></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let <span class="string">snackbar:</span> TTGSnackbar = TTGSnackbar.init(<span class="string">message:</span> <span class="string">"Two actions !"</span>, <span class="string">duration:</span> .Long)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add icon image</span></span><br><span class="line">snackbar.icon = UIImage.init(<span class="string">named:</span> <span class="string">"emoji_cool_small"</span>)</span><br><span class="line"></span><br><span class="line">snackbar.show()</span><br></pre></td></tr></table></figure><h2 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h2><p>可以自定义文字的字体、颜色，动作按钮的字体、颜色，回调等等，详细的请看Github的README说明。😊</p><h2 id="总之"><a href="#总之" class="headerlink" title="总之"></a>总之</h2><p>一时兴起写了个简单的库，后来发现居然有人提交PR、issue，不敢怠慢啊，也就坚持了下来，断断续续更新了10个小版本了=。=（2016年3月25号，25周岁前一天-_-|||）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;更新&quot;&gt;&lt;a href=&quot;#更新&quot; class=&quot;headerlink&quot; title=&quot;更新&quot;&gt;&lt;/a&gt;更新&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;2016-12-25: 增加多行文本的支持，增加阴影&lt;/li&gt;
&lt;li&gt;2016-10-20: 增加ContentInset，也就是Padding的属性；增加自定义内容View; 版本1.3.0&lt;/li&gt;
&lt;li&gt;2016-10-17: 支持Swift3；增加的顶部Top位置动画；增加同时两个Action按钮；增加带图片icon显示&lt;/li&gt;
&lt;li&gt;2016-03-25: 版本更新到了0.5.1，补充些说明、示例&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;TTGSnackbar&quot;&gt;&lt;a href=&quot;#TTGSnackbar&quot; class=&quot;headerlink&quot; title=&quot;TTGSnackbar&quot;&gt;&lt;/a&gt;TTGSnackbar&lt;/h2&gt;&lt;p&gt;用Swift写了个简单的控件库：TTGSnackbar，模仿Android的Snackbar。目前更新到了版本1.3.0。支持多种动画，增强了自定义。&lt;/p&gt;
&lt;p&gt;Github: &lt;a href=&quot;https://github.com/zekunyan/TTGSnackbar&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/zekunyan/TTGSnackbar&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2015/10/09/ttgsnackbar-lib/TTGSnackbar_screen_shot.png&quot; alt=&quot;Screenshot&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gif&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2015/10/09/ttgsnackbar-lib/TTGSnackbar_example.gif&quot; alt=&quot;Screenshot&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="开源" scheme="http://tutuge.me/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="Swift" scheme="http://tutuge.me/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>有趣的Autolayout示例2-Masonry实现</title>
    <link href="http://tutuge.me/2015/08/08/autolayout-example-with-masonry2/"/>
    <id>http://tutuge.me/2015/08/08/autolayout-example-with-masonry2/</id>
    <published>2015-08-07T16:55:52.000Z</published>
    <updated>2018-10-07T17:37:29.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Masonry写的Autolayout示例又来了，仍然是三个小例子，分别是<strong>变高度的UITableViewCell、topLayoutGuide与bottomLayoutGuide，还有自定义的baseline</strong>，外加两个基本的知识点讲解，说不上“有趣”=。=，比较基础，写了很多，各位随意看看吧~</p><ul><li>第一篇: <a href="http://tutuge.me/2015/05/23/autolayout-example-with-masonry/">有趣的Autolayout示例-Masonry实现</a>  </li><li>第三篇: <a href="http://tutuge.me/2015/12/14/autolayout-example-with-masonry3/">有趣的Autolayout示例3-Masonry实现</a></li><li>第四篇: <a href="http://tutuge.me/2016/08/06/autolayout-example-with-masonry4/">有趣的Autolayout示例4-Masonry实现</a></li></ul><p>Github地址：<br><a href="https://github.com/zekunyan/AutolayoutExampleWithMasonry" target="_blank" rel="noopener">https://github.com/zekunyan/AutolayoutExampleWithMasonry</a></p><p><img src="/2015/08/08/autolayout-example-with-masonry2/blog_autolayout_example_with_masonry2_1.gif" alt="Gif示例"></p><a id="more"></a><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>先讲讲两个知识点，很基础，但是很容易被忽略。</p><h3 id="坐标系、top、right、offset"><a href="#坐标系、top、right、offset" class="headerlink" title="坐标系、top、right、offset"></a>坐标系、top、right、offset</h3><p>先看看Masonry的Github主页的示例代码：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UIEdgeInsets padding = UIEdgeInsetsMake(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.<span class="built_in">top</span>.equalTo(superview.mas_top).<span class="built_in">with</span>.offset(padding.<span class="built_in">top</span>);</span><br><span class="line">    make.<span class="built_in">left</span>.equalTo(superview.mas_left).<span class="built_in">with</span>.offset(padding.<span class="built_in">left</span>);</span><br><span class="line">    make.<span class="built_in">bottom</span>.equalTo(superview.mas_bottom).<span class="built_in">with</span>.offset(-padding.<span class="built_in">bottom</span>);</span><br><span class="line">    make.<span class="built_in">right</span>.equalTo(superview.mas_right).<span class="built_in">with</span>.offset(-padding.<span class="built_in">right</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>代码的意思很简单，就是view1的上下左右边距为padding对应的值。</p><p>但是，为什么bottom、right的offset是<strong>负数</strong>呢？</p><p>其实无论是Autolayout还是直接写frame，最终的结果都是要把我们的控件按照正确的位置绘制在屏幕上，也就是说，在一个统一的坐标系下，如下：</p><p><img src="/2015/08/08/autolayout-example-with-masonry2/blog_autolayout_example_with_masonry2_2.png" alt="坐标系"></p><p>而在Masonry里面，offset只是做了“加法”运算，举个例，上面的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">make</span><span class="selector-class">.top</span><span class="selector-class">.equalTo</span>(<span class="selector-tag">superview</span><span class="selector-class">.mas_top</span>)<span class="selector-class">.with</span><span class="selector-class">.offset</span>(<span class="selector-tag">padding</span><span class="selector-class">.top</span>);</span><br></pre></td></tr></table></figure><p>其实等于下面的式子：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view1.<span class="built_in">top</span> = superview.<span class="built_in">top</span> + padding.<span class="built_in">top</span>;</span><br></pre></td></tr></table></figure><p>转换到坐标系里面，即是：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view1顶部的y坐标 = superview顶部的y坐标 + padding.<span class="built_in">top</span>;</span><br></pre></td></tr></table></figure><p>所以，如果我们想view1的bottom距底部间距为10，按照offset的“加法运算”，应该是下面这样：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">view1底部的y坐标 </span>=<span class="string"> superview底部的y坐标 + (-10);</span></span><br></pre></td></tr></table></figure><p>所以，代码里面的bottom的offset是负数。right也是一个道理。</p><p>总的来说，就是布局的时候，始终要在坐标系下考虑。</p><h3 id="约束的“等价”性"><a href="#约束的“等价”性" class="headerlink" title="约束的“等价”性"></a>约束的“等价”性</h3><p>语文不好，还是用公式说明吧=。=<br>先看看Autolayout的基本公式：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewA-<span class="keyword">attribute</span> = viewB-<span class="keyword">attribute</span> * multiplier + <span class="keyword">constant</span></span><br></pre></td></tr></table></figure><p>这个公式，跟下面的是等价的：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewB-<span class="keyword">attribute</span> = (viewA-<span class="keyword">attribute</span> - <span class="keyword">constant</span>) / multiplier</span><br></pre></td></tr></table></figure><p>这个转换是如此的简单，小学生都会=。=，只是为了说明，我们在设置约束的时候，既可以从ViewA的角度考虑，也可以从ViewB的角度，两者完全<strong>等价</strong>！。</p><p>说白了就是：“ViewA跟ViewB相距10”和“ViewB跟ViewA相距10”是一样的，如下两段代码，效果是一样的（注意正负数）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// View2的顶部距离View1的底部10</span></span><br><span class="line">[view2 mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) &#123;</span><br><span class="line">    <span class="built_in">make</span>.top.equalTo(view1.mas_bottom).with.offset(<span class="number">10</span>);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// View1的底部距离View2的顶部10</span></span><br><span class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) &#123;</span><br><span class="line">    <span class="built_in">make</span>.bottom.equalTo(view2.mas_top).with.offset(<span class="number">-10</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>更进一步说，就是约束只是两个View之间的关系，对于系统来说，ViewA和ViewB的地位是<strong>平等</strong>的，我们设置约束的时候，没有<strong>主次</strong>之分。</p><p>所以，我们在设置约束的时候，要从“<strong>整体</strong>”、“<strong>宏观</strong>”上考虑，更好地把握布局，避免重复约束。</p><h2 id="Case-1-变高UITableViewCell"><a href="#Case-1-变高UITableViewCell" class="headerlink" title="Case 1: 变高UITableViewCell"></a>Case 1: 变高UITableViewCell</h2><p>变高的UITableViewCell，这是个永恒的话题=。=</p><p>不用Autolayout的话，计算Cell的高度的时候，就只能用sizeThatFits等方法，加上各种“魔鬼”数据的margin、padding来手动拼凑出Cell的高度。这种方法非常耗时，并且难以调试。</p><p>有了Autolayout，就再也不用手动算高度了~</p><h3 id="UITableViewCell"><a href="#UITableViewCell" class="headerlink" title="UITableViewCell"></a>UITableViewCell</h3><p>先看看Cell的约束。</p><h4 id="“自我约束”的Cell"><a href="#“自我约束”的Cell" class="headerlink" title="“自我约束”的Cell"></a>“自我约束”的Cell</h4><p>既然要能让系统自己计算出Cell的高度，我们在设置约束的时候，就要让约束整体是“完整”、“自我约束”的。（这个很难用语言描述。。。）Cell里面的每一个View的大小、位置，都可以从约束中得到体现，而Cell的整体大小，也是从子View的约束综合计算得出的。</p><p>如下面的Cell：</p><p><img src="/2015/08/08/autolayout-example-with-masonry2/blog_autolayout_example_with_masonry2_3.png" alt="Cell"></p><ol><li>左上角的图片固定大小。</li><li>标题的Label只显示一行，固定高度。</li><li>内容的Label根据内容决定高度。</li><li>两个Label宽度整体随着Cell的宽度变化。</li></ol><p>约束的设定如下：</p><p><img src="/2015/08/08/autolayout-example-with-masonry2/blog_autolayout_example_with_masonry2_4.png" alt="约束示意"></p><p>关键点:</p><ol><li>内容Label的bottom和Cell的contentView的约束不可以省，因为cell的高度要由内部的约束决定，所以上下左右的约束一个不能少。</li><li>内容Label的高度随着内容变化，即cell的高度随内容变化，这个时候可以设置Label的ContentHugging的优先级最高。</li></ol><h4 id="UILabel的preferredMaxLayoutWidth"><a href="#UILabel的preferredMaxLayoutWidth" class="headerlink" title="UILabel的preferredMaxLayoutWidth"></a>UILabel的preferredMaxLayoutWidth</h4><p>Autolayout下，UILabel在多行显示时，有个很“坑”的属性需要设定，就是preferredMaxLayoutWidth。</p><p>定义如下:</p><blockquote><p>This property affects the size of the label when layout constraints are applied to it. During layout, if the text extends beyond the width specified by this property, the additional text is flowed to one or more new lines, thereby increasing the height of the label.</p></blockquote><p>如果我们要使用Autolayout自动计算多行UILabel的高度，这个属性就必须在运行时指定，要不然系统计算不出UILabel的宽度，例如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算UILabel的preferredMaxLayoutWidth值，多行时必须设置这个值，否则系统无法决定Label的宽度</span></span><br><span class="line"><span class="selector-tag">label</span><span class="selector-class">.preferredMaxWidth</span> = [UIScreen mainScreen]<span class="selector-class">.bounds</span><span class="selector-class">.size</span><span class="selector-class">.width</span> - <span class="attribute">margin</span> - padding;</span><br></pre></td></tr></table></figure><p>手动计算宽度，感觉回到了没有Autolayout的时代=。=</p><h4 id="Cell的关键代码"><a href="#Cell的关键代码" class="headerlink" title="Cell的关键代码"></a>Cell的关键代码</h4><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Avatar - 头像</span></span><br><span class="line"><span class="variable">_avatarImageView</span> = [UIImageView new];</span><br><span class="line">[self.contentView addSubview:<span class="variable">_avatarImageView</span>];</span><br><span class="line">[<span class="variable">_avatarImageView</span> mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.width.<span class="built_in">and</span>.height.equalTo(@<span class="number">44</span>); <span class="comment">// 宽高固定</span></span><br><span class="line">    make.left.<span class="built_in">and</span>.top.equalTo(self.contentView).<span class="keyword">with</span>.offset(<span class="number">4</span>);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Title - 单行</span></span><br><span class="line"><span class="variable">_titleLabel</span> = [UILabel new];</span><br><span class="line">[self.contentView addSubview:<span class="variable">_titleLabel</span>];</span><br><span class="line">[<span class="variable">_titleLabel</span> mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.height.equalTo(@<span class="number">22</span>); <span class="comment">// 宽高固定</span></span><br><span class="line">    make.top.equalTo(self.contentView).<span class="keyword">with</span>.offset(<span class="number">4</span>);</span><br><span class="line">    make.left.equalTo(<span class="variable">_avatarImageView</span>.mas_right).<span class="keyword">with</span>.offset(<span class="number">4</span>);</span><br><span class="line">    make.right.equalTo(self.contentView).<span class="keyword">with</span>.offset(-<span class="number">4</span>);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算UILabel的preferredMaxLayoutWidth值，多行时必须设置这个值，否则系统无法决定Label的宽度</span></span><br><span class="line">CGFloat preferredMaxWidth = [UIScreen mainScreen].bounds.<span class="built_in">size</span>.width - (<span class="number">16</span> + <span class="number">4</span>) * <span class="number">2</span> - <span class="number">44</span> - <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Content - 多行</span></span><br><span class="line"><span class="variable">_contentLabel</span> = [UILabel new];</span><br><span class="line"><span class="variable">_contentLabel</span>.numberOfLines = <span class="number">0</span>;</span><br><span class="line"><span class="variable">_contentLabel</span>.preferredMaxLayoutWidth = preferredMaxWidth; <span class="comment">// 多行时必须设置</span></span><br><span class="line">[self.contentView addSubview:<span class="variable">_contentLabel</span>];</span><br><span class="line"></span><br><span class="line">[<span class="variable">_contentLabel</span> mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.equalTo(<span class="variable">_titleLabel</span>.mas_bottom).<span class="keyword">with</span>.offset(<span class="number">4</span>);</span><br><span class="line">    make.left.equalTo(<span class="variable">_avatarImageView</span>.mas_right).<span class="keyword">with</span>.offset(<span class="number">4</span>);</span><br><span class="line">    make.right.equalTo(self.contentView).<span class="keyword">with</span>.offset(-<span class="number">4</span>);</span><br><span class="line">    make.bottom.equalTo(self.contentView).<span class="keyword">with</span>.offset(-<span class="number">4</span>);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 设置高度的Content Hugging</span></span><br><span class="line">[<span class="variable">_contentLabel</span> setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisVertical];</span><br></pre></td></tr></table></figure><h3 id="UITableView"><a href="#UITableView" class="headerlink" title="UITableView"></a>UITableView</h3><p>再看看UITableView。</p><h4 id="用systemLayoutSizeFittingSize-获取Cell的高度"><a href="#用systemLayoutSizeFittingSize-获取Cell的高度" class="headerlink" title="用systemLayoutSizeFittingSize:获取Cell的高度"></a>用systemLayoutSizeFittingSize:获取Cell的高度</h4><p>在设定好Cell的约束以后，就可以用systemLayoutSizeFittingSize:方法获取Cell的实际高度，它的参数可以设定为两个系统常量，如下：</p><ol><li>UILayoutFittingCompressedSize: 返回合适的最小大小。</li><li>UILayoutFittingExpandedSize: 返回合适的最大大小。</li></ol><h4 id="模板Cell"><a href="#模板Cell" class="headerlink" title="模板Cell"></a>模板Cell</h4><p>为了在<code>- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath</code>方法中计算Cell的高度，我们需要一个专门用于计算高度的Cell实例，可以说算是Cell的“模板”。一般来说，这个实例可以设置成函数的static变量，并只在第一次使用时初始化一次。</p><h4 id="简单缓存高度"><a href="#简单缓存高度" class="headerlink" title="简单缓存高度"></a>简单缓存高度</h4><p>为了避免每次滑动时计算高度，可以将Cell的高度缓存下来。如，保存在每一行对应的数据Model(Entity)中，例如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">Entity </span>: NSObject</span><br><span class="line"><span class="comment">// Data</span></span><br><span class="line"><span class="variable">@property</span> (copy, nonatomic) NSString *title;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Cache height</span></span><br><span class="line"><span class="variable">@property</span> (assign, nonatomic) CGFloat cellHeight;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>每次要获取高度时，就可以先检查一下是否有缓存，减少计算量。</p><h4 id="设置estimatedRowHeight以减少首次显示的计算量"><a href="#设置estimatedRowHeight以减少首次显示的计算量" class="headerlink" title="设置estimatedRowHeight以减少首次显示的计算量"></a>设置estimatedRowHeight以减少首次显示的计算量</h4><p>默认情况下，首次显示之前，系统都会一次性全部计算出所有Cell的高度，这简直不能忍啊！要是有10000行，那岂不是要卡死=。=</p><p>所以iOS 7以后，UITableView有了一个新的属性：estimatedRowHeight。</p><p>从属性名上就可以看出，这个属性可以为Cell预先指定一个“估计”的高度值，这样的话，系统就可以先按照估计值布局，然后只获取显示范围内的Cell的高度，这样就不会一次性计算全部的了。</p><h4 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="keyword">static</span> Case4Cell *templateCell;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        templateCell = [tableView dequeueReusableCellWithIdentifier:<span class="built_in">NSStringFromClass</span>([Case4Cell <span class="keyword">class</span>])];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应的数据</span></span><br><span class="line">    Case4DataEntity *dataEntity = _data[(<span class="built_in">NSUInteger</span>) indexPath.row];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充数据</span></span><br><span class="line">    [templateCell setupData:dataEntity];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断高度是否已经计算过</span></span><br><span class="line">    <span class="keyword">if</span> (dataEntity.cellHeight &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据当前数据，计算Cell的高度，注意+1</span></span><br><span class="line">        dataEntity.cellHeight = [templateCell.contentView systemLayoutSizeFittingSize:<span class="built_in">UILayoutFittingCompressedSize</span>].height + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataEntity.cellHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iOS-8的新特性"><a href="#iOS-8的新特性" class="headerlink" title="iOS 8的新特性"></a>iOS 8的新特性</h3><p>iOS 8大大简化了Cell的高度计算，只要设置好Cell的约束，添加下面几行代码：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tableView.rowHeight</span> = UITableViewAutomaticDimension<span class="comment">;</span></span><br><span class="line"><span class="attr">tableView.estimatedRowHeight</span> = <span class="number">80</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>然后：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="comment">// 只用返回这个！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UITableViewAutomaticDimension</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对！就只用这么几行代码就行！</p><h2 id="Case-2-topLayoutGuide和bottomLayoutGuide"><a href="#Case-2-topLayoutGuide和bottomLayoutGuide" class="headerlink" title="Case 2: topLayoutGuide和bottomLayoutGuide"></a>Case 2: topLayoutGuide和bottomLayoutGuide</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>topLayoutGuide和bottomLayoutGuide都是iOS 7以后，UIViewController的属性。</p><p>在文档、头文件中，topLayoutGuide和bottomLayoutGuide的定义如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">retain</span>) <span class="keyword">id</span>&lt;<span class="built_in">UILayoutSupport</span>&gt; topLayoutGuide <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0);</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">retain</span>) <span class="keyword">id</span>&lt;<span class="built_in">UILayoutSupport</span>&gt; bottomLayoutGuide <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0);</span><br></pre></td></tr></table></figure><p>而UILayoutSupport的定义更是简单：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@protocol</span> UILayoutSupport &lt;NSObject&gt;</span><br><span class="line"><span class="variable">@property</span>(nonatomic,readonly) CGFloat length;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p><strong>以topLayoutGuide为例</strong>：</p><blockquote><p>The topLayoutGuide property comes into play when a view controller is frontmost onscreen. It indicates the highest vertical extent for content that you don’t want to appear behind a translucent or transparent UIKit bar (such as a status or navigation bar). This property implements the UILayoutSupport protocol and you can employ it as a constraint item when using the NSLayoutConstraint class.</p></blockquote><p>简单来说，topLayoutGuide表示当前页面的上方被status bar、navigation bar遮挡的部分。同理，bottomLayoutGuide表示下方被遮挡的部分。</p><p>如下图:  </p><p><img src="/2015/08/08/autolayout-example-with-masonry2/blog_autolayout_example_with_masonry2_5.jpg" alt="topLayoutGuide和bottomLayoutGuide"></p><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>有些时候，一个ViewController可能单独显示出来，也可能内嵌在UINavigationController里面显示出来。在这两种情况下，页面的“<strong>可视范围</strong>”是不一样的，很明显，NavigationBar会遮挡住一部分，用了UITabBarController时，tabBar也会遮挡住下方一部分。再加上各种Bar都可以隐藏，情况会变得更复杂。</p><p>难道要为每种情况去写一份布局代码？</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>为了解决上面的问题，就需要在设置约束时，加进topLayoutGuide和bottomLayoutGuide。</p><h4 id="用法1-强制转换为UIView"><a href="#用法1-强制转换为UIView" class="headerlink" title="用法1: 强制转换为UIView"></a>用法1: 强制转换为UIView</h4><p>定义上，topLayoutGuide和bottomLayoutGuide都是id，但是实际中是什么呢？跟UIView有什么关系？<br>看看如下代码的运行结果：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, [<span class="keyword">self</span>.topLayoutGuide isKindOfClass:[<span class="built_in">UIView</span> <span class="keyword">class</span>]]);</span><br></pre></td></tr></table></figure><p>结果是：”1”</p><p><strong>也就是说，在运行期间，topLayoutGuide和bottomLayoutGuide就是UIView的子类</strong>。</p><p>所以，第一种方法就是强制转换成UIView，直接运用在Masonry的约束里面，正如较旧的Masonry官方示例中的一样：</p><figure class="highlight hy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[topView makeConstraints:^(<span class="name">MASConstraintMaker</span> *make) &#123;</span><br><span class="line">    // 强制转换</span><br><span class="line">    UIView *topLayoutGuide = (<span class="name"><span class="builtin-name">id</span></span>)self.topLayoutGuide;</span><br><span class="line">    make.top.equalTo(<span class="name">topLayoutGuide.mas_bottom</span>)<span class="comment">;</span></span><br><span class="line">    // ...</span><br><span class="line">&#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>但是这样存在着风险，万一哪天苹果改变了topLayoutGuide和bottomLayoutGuide的实现方法，这么用就Crash了=。=</p><h4 id="用法2-直接使用length属性"><a href="#用法2-直接使用length属性" class="headerlink" title="用法2: 直接使用length属性"></a>用法2: 直接使用length属性</h4><p>第二种方法，就是直接使用UILayoutSupport定义的length属性。<br>这个时候就有个地方要特别注意，在运行到viewDidLoad的时候，length的值是0，因为这个时候界面还没有被绘制，所以一个解决方法就是在ViewController的<strong>updateViewConstraints</strong>方法里面去使用length值添加约束。如下：</p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)updateViewConstraints &#123;</span><br><span class="line">    [<span class="attribute">_topView mas_updateConstraints</span>:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        // 直接利用其length属性</span><br><span class="line">        make<span class="variable">.top</span><span class="variable">.equalTo</span>(self<span class="variable">.view</span><span class="variable">.mas_top</span>)<span class="variable">.with</span><span class="variable">.offset</span>(self<span class="variable">.topLayoutGuide</span><span class="variable">.length</span>);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    [super updateViewConstraints];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用法3-使用新版的mas-topLayoutGuide和mas-bottomLayoutGuide"><a href="#用法3-使用新版的mas-topLayoutGuide和mas-bottomLayoutGuide" class="headerlink" title="用法3: 使用新版的mas_topLayoutGuide和mas_bottomLayoutGuide"></a>用法3: 使用新版的mas_topLayoutGuide和mas_bottomLayoutGuide</h4><p>在<a href="https://github.com/SnapKit/Masonry/commit/c99e65c2eb40a02106d87a1487f96c0f4b1b72c0" target="_blank" rel="noopener">Masonry的新版</a>中，为UIViewController增加了一个新的Category: <code>MASAdditions</code>，增加了<code>mas_topLayoutGuide</code>和<code>mas_bottomLayoutGuide</code>两个方法，这样的话，我们就可以优雅的使用topLayoutGuide和bottomLayoutGuide了~</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[_topView mas_makeConstraints:^(<span class="name">MASConstraintMaker</span> *make) &#123;</span><br><span class="line">    // 不用强制转换，也不用在updateViewConstraints里面更新了</span><br><span class="line">    make.top.equalTo(<span class="name">self.mas_topLayoutGuide</span>)<span class="comment">;</span></span><br><span class="line">    // ...</span><br><span class="line">&#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>直接看Demo吧，比较简单。</p><h2 id="Case-3-自定义baseline"><a href="#Case-3-自定义baseline" class="headerlink" title="Case 3: 自定义baseline"></a>Case 3: 自定义baseline</h2><p>最后一个Case，讲讲baseline。  </p><p>baseline，翻译过来就是“基线”，在Autolayout里面对应着<strong><code>NSLayoutFormatAlignAllBaseline</code></strong>，也是一种对齐的标准。例如，UIButton的baseline就是内部的文字，如果一排button按照baseline对齐的话，就是下面这样：</p><p><img src="/2015/08/08/autolayout-example-with-masonry2/blog_autolayout_example_with_masonry2_6.jpg" alt="按钮按照baseline对其"></p><p>对于自定义的View来说，baseline默认就是整个view的底部，如果想改变baseline的话，可以重写UIView的<strong>viewForBaselineLayout</strong>，返回当成baseline的view即可。</p><p>如下面的自定义view：</p><p><img src="/2015/08/08/autolayout-example-with-masonry2/blog_autolayout_example_with_masonry2_7.jpg" alt="自定义baseline"></p><p>很明显，baseline就是显示图片的UIImageView，代码也很简单:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义的View中</span></span><br><span class="line"><span class="comment">// 返回自定义的baseline的view</span></span><br><span class="line">- (UIView *)viewForBaselineLayout &#123;</span><br><span class="line">    <span class="keyword">return</span> _imageView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>灵活的使用baseline，可以更加方便的进行布局。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写了好长，能全部看完的朋友，嗯，你是个优秀的程序员=。=</p><p>后面打算用Swift的SnapKit把所有的Case全部实现一次。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://chun.tips/blog/2014/10/23/xi-shu-autolayoutyi-lai-uiviewhe-uiviewcontrollerxin-zeng-de-xiang-guan-api-uiviewpian/" target="_blank" rel="noopener">细数AutoLayout以来UIView和UIViewController新增的相关API – UIView篇</a></li><li><a href="https://developer.apple.com/library/ios/qa/qa1797/_index.html" target="_blank" rel="noopener">Preventing the Status Bar from Covering Your Views</a></li><li><a href="http://www.objc.io/issues/3-views/advanced-auto-layout-toolbox/#intrinsic-content-size" target="_blank" rel="noopener">Advanced Auto Layout Toolbox</a></li><li><a href="http://chun.tips/blog/2014/10/25/xi-shu-autolayoutyi-lai-uiviewhe-uiviewcontrollerxin-zeng-de-xiang-guan-api-uiviewcontrollerpian/" target="_blank" rel="noopener">细数AutoLayout以来UIView和UIViewController新增的相关API – UIViewController篇</a></li><li><a href="http://www.wugaojun.com/blog/2015/05/24/autolayoutshi-zhan-cellgao-du-bu-gu-ding-de-uitableview/" target="_blank" rel="noopener">AutoLayout实战:cell高度不固定的UITableView</a></li><li><a href="http://www.jianshu.com/p/d5d897ffe118" target="_blank" rel="noopener">AutoLayout下多行UILabel无法显示多行文本的问题</a></li><li><a href="https://grayluo.github.io/WeiFocusIo/autolayout/2015/02/01/autolayout5/" target="_blank" rel="noopener">AutoLayout深入浅出五-UITableView动态高度</a></li><li><a href="http://www.brynbodayle.com/faster-uitableviews-with-ios-7/" target="_blank" rel="noopener">Faster UITableViews with iOS 7</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Masonry写的Autolayout示例又来了，仍然是三个小例子，分别是&lt;strong&gt;变高度的UITableViewCell、topLayoutGuide与bottomLayoutGuide，还有自定义的baseline&lt;/strong&gt;，外加两个基本的知识点讲解，说不上“有趣”=。=，比较基础，写了很多，各位随意看看吧~&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一篇: &lt;a href=&quot;http://tutuge.me/2015/05/23/autolayout-example-with-masonry/&quot;&gt;有趣的Autolayout示例-Masonry实现&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;第三篇: &lt;a href=&quot;http://tutuge.me/2015/12/14/autolayout-example-with-masonry3/&quot;&gt;有趣的Autolayout示例3-Masonry实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;第四篇: &lt;a href=&quot;http://tutuge.me/2016/08/06/autolayout-example-with-masonry4/&quot;&gt;有趣的Autolayout示例4-Masonry实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Github地址：&lt;br&gt;&lt;a href=&quot;https://github.com/zekunyan/AutolayoutExampleWithMasonry&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/zekunyan/AutolayoutExampleWithMasonry&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2015/08/08/autolayout-example-with-masonry2/blog_autolayout_example_with_masonry2_1.gif&quot; alt=&quot;Gif示例&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="Autolayout" scheme="http://tutuge.me/tags/Autolayout/"/>
    
      <category term="Masonry" scheme="http://tutuge.me/tags/Masonry/"/>
    
  </entry>
  
  <entry>
    <title>解决iOS项目的版本兼容问题-结合宏、Category和Runtime</title>
    <link href="http://tutuge.me/2015/07/25/compatibility-with-macro-category-and-runtime/"/>
    <id>http://tutuge.me/2015/07/25/compatibility-with-macro-category-and-runtime/</id>
    <published>2015-07-24T16:39:03.000Z</published>
    <updated>2018-10-07T17:37:29.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h3 id="2015-11-16"><a href="#2015-11-16" class="headerlink" title="2015-11-16"></a>2015-11-16</h3><p>感谢微博好友<strong>@zyyy_000</strong>的评论，补充了为什么要在<code>+ (void)load</code>方法里面做<strong>Method Swizzling</strong>。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近，在做项目时，因为某种原因，突然要“适配”iOS6（也是醉了。。。），保证极少数的iOS6用户可以“用上”新的版本。哪怕界面上有瑕疵，只要功能正常就行。于是就只好花几天时间对iOS6进行紧急适配（心中一万头驼羊奔跑而过。。。）</p><p>本文总结了一些常规的，和“非常规”的iOS项目向老版本兼容的办法，结合了<strong>宏定义</strong>、<strong>Category</strong>和<strong>Runtime</strong>，大家看着消遣一下就好哈~</p><a id="more"></a><h2 id="重点概念"><a href="#重点概念" class="headerlink" title="重点概念"></a>重点概念</h2><p>首先强调一些概念。</p><h3 id="Deployment-Target-和-Base-SDK"><a href="#Deployment-Target-和-Base-SDK" class="headerlink" title="Deployment Target 和 Base SDK"></a>Deployment Target 和 Base SDK</h3><p><strong>Deployment Target</strong></p><p>指的是你的APP能支持的最低系统版本，如要支持iOS6以上，就设置成iOS6即可。</p><p><strong>Base SDK</strong></p><p>指的是用来编译APP的SDK（Software Development Kit）的版本，一般保持当前XCode支持的最新的就好，如iOS8.4。SDK其实就是包含了所有的你要用到的头文件、链接库的集合，你的APP里面用的各种类、函数，能编译、链接成最后的安装包，就要靠它，苹果每次升级系统，新推出的各种API，也是在SDK里面。所以一般Base SDK肯定是大于等于Deployment Target的版本。</p><p><strong>区分</strong></p><p>既然Base SDK的版本大于等于Deployment Target的版本，那么就要小心了，因为<strong>“只要用到的类、方法，在当前的Base SDK版本里面存在，就可以<em>编译通过</em>！但是一旦运行APP的手机的系统版本低于这些类、方法的最低版本要求，APP就会Crash！”</strong></p><p>所以并不是说，能编译通过的，就一定能<em>运行成功</em>！还要在<em>运行时检查</em>！简单来说，就是如下图：</p><p><img src="/2015/07/25/compatibility-with-macro-category-and-runtime/blog_compatibility-with-macro-category-and-runtime_1.png" alt="兼容示意图"></p><h3 id="宏只在编译时生效！"><a href="#宏只在编译时生效！" class="headerlink" title="宏只在编译时生效！"></a>宏只在编译时生效！</h3><p>宏定义只是纯粹的文本替换，只在编译时起作用。如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __IPHONE_OS_VERSION_MIN_REQUIRED &gt;= 70000</span></span><br><span class="line">    NSLog(@<span class="string">"Tutuge"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>被宏定义包起来的代码是否会执行，在编译时就决定好了，无论你是用什么系统运行，宏定义再也没有什么卵用=。=</p><h2 id="编译时检查SDK版本，运行时检查系统版本"><a href="#编译时检查SDK版本，运行时检查系统版本" class="headerlink" title="编译时检查SDK版本，运行时检查系统版本"></a>编译时检查SDK版本，运行时检查系统版本</h2><p>这个是最基本的适配手段。</p><p>用到的宏如下：</p><ol><li><strong>__IPHONE_OS_VERSION_MAX_ALLOWED</strong>: 值等于Base SDK，即用于检查SDK版本的。</li><li><strong>__IPHONE_OS_VERSION_MIN_REQUIRED</strong>: 值等于Deployment Target，检查支持的最小系统版本。</li></ol><p>运行时检查系统版本：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([UIDevice currentDevice]<span class="selector-class">.systemVersion</span><span class="selector-class">.floatValue</span> &gt; <span class="number">8.0</span>f) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如我们现在想用iOS8新的<strong>UIAlertController</strong>来显示提示框，应该如下判断：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译时判断：检查SDK版本</span></span><br><span class="line"><span class="meta">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt; 80000</span></span><br><span class="line">    <span class="comment">// 运行时判断：检查当前系统版本</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">UIDevice</span> currentDevice].systemVersion.floatValue &gt; <span class="number">8.0</span>f) &#123;</span><br><span class="line">        <span class="built_in">UIAlertController</span> *alertController =</span><br><span class="line">        [<span class="built_in">UIAlertController</span> alertControllerWithTitle:<span class="string">@"Tutuge"</span></span><br><span class="line">                                            message:<span class="string">@"Compatibility"</span></span><br><span class="line">                                     preferredStyle:<span class="built_in">UIAlertControllerStyleAlert</span>];</span><br><span class="line">        [alertController addAction:[<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@"Cancel"</span></span><br><span class="line">                                                            style:<span class="built_in">UIAlertActionStyleCancel</span></span><br><span class="line">                                                          handler:^(<span class="built_in">UIAlertAction</span> *action) &#123;</span><br><span class="line">                                                              <span class="built_in">NSLog</span>(<span class="string">@"Cancel"</span>);</span><br><span class="line">                                                          &#125;]];</span><br><span class="line">        [<span class="keyword">self</span> presentViewController:alertController animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 用旧的代替</span></span><br><span class="line">        <span class="built_in">UIAlertView</span> *alertView = [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"Tutuge"</span></span><br><span class="line">                                                            message:<span class="string">@"Compatibility"</span></span><br><span class="line">                                                           delegate:<span class="literal">nil</span></span><br><span class="line">                                                  cancelButtonTitle:<span class="string">@"Cancel"</span></span><br><span class="line">                                                  otherButtonTitles:<span class="literal">nil</span>];</span><br><span class="line">        [alertView show];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p>总的来说就是编译时、运行时的判断均不能少。</p><h2 id="Weakly-Linked-运行时检查类、方法是否可用"><a href="#Weakly-Linked-运行时检查类、方法是否可用" class="headerlink" title="Weakly Linked - 运行时检查类、方法是否可用"></a>Weakly Linked - 运行时检查类、方法是否可用</h2><p>除了用宏、系统版本检测，还可以用<strong>Weakly Linked</strong>特性做运行时的检查。</p><p>对于iOS4.2以上的，有<strong>NS_CLASS_AVAILABLE</strong>标示的类，可以如下判断是否可用：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __IPHONE_OS_VERSION_MAX_ALLOWED &gt; 80000</span></span><br><span class="line">    <span class="comment">// Weakly Linked判断</span></span><br><span class="line">    <span class="built_in">if</span> ([UIAlertController class]) &#123;</span><br><span class="line">        <span class="comment">// 使用UIAlertController...</span></span><br><span class="line">    &#125; <span class="built_in">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用旧的方案...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>也可以如下判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class <span class="class"><span class="keyword">class</span> </span>= NSClassFromString (@<span class="string">"UIAlertController"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="class"><span class="keyword">class</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用UIAlertController...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 使用旧的方案...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于方法，如下判断:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">if</span> ([UITableViewCell <span class="attribute">instancesRespondToSelector</span>:<span class="variable">@selector</span> (<span class="attribute">setSeparatorInset</span>:)]) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="selector-tag">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于用哪种方法，统一一下即可。</p><h2 id="用Method-Swizzling做兼容"><a href="#用Method-Swizzling做兼容" class="headerlink" title="用Method Swizzling做兼容"></a>用Method Swizzling做兼容</h2><p>有关Runtime、Method Swizzling的资料很多，各位自行阅读哈~</p><h3 id="在-void-load方法里面做替换"><a href="#在-void-load方法里面做替换" class="headerlink" title="在+ (void)load方法里面做替换"></a>在<code>+ (void)load</code>方法里面做替换</h3><p>这里提一下为什么要在<code>+ (void)load</code>方法里面做Method Swizzling。</p><p>在Objective-C中，运行时会自动调用每个类的两个方法。<code>+ (void)load</code>会在类、Category初始加载时调用，<code>+ (void)initialize</code>会在第一次调用类的类方法或实例方法之前被调用。</p><p>但是需要注意的是，<code>+ (void)initialize</code>是可以被Category覆盖重写的，并且有多个Category都重写了<code>+ (void)initialize</code>方法时，只会运行其中一个，所以在<code>+ (void)initialize</code>里面做Method Swizzling显然是不行的。</p><p>而<code>+ (void)load</code>方法只要实现了，就一定会调用。具体为什么大家可以自行阅读Runtime的源码，或者查阅相关文章。</p><h3 id="用dispatch-once保证只运行一次"><a href="#用dispatch-once保证只运行一次" class="headerlink" title="用dispatch_once保证只运行一次"></a>用dispatch_once保证只运行一次</h3><p>因为Method Swizzling的影响是全局的，而且一旦多次调用，会出错，所以这个时候用dispatch_once就再合适不过了~</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面就是利用Method Swizzling做兼容的一个例子。<br>有时候，不同版本之间，同一个类、View控件的默认属性可能都会变化，如UILabel的背景色在iOS6上，默认是白色，而iOS6以后是透明的！如果在每个用到UILabel的地方，都手动设置一次背景色，代价太大。这个时候就需要Runtime的“黑魔法”上场。</p><p>就以设置UILabel的默认背景色透明为例，就是在UILabel初始化时，如initWithFrame之前，先设置好透明背景色，简单的示例如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Category</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UILabel</span> (<span class="title">TTGCompatibility</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// 先判断系统版本，尽量减少Runtime的作用范围</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">UIDevice</span> currentDevice].systemVersion.floatValue &lt; <span class="number">7.0</span>f) &#123;</span><br><span class="line">            <span class="comment">// Method Swizzling</span></span><br><span class="line">            <span class="comment">// initWithFrame</span></span><br><span class="line">            Method oriMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(initWithFrame:));</span><br><span class="line">            Method newMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(compatible_initWithFrame:));</span><br><span class="line">            method_exchangeImplementations(oriMethod, newMethod);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// initWithCoder...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initWithFrame</span></span><br><span class="line">- (<span class="keyword">id</span>)compatible_initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</span><br><span class="line">    <span class="keyword">id</span> newSelf = [<span class="keyword">self</span> compatible_initWithFrame:frame];</span><br><span class="line">    <span class="comment">// 设置透明背景色</span></span><br><span class="line">    ((<span class="built_in">UILabel</span> *)newSelf).backgroundColor = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">    <span class="keyword">return</span> newSelf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initWithCoder...</span></span><br></pre></td></tr></table></figure><h2 id="运行时添加“Dummy”方法，减少代码改动"><a href="#运行时添加“Dummy”方法，减少代码改动" class="headerlink" title="运行时添加“Dummy”方法，减少代码改动"></a>运行时添加“Dummy”方法，减少代码改动</h2><p>Dummy，意思是“假的、假动作、假人”，在这里指的是为旧版本不存在的方法提供一个“假的”替代方法，防止因新API找不到而导致的Crash。</p><p>以UITableViewCell的<strong>“setSeparatorInset:”</strong>方法为例，在iOS6中，压根就不存在separatorInset，但是现有的代码里面大量的调用了这个方法，怎么办？难道一个一个的去加上判断条件？代价太大。</p><p>这个时候就可以用Runtime的手段，在运行时添加一个Dummy方法，去“<strong>代替接收</strong>”setSeparatorInset消息，防止在iOS6上的Crash。</p><p>代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UITableViewCell</span> (<span class="title">TTGCompatibility</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line"><span class="comment">// 编译时判断SDK</span></span><br><span class="line"><span class="meta">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt; __IPHONE_7_0</span></span><br><span class="line">    <span class="comment">// 运行时判断系统版本</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">UIDevice</span> currentDevice].systemVersion.floatValue &lt; <span class="number">7.0</span>f) &#123;</span><br><span class="line">        Method newMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(compatible_setSeparatorInset:));</span><br><span class="line">        <span class="comment">// 增加Dummy方法</span></span><br><span class="line">        class_addMethod(</span><br><span class="line">                <span class="keyword">self</span>,</span><br><span class="line">                <span class="keyword">@selector</span>(setSeparatorInset:),</span><br><span class="line">                method_getImplementation(newMethod),</span><br><span class="line">                method_getTypeEncoding(newMethod));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setSeparatorInset: 的Dummy方法</span></span><br><span class="line">- (<span class="keyword">void</span>)compatible_setSeparatorInset:(<span class="built_in">UIEdgeInsets</span>) inset &#123;</span><br><span class="line">    <span class="comment">// 空方法都可以，只是为了接收setSeparatorInset:消息。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在适配旧版本时，除了基本的宏定义、[UIDevice currentDevice].systemVersion判断，适当的用Runtime，可以大大减少对现有代码的“干涉”，多种方法相结合才是最好的。</p><p>嗯，还在用iOS6的用户，升个级呗=。=</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/cross_development/Introduction/Introduction.html#//apple_ref/doc/uid/10000163-BCICHGIE" target="_blank" rel="noopener">SDK Compatibility Guide</a></li><li><a href="http://git.devzeng.com/blog/ios-multiple-version-compatible.html" target="_blank" rel="noopener">iOS开发之多系统版本兼容</a></li><li><a href="http://stackoverflow.com/questions/3057325/weak-linking-check-if-a-class-exists-and-use-that-class" target="_blank" rel="noopener">Weak Linking - check if a class exists and use that class</a></li><li><a href="http://stackoverflow.com/questions/19789958/xcode-preprocessor-macro-to-check-if-base-sdk-ios-7-0" target="_blank" rel="noopener">Xcode preprocessor macro to check if Base SDK &gt;= iOS 7.0</a></li><li><a href="http://xuzhongzhou.net/post/ios-sdk-compatibility-guide.html" target="_blank" rel="noopener">iOS SDK 兼容性指南</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;更新&quot;&gt;&lt;a href=&quot;#更新&quot; class=&quot;headerlink&quot; title=&quot;更新&quot;&gt;&lt;/a&gt;更新&lt;/h2&gt;&lt;h3 id=&quot;2015-11-16&quot;&gt;&lt;a href=&quot;#2015-11-16&quot; class=&quot;headerlink&quot; title=&quot;2015-11-16&quot;&gt;&lt;/a&gt;2015-11-16&lt;/h3&gt;&lt;p&gt;感谢微博好友&lt;strong&gt;@zyyy_000&lt;/strong&gt;的评论，补充了为什么要在&lt;code&gt;+ (void)load&lt;/code&gt;方法里面做&lt;strong&gt;Method Swizzling&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近，在做项目时，因为某种原因，突然要“适配”iOS6（也是醉了。。。），保证极少数的iOS6用户可以“用上”新的版本。哪怕界面上有瑕疵，只要功能正常就行。于是就只好花几天时间对iOS6进行紧急适配（心中一万头驼羊奔跑而过。。。）&lt;/p&gt;
&lt;p&gt;本文总结了一些常规的，和“非常规”的iOS项目向老版本兼容的办法，结合了&lt;strong&gt;宏定义&lt;/strong&gt;、&lt;strong&gt;Category&lt;/strong&gt;和&lt;strong&gt;Runtime&lt;/strong&gt;，大家看着消遣一下就好哈~&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="Runtime" scheme="http://tutuge.me/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>用Runtime的手段填充任意NSObject对象的nil属性</title>
    <link href="http://tutuge.me/2015/07/08/fill-nil-property-of-object/"/>
    <id>http://tutuge.me/2015/07/08/fill-nil-property-of-object/</id>
    <published>2015-07-08T15:23:23.000Z</published>
    <updated>2018-10-07T17:37:29.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>好久没有写东西了，忙啊。</p><p>前段时间参加了一下我们华科联创的HackDay（本人在读研=。=，目前在阿里实习），作品是一款<strong>实时在线对战游戏 - 波波攒</strong>，（介绍请看<a href="http://www.zhihu.com/question/24402279" target="_blank" rel="noopener">知乎</a>）<br>从iOS游戏客户端（用的<strong>SpriteKit</strong>）到后台（<strong>PHP CI + Node + SocketIO + MySQL</strong>）全是自己一个人倒腾出来的，做了一把真正的全栈工程师，爽啊~<br>后面会完善整个游戏，增加角色、优化啥的，过上一段时间会上线的哈~</p><p><strong>回到正文</strong>，本文主要介绍了怎么用Runtime的手段遍历任意NSObject对象的所有property，检查其值是否是nil，是的话根据其类型为其填充一个默认值。<br>Runtime毕竟是个“危险”的技术，本文的代码只是个初步的尝试。</p><a id="more"></a><h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><p>在做项目的过程中，总是会写一大堆if、else语句去检查对象的Property是否是nil，如从服务器返回的JSON中缺少属性，导致Entity的某些值为空；或者创建的对象没有对所有属性做初始化等等。写多了觉得好烦啊=。=<br>所以想到本文的方法，嗯，程序员总是懒的。</p><h2 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h2><ol><li>遍历一个对象的所有属性（默认不包括父类属性）。</li><li>判断属性是否是nil。</li><li>为nil的属性，获取它的类型。</li><li>根据类型设置初始值（如NSString可以设为空字符串；NSNumber可以设为@0）</li></ol><h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><p>OC是一门“动态”、“基于消息”的语言，而Runtime就是利用OC的动态特性，在运行时对程序做出“调整”的技术。有关Runtime的官方文档、网上的资料很多，大家自学哈~</p><p>本文主要用了如下几个Runtime的函数：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取类的所有<span class="keyword">Property</span><span class="title"></span></span><br><span class="line"><span class="number">1</span>. objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)</span><br><span class="line">// 获取一个<span class="keyword">Property</span><span class="title"></span>的变量名</span><br><span class="line"><span class="number">2</span>. const char *property_getName(objc_property_t <span class="keyword">property</span><span class="title"></span>)</span><br><span class="line">// 获取一个<span class="keyword">Property</span><span class="title"></span>的详细类型表达字符串</span><br><span class="line"><span class="number">3</span>. const char *property_getAttributes(objc_property_t <span class="keyword">property</span><span class="title"></span>)</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>不好一块一块拆开说，直接上代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析Property的Attributed字符串，参考Stackoverflow</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *getPropertyType(objc_property_t property) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *attributes = property_getAttributes(property);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, attributes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1</span> + strlen(attributes)];</span><br><span class="line">    strcpy(buffer, attributes);</span><br><span class="line">    <span class="keyword">char</span> *state = buffer, *attribute;</span><br><span class="line">    <span class="keyword">while</span> ((attribute = strsep(&amp;state, <span class="string">","</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 非对象类型</span></span><br><span class="line">        <span class="keyword">if</span> (attribute[<span class="number">0</span>] == <span class="string">'T'</span> &amp;&amp; attribute[<span class="number">1</span>] != <span class="string">'@'</span>) &#123;</span><br><span class="line">            <span class="comment">// 利用NSData复制一份字符串</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">const</span> <span class="keyword">char</span> *) [[<span class="built_in">NSData</span> dataWithBytes:(attribute + <span class="number">1</span>) length:strlen(attribute) - <span class="number">1</span>] bytes];</span><br><span class="line">        <span class="comment">// 纯id类型</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (attribute[<span class="number">0</span>] == <span class="string">'T'</span> &amp;&amp; attribute[<span class="number">1</span>] == <span class="string">'@'</span> &amp;&amp; strlen(attribute) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"id"</span>;</span><br><span class="line">        <span class="comment">// 对象类型</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (attribute[<span class="number">0</span>] == <span class="string">'T'</span> &amp;&amp; attribute[<span class="number">1</span>] == <span class="string">'@'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">const</span> <span class="keyword">char</span> *) [[<span class="built_in">NSData</span> dataWithBytes:(attribute + <span class="number">3</span>) length:strlen(attribute) - <span class="number">4</span>] bytes];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给对象的属性设置默认值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> checkEntity(<span class="built_in">NSObject</span> *object) &#123;</span><br><span class="line">    <span class="comment">// 不同类型的字符串表示，目前只是简单检查字符串、数字、数组</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">CLASS_NAME_NSSTRING</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">CLASS_NAME_NSNUMBER</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">CLASS_NAME_NSARRAY</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化类型常量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// "NSString"</span></span><br><span class="line">        <span class="built_in">CLASS_NAME_NSSTRING</span> =  <span class="built_in">NSStringFromClass</span>([<span class="built_in">NSString</span> <span class="keyword">class</span>]).UTF8String;</span><br><span class="line">        <span class="comment">// "NSNumber</span></span><br><span class="line">        <span class="built_in">CLASS_NAME_NSNUMBER</span> = <span class="built_in">NSStringFromClass</span>([<span class="built_in">NSNumber</span> <span class="keyword">class</span>]).UTF8String;</span><br><span class="line">        <span class="comment">// "NSArray"</span></span><br><span class="line">        <span class="built_in">CLASS_NAME_NSARRAY</span> = <span class="built_in">NSStringFromClass</span>([<span class="built_in">NSArray</span> <span class="keyword">class</span>]).UTF8String;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@try</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount, i;</span><br><span class="line">        <span class="comment">// 包含所有Property的数组</span></span><br><span class="line">        objc_property_t *properties = class_copyPropertyList([object <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个Property</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">            <span class="comment">// 取出对应Property</span></span><br><span class="line">            objc_property_t property = properties[i];</span><br><span class="line">            <span class="comment">// 获取Property对应的变量名</span></span><br><span class="line">            <span class="built_in">NSString</span> *propertyName = [<span class="built_in">NSString</span> stringWithUTF8String:property_getName(property)];</span><br><span class="line">            <span class="comment">// 获取Property的类型名</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *propertyTypeName = getPropertyType(property);</span><br><span class="line">            <span class="comment">// 获取Property的值</span></span><br><span class="line">            <span class="keyword">id</span> propertyValue = [object valueForKey:propertyName];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 值为空，才设置默认值</span></span><br><span class="line">            <span class="keyword">if</span> (!propertyValue) &#123;</span><br><span class="line">                <span class="comment">// NSString</span></span><br><span class="line">                <span class="keyword">if</span> (strncmp(<span class="built_in">CLASS_NAME_NSSTRING</span>, propertyTypeName, strlen(<span class="built_in">CLASS_NAME_NSSTRING</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    [object setValue:<span class="string">@""</span> forKey:propertyName];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// NSNumber</span></span><br><span class="line">                <span class="keyword">if</span> (strncmp(<span class="built_in">CLASS_NAME_NSNUMBER</span>, propertyTypeName, strlen(<span class="built_in">CLASS_NAME_NSNUMBER</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    [object setValue:@<span class="number">0</span> forKey:propertyName];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// NSArray</span></span><br><span class="line">                <span class="keyword">if</span> (strncmp(<span class="built_in">CLASS_NAME_NSARRAY</span>, propertyTypeName, strlen(<span class="built_in">CLASS_NAME_NSARRAY</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    [object setValue:@[] forKey:propertyName];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 别忘了释放数组</span></span><br><span class="line">        free(properties);</span><br><span class="line">    &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Check Entity Exception: %@"</span>, [exception description]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重点-解析property-getAttributes函数的结果"><a href="#重点-解析property-getAttributes函数的结果" class="headerlink" title="重点 - 解析property_getAttributes函数的结果"></a>重点 - 解析property_getAttributes函数的结果</h2><p>在整个处理过程中，property_getAttributes函数是关键，因为我们要首先确定Property的类型，才能根据类型赋初值，但是property_getAttributes函数返回的字符串比较“晦涩难懂”：</p><p>如下定义的Property：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSNumber</span> *number;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSArray</span> *array;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> i;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> f;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">char</span> *cStr;</span><br></pre></td></tr></table></figure><p>依次通过property_getAttributes获取的结果是：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">T</span>@<span class="string">"NSString"</span>,C,<span class="built_in">N</span>,V_name</span><br><span class="line"><span class="built_in">T</span>@<span class="string">"NSNumber"</span>,&amp;,<span class="built_in">N</span>,V_number</span><br><span class="line"><span class="built_in">T</span>@<span class="string">"NSArray"</span>,&amp;,<span class="built_in">N</span>,V_array</span><br><span class="line">Tq,<span class="built_in">N</span>,V_i</span><br><span class="line">Td,<span class="built_in">N</span>,V_f</span><br><span class="line"><span class="built_in">T</span>*,<span class="built_in">N</span>,V_cStr</span><br></pre></td></tr></table></figure><p>参考<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101" target="_blank" rel="noopener"> Declared Properties of Objective-C Runtime Programming Guide</a><br>我们大概可以知道，T表示Type，后面跟着@表示Cocoa对象类型，后面的表示Property的属性，如Copy、strong等，然后就是变量名。<br>所以getPropertyType函数的工作就是纯粹的解析字符串，获取T@后面的类型名。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>例如我们有如下对象：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">UserEntity </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (copy, nonatomic) NSString *name;</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) NSNumber *number;</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) NSArray *array;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>设置默认值：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UserEntity *userEntity = [UserEntity new];</span><br><span class="line"><span class="comment">// 检查属性，设置默认值。</span></span><br><span class="line">checkEntity(userEntity);</span><br><span class="line"><span class="comment">// 使用...</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"name: %@"</span>, userEntity.name);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"number: %@"</span>, userEntity.number);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"array: %@"</span>, userEntity.array);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">2015-07-11</span> <span class="selector-tag">18</span><span class="selector-pseudo">:17</span><span class="selector-pseudo">:25.918</span> <span class="selector-tag">Common</span><span class="selector-attr">[6939:270543]</span> <span class="selector-tag">name</span>:</span><br><span class="line"><span class="selector-tag">2015-07-11</span> <span class="selector-tag">18</span><span class="selector-pseudo">:17</span><span class="selector-pseudo">:25.918</span> <span class="selector-tag">Common</span><span class="selector-attr">[6939:270543]</span> <span class="selector-tag">number</span>: <span class="selector-tag">0</span></span><br><span class="line"><span class="selector-tag">2015-07-11</span> <span class="selector-tag">18</span><span class="selector-pseudo">:17</span><span class="selector-pseudo">:25.918</span> <span class="selector-tag">Common</span><span class="selector-attr">[6939:270543]</span> <span class="selector-tag">array</span>: (</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这样，一个对象的所有Property都有了初值。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面的例子只是个粗略的版本，只是检查了字符串、数字、数组，其实完全可以扩展出很多功能，如针对不同的类型，根据对象的类型，设置不同的默认初值等，靠读者你了~</p><p>Runtime是个好东西，但是别乱用啊=。=</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html" target="_blank" rel="noopener">Objective-C Runtime Reference</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101" target="_blank" rel="noopener">Objective-C Runtime Programming Guide - Declared Properties</a></li><li><a href="http://stackoverflow.com/questions/754824/get-an-object-properties-list-in-objective-c" target="_blank" rel="noopener">Get an object properties list in Objective-C</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;好久没有写东西了，忙啊。&lt;/p&gt;
&lt;p&gt;前段时间参加了一下我们华科联创的HackDay（本人在读研=。=，目前在阿里实习），作品是一款&lt;strong&gt;实时在线对战游戏 - 波波攒&lt;/strong&gt;，（介绍请看&lt;a href=&quot;http://www.zhihu.com/question/24402279&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;知乎&lt;/a&gt;）&lt;br&gt;从iOS游戏客户端（用的&lt;strong&gt;SpriteKit&lt;/strong&gt;）到后台（&lt;strong&gt;PHP CI + Node + SocketIO + MySQL&lt;/strong&gt;）全是自己一个人倒腾出来的，做了一把真正的全栈工程师，爽啊~&lt;br&gt;后面会完善整个游戏，增加角色、优化啥的，过上一段时间会上线的哈~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回到正文&lt;/strong&gt;，本文主要介绍了怎么用Runtime的手段遍历任意NSObject对象的所有property，检查其值是否是nil，是的话根据其类型为其填充一个默认值。&lt;br&gt;Runtime毕竟是个“危险”的技术，本文的代码只是个初步的尝试。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="Runtime" scheme="http://tutuge.me/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>有趣的Autolayout示例-Masonry实现</title>
    <link href="http://tutuge.me/2015/05/23/autolayout-example-with-masonry/"/>
    <id>http://tutuge.me/2015/05/23/autolayout-example-with-masonry/</id>
    <published>2015-05-23T11:59:22.000Z</published>
    <updated>2018-10-07T17:37:29.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><ul><li>2016-08-06: 第四篇: <a href="http://tutuge.me/2016/08/06/autolayout-example-with-masonry4/">有趣的Autolayout示例4-Masonry实现</a></li><li>2015-12-23: 感谢<a href="https://github.com/XVXVXXX" target="_blank" rel="noopener">XVXVXXX</a>的PR，更新了Case2</li><li>2015-12-15: 第三篇：<a href="http://tutuge.me/2015/12/14/autolayout-example-with-masonry3/">有趣的Autolayout示例3-Masonry实现</a></li><li>2015-11-27: 感谢“谢小雷”指出打字错误~</li><li>2015-9-10: 第二篇: <a href="http://tutuge.me/2015/08/08/autolayout-example-with-masonry2/">有趣的Autolayout示例2-Masonry实现</a></li><li>2015-9-1: 感谢“王振宇C艹”指出打字错误，已经修改了哈~</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>好久没有写Blog了，这段时间有点忙啊=。=<br>本文举了3个比较有“特点”的Autolayout例子，源于微博上好友的提问，感觉比较有意思，也比较有代表性，就写了出来，分享给大家~<br>至于为什么用Masonry，那是因为它好用啊！（被问到过有关Masonry的问题，就索性用它来实现吧=。=）。</p><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="/2015/05/23/autolayout-example-with-masonry/blog_autolayout_example_with_masonry_1.gif" alt="效果图"></p><h3 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h3><p><a href="https://github.com/zekunyan/AutolayoutExampleWithMasonry" target="_blank" rel="noopener">https://github.com/zekunyan/AutolayoutExampleWithMasonry</a></p><a id="more"></a><h3 id="关于例子工程结构"><a href="#关于例子工程结构" class="headerlink" title="关于例子工程结构"></a>关于例子工程结构</h3><p>实现的时候采用的是用StoryBoard拖拽约束+Masonry手写代码相结合的方式实现。最关键的地方是用Masonry，为了更好地突出重点。其它的无关紧要的空间约束，直接就拖拽了。</p><h2 id="关于Autolayout"><a href="#关于Autolayout" class="headerlink" title="关于Autolayout"></a>关于Autolayout</h2><p>刚开始学习Autolayout的时候，什么“Leading Edges”、“Horizontal Centers”，好多啊，感觉一下子适应不来，有时候面对一个界面布局上的需求，可能都无从下手。</p><p>总的来说，我觉得Autolayout的关键就是“<strong>Constraint（约束）</strong>”。其实就是以下两点：</p><ol><li>从显式设置frame的属性，到利用约束控制View的大小、位置。</li><li>思考如何布局时，重点从单个的View，到整体所有View之间的相互关系。</li></ol><p>既然没有了具体设置View的frame属性，也就是说，系统会在运行时，通过我们设定的“约束”，计算出每个View的frame，再去绘制屏幕内容。</p><p>也就是说，我们设置的Constraint，要能体现出View的<strong>位置（x、y坐标）</strong>、<strong>大小（宽高）</strong>。无论是用IB拖拽约束，还是手写代码，只要从这个角度去思考，很多问题就都能解决。</p><p>有关Autolayout的知识，网上有很多，在这里就不详细列出了，但是有个公式倒是可以贴出来：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewA-<span class="keyword">attribute</span> = viewB-<span class="keyword">attribute</span> * multiplier + <span class="keyword">constant</span></span><br></pre></td></tr></table></figure><h2 id="关于Masonry"><a href="#关于Masonry" class="headerlink" title="关于Masonry"></a>关于Masonry</h2><p>好用！</p><h2 id="Case-1-并排两个label，宽度由内容决定。父级View宽度不够时，优先显示左边label的内容"><a href="#Case-1-并排两个label，宽度由内容决定。父级View宽度不够时，优先显示左边label的内容" class="headerlink" title="Case 1: 并排两个label，宽度由内容决定。父级View宽度不够时，优先显示左边label的内容"></a>Case 1: 并排两个label，宽度由内容决定。父级View宽度不够时，优先显示左边label的内容</h2><p>遇到这种跟内容压缩、优先级有关的布局，就不得不提Autolayout中的两个重要的属性“<strong>Content Compression Resistance</strong>”和“<strong>Content Hugging</strong>”。</p><h3 id="Content-Compression-Resistance-不许挤我！"><a href="#Content-Compression-Resistance-不许挤我！" class="headerlink" title="Content Compression Resistance = 不许挤我！"></a>Content Compression Resistance = 不许挤我！</h3><p>对，这个属性说白了就是“不许挤我”=。=<br>这个属性的优先级（Priority）越高，越不“容易”被压缩。也就是说，当整体的空间装不下所有的View的时候，Content Compression Resistance优先级越高的，显示的内容越完整。</p><h3 id="Content-Hugging-抱紧！"><a href="#Content-Hugging-抱紧！" class="headerlink" title="Content Hugging = 抱紧！"></a>Content Hugging = 抱紧！</h3><p>这个属性的优先级越高，整个View就要越“抱紧”View里面的内容。也就是View的大小不会随着父级View的扩大而扩大。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>根据要求，可以将约束分为两个部分：</p><ol><li>整体空间足够时，两个label的宽度由内容决定，也就是说，label的“Content Hugging”优先级很高，而且没有固定的Width属性。</li><li>整体空间不够时，左边的label更不容易被压缩，也就是“Content Compression Resistance”优先级更高。</li></ol><p>重点：</p><ol><li>label不设置具体的宽度（width）属性，宽度由内容决定。</li><li>显示的优先级由“Content Compression Resistance”属性的高低决定。</li></ol><h3 id="约束示例图"><a href="#约束示例图" class="headerlink" title="约束示例图"></a>约束示例图</h3><p><img src="/2015/05/23/autolayout-example-with-masonry/blog_autolayout_example_with_masonry_2.png" alt="约束示例图"></p><h3 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h3><p>关键的代码如下：（label1是左边的label，label2是右边的）</p><h4 id="设置位置"><a href="#设置位置" class="headerlink" title="设置位置"></a>设置位置</h4><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// label1: 位于左上角</span></span><br><span class="line">[<span class="variable">_label1</span> mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.equalTo(<span class="variable">_contentView1</span>.mas_top).<span class="keyword">with</span>.offset(<span class="number">5</span>);</span><br><span class="line">    make.left.equalTo(<span class="variable">_contentView1</span>.mas_left).<span class="keyword">with</span>.offset(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 40高度</span></span><br><span class="line">    make.height.equalTo(@<span class="number">40</span>);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// label2: 位于右上角</span></span><br><span class="line">[<span class="variable">_label2</span> mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    <span class="comment">//左边贴着label1，间隔2</span></span><br><span class="line">    make.left.equalTo(<span class="variable">_label1</span>.mas_right).<span class="keyword">with</span>.offset(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上边贴着父view，间隔5</span></span><br><span class="line">    make.top.equalTo(<span class="variable">_contentView1</span>.mas_top).<span class="keyword">with</span>.offset(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右边的间隔保持大于等于2，注意是lessThanOrEqual</span></span><br><span class="line">    <span class="comment">//这里的“lessThanOrEqualTo”放在从左往右的X轴上考虑会更好理解。</span></span><br><span class="line">    <span class="comment">//即：label2的右边界的X坐标值“小于等于”containView的右边界的X坐标值。</span></span><br><span class="line">    make.right.lessThanOrEqualTo(<span class="variable">_contentView1</span>.mas_right).<span class="keyword">with</span>.offset(-<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只设置高度40</span></span><br><span class="line">    make.height.equalTo(@<span class="number">40</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="设置内容约束"><a href="#设置内容约束" class="headerlink" title="设置内容约束"></a>设置内容约束</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置label1的content hugging 为1000</span></span><br><span class="line">[_label1 setContentHuggingPriority:<span class="built_in">UILayoutPriorityRequired</span></span><br><span class="line">                           forAxis:<span class="built_in">UILayoutConstraintAxisHorizontal</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置label1的content compression 为1000</span></span><br><span class="line">[_label1 setContentCompressionResistancePriority:<span class="built_in">UILayoutPriorityRequired</span></span><br><span class="line">                                         forAxis:<span class="built_in">UILayoutConstraintAxisHorizontal</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置右边的label2的content hugging 为1000</span></span><br><span class="line">[_label2 setContentHuggingPriority:<span class="built_in">UILayoutPriorityRequired</span></span><br><span class="line">                           forAxis:<span class="built_in">UILayoutConstraintAxisHorizontal</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置右边的label2的content compression 为250</span></span><br><span class="line">[_label2 setContentCompressionResistancePriority:<span class="built_in">UILayoutPriorityDefaultLow</span></span><br><span class="line">                                         forAxis:<span class="built_in">UILayoutConstraintAxisHorizontal</span>];</span><br></pre></td></tr></table></figure><h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p>灵活运用“Content Compression Resistance”和“Content Hugging”属性。</p><h2 id="Case-2-四个ImageView整体居中，可以任意显示、隐藏"><a href="#Case-2-四个ImageView整体居中，可以任意显示、隐藏" class="headerlink" title="Case 2: 四个ImageView整体居中，可以任意显示、隐藏"></a>Case 2: 四个ImageView整体居中，可以任意显示、隐藏</h2><p>先看看示例的截图：</p><p><img src="/2015/05/23/autolayout-example-with-masonry/blog_autolayout_example_with_masonry_3.png" alt="效果图"></p><p>下面的四个Switch控件分别控制上面对应位置的图片是否显示。</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><ol><li>首先就是整体居中，为了实现这个，最简单的办法就是将四个图片“装进”一个<strong>容器View</strong>里面，然后让这个容器View在整个页面中居中即可。这样就不用控制每个图片的居中效果了。</li><li>然后就是显示与隐藏。在这里我直接控制图片ImageView的宽度，宽度为0的时候不就“隐藏”了吗。</li></ol><h3 id="约束示例图-1"><a href="#约束示例图-1" class="headerlink" title="约束示例图"></a>约束示例图</h3><p><img src="/2015/05/23/autolayout-example-with-masonry/blog_autolayout_example_with_masonry_4.png" alt="约束示例图"></p><p><strong>解释</strong></p><p>之所以这么设置，主要目的有以下几点：</p><ol><li>尽量减少无效的约束，保证约束不多也不少。</li><li>内部的每个imageView约束其实都只有四个：left、centerY、width和height，这样有个好处，就是可以在循环里面依次添加约束，大大减少代码量。</li><li>最右边的imageView还要单独设置跟容器View的右边约束，是为了不用设置容器View的width，保证容器View是刚好包含内部的View的，这样整体才是居中的。</li></ol><h3 id="关键代码-1"><a href="#关键代码-1" class="headerlink" title="关键代码"></a>关键代码</h3><p>先看看最外层容器View的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//containerView 就是 容器View</span></span><br><span class="line"></span><br><span class="line">[_containerView mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) &#123;</span><br><span class="line">    <span class="comment">//只设置高度，宽度由子View决定</span></span><br><span class="line">    <span class="built_in">make</span>.height.equalTo(@(IMAGE_SIZE));</span><br><span class="line">    <span class="comment">//水平居中</span></span><br><span class="line">    <span class="built_in">make</span>.centerX.equalTo(self.view.mas_centerX);</span><br><span class="line">    <span class="comment">//距离父View顶部200点</span></span><br><span class="line">    <span class="built_in">make</span>.top.equalTo(self.view.mas_top).offset(<span class="number">200</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>循环创建每个内部的imageView</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环创建、添加imageView</span></span><br><span class="line"><span class="keyword">for</span> (NSUInteger i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    UIImageView *imageView = [[UIImageView alloc] <span class="string">initWithImage:</span>[UIImage <span class="string">imageNamed:</span>_imageNames[i]]];</span><br><span class="line">    [_imageViews <span class="string">addObject:</span>imageView];</span><br><span class="line">    [_containerView <span class="string">addSubview:</span>imageView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是循环对imageView加上约束： 感谢<a href="https://github.com/XVXVXXX" target="_blank" rel="noopener">XVXVXXX</a>的PR:-D</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设定大小</span></span><br><span class="line">CGSize imageViewSize = <span class="built_in">CGSizeMake</span>(IMAGE_SIZE, IMAGE_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//分别设置每个imageView的宽高、左边、垂直中心约束，注意约束的对象</span></span><br><span class="line"><span class="comment">//每个View的左边约束和左边的View的右边相等=。=，有点绕口...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存循环中的临时结果</span></span><br><span class="line">__block UIView *lastView = nil;</span><br><span class="line">__block MASConstraint *widthConstraint = nil;</span><br><span class="line"></span><br><span class="line">NSUInteger arrayCount = _imageViews.count;</span><br><span class="line">[_imageViews enumerateObjectsUsingBlock:^(UIView *<span class="built_in">view</span>, NSUInteger idx, <span class="keyword">BOOL</span> *<span class="keyword">stop</span>) &#123;</span><br><span class="line">    [<span class="built_in">view</span> mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) &#123;</span><br><span class="line">        <span class="comment">//宽高固定</span></span><br><span class="line">        widthConstraint = make.width.<span class="built_in">equalTo</span>(<span class="comment">@(imageViewSize.width));</span></span><br><span class="line"><span class="comment">        make.height.equalTo(@</span>(imageViewSize.height));</span><br><span class="line">        <span class="comment">//左边约束</span></span><br><span class="line">        make.left.<span class="built_in">equalTo</span>(lastView ? lastView.mas_right : <span class="built_in">view</span>.superview.mas_left);</span><br><span class="line">        <span class="comment">//垂直中心对齐</span></span><br><span class="line">        make.centerY.<span class="built_in">equalTo</span>(<span class="built_in">view</span>.superview.mas_centerY);</span><br><span class="line">        <span class="comment">//设置最右边的imageView的右边与父view的最右对齐</span></span><br><span class="line">        <span class="keyword">if</span> (idx == arrayCount - <span class="number">1</span>) &#123;</span><br><span class="line">            make.right.<span class="built_in">equalTo</span>(<span class="built_in">view</span>.superview.mas_right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [_widthConstraints addObject:widthConstraint];</span><br><span class="line">        lastView = <span class="built_in">view</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>控制ImageView显示、隐藏的时候，直接让其宽度等于0就行：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)showOrHideImage:(<span class="built_in">UISwitch</span> *)sender &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> index = (<span class="built_in">NSUInteger</span>) sender.tag;</span><br><span class="line">    MASConstraint *width = _widthConstraints[index];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sender.on) &#123;</span><br><span class="line">        width.equalTo(@(IMAGE_SIZE));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        width.equalTo(@<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小节-1"><a href="#小节-1" class="headerlink" title="小节"></a>小节</h3><p>有时候用个“容器View”管理内部的View，往往会起到事半功倍的效果。而且在组织约束的时候，尽量的将约束统一起来，这样可以用一个函数去设置，减少代码量。</p><h2 id="Case-3-子View的宽度始终是父级View的一半（或者任意百分比）"><a href="#Case-3-子View的宽度始终是父级View的一半（或者任意百分比）" class="headerlink" title="Case 3: 子View的宽度始终是父级View的一半（或者任意百分比）"></a>Case 3: 子View的宽度始终是父级View的一半（或者任意百分比）</h2><p>其实这个很简单=。= 再看看这个公式：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewA-<span class="keyword">attribute</span> = viewB-<span class="keyword">attribute</span> * multiplier + <span class="keyword">constant</span></span><br></pre></td></tr></table></figure><p>这个是Autolayout里面一个约束的不同属性的基本组合关系，替换成宽度的话，就是下面这样：</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子<span class="keyword">View</span>的宽度 = 父级<span class="keyword">View</span>宽度 * 系数 + 常数；</span><br></pre></td></tr></table></figure><p>在Masonry里面，其实有个函数“<strong>multipliedBy</strong>”，就是用来设置multipler属性的（跟原本的NSLayoutConstraint的对应）。</p><h3 id="关键代码-2"><a href="#关键代码-2" class="headerlink" title="关键代码"></a>关键代码</h3><p>如下：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">subView</span> mas_makeConstraints:^(<span class="name">MASConstraintMaker</span> *make) &#123;</span><br><span class="line">    //上下左贴边</span><br><span class="line">    make.left.equalTo(<span class="name">_containerView.mas_left</span>)<span class="comment">;</span></span><br><span class="line">    make.top.equalTo(<span class="name">_containerView.mas_top</span>)<span class="comment">;</span></span><br><span class="line">    make.bottom.equalTo(<span class="name">_containerView.mas_bottom</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    //宽度为父view的宽度的一半</span><br><span class="line">    make.width.equalTo(<span class="name">_containerView.mas_width</span>).multipliedBy(<span class="name">0.5</span>)<span class="comment">;</span></span><br><span class="line">&#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>接着，只要控制父级View的宽度，子View的宽度就会随着变化了。</p><h3 id="小节-2"><a href="#小节-2" class="headerlink" title="小节"></a>小节</h3><p>multipliedBy在Masonry的Github主页里面没有=。=<br>所以要养成读头文件的习惯~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有关Autolayout的东西还有好多没有写，什么动画啊、动态修改约束之类的，本文也算是个引子吧，任重而道远~</p><p>能看到这的朋友，也算是很有耐心了，哈哈~~</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener">SnapKit/Masonry</a></li><li><a href="http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/" target="_blank" rel="noopener">Masonry介绍与使用实践(快速上手Autolayout)</a></li><li><a href="http://www.vienta.me/2014/12/07/AutoLayout-忘掉Frame-拥抱Constraint（I）/" target="_blank" rel="noopener">AutoLayout:忘掉Frame,拥抱Constraint</a></li><li><a href="https://www.zybuluo.com/MicroCai/note/73867#autolayout-基础" target="_blank" rel="noopener">Autolayout 基础</a></li><li><a href="http://codingobjc.com/blog/2015/01/28/autolayoutzhong-de-content-compression-resistancehe-content-huggingdao-di-shi-shi-yao-yi-si/" target="_blank" rel="noopener">对Auto Layout中的Content Compression Resistance和Content Hugging的总结</a></li><li><a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/Introduction/Introduction.html" target="_blank" rel="noopener">Auto Layout Guide</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;更新&quot;&gt;&lt;a href=&quot;#更新&quot; class=&quot;headerlink&quot; title=&quot;更新&quot;&gt;&lt;/a&gt;更新&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;2016-08-06: 第四篇: &lt;a href=&quot;http://tutuge.me/2016/08/06/autolayout-example-with-masonry4/&quot;&gt;有趣的Autolayout示例4-Masonry实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2015-12-23: 感谢&lt;a href=&quot;https://github.com/XVXVXXX&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;XVXVXXX&lt;/a&gt;的PR，更新了Case2&lt;/li&gt;
&lt;li&gt;2015-12-15: 第三篇：&lt;a href=&quot;http://tutuge.me/2015/12/14/autolayout-example-with-masonry3/&quot;&gt;有趣的Autolayout示例3-Masonry实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2015-11-27: 感谢“谢小雷”指出打字错误~&lt;/li&gt;
&lt;li&gt;2015-9-10: 第二篇: &lt;a href=&quot;http://tutuge.me/2015/08/08/autolayout-example-with-masonry2/&quot;&gt;有趣的Autolayout示例2-Masonry实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2015-9-1: 感谢“王振宇C艹”指出打字错误，已经修改了哈~&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;好久没有写Blog了，这段时间有点忙啊=。=&lt;br&gt;本文举了3个比较有“特点”的Autolayout例子，源于微博上好友的提问，感觉比较有意思，也比较有代表性，就写了出来，分享给大家~&lt;br&gt;至于为什么用Masonry，那是因为它好用啊！（被问到过有关Masonry的问题，就索性用它来实现吧=。=）。&lt;/p&gt;
&lt;h3 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;效果图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2015/05/23/autolayout-example-with-masonry/blog_autolayout_example_with_masonry_1.gif&quot; alt=&quot;效果图&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Github地址&quot;&gt;&lt;a href=&quot;#Github地址&quot; class=&quot;headerlink&quot; title=&quot;Github地址&quot;&gt;&lt;/a&gt;Github地址&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/zekunyan/AutolayoutExampleWithMasonry&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/zekunyan/AutolayoutExampleWithMasonry&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="Autolayout" scheme="http://tutuge.me/tags/Autolayout/"/>
    
      <category term="Masonry" scheme="http://tutuge.me/tags/Masonry/"/>
    
  </entry>
  
  <entry>
    <title>UITextView编辑时插入自定义表情-续-自定义表情图片的大小</title>
    <link href="http://tutuge.me/2015/04/21/resizable-nstextattachment/"/>
    <id>http://tutuge.me/2015/04/21/resizable-nstextattachment/</id>
    <published>2015-04-21T12:26:17.000Z</published>
    <updated>2018-10-07T17:37:29.301Z</updated>
    
    <content type="html"><![CDATA[<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><ul><li>2015-11-27：增加了利用NSTextAttachment的bounds属性修改大小的方法。</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是基于<a href="http://tutuge.me/2015/03/07/UITextView编辑时插入自定义表情-简单的图文混编/">UITextView编辑时插入自定义表情-简单的图文混编</a>写的，主要实现了在UITextView插入表情图片时，自定义表情大小的功能。</p><h4 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h4><p>本文代码工程地址：<a href="https://github.com/zekunyan/UITextViewDIYEmojiExample" target="_blank" rel="noopener">https://github.com/zekunyan/UITextViewDIYEmojiExample</a></p><h4 id="Gif示例图"><a href="#Gif示例图" class="headerlink" title="Gif示例图"></a>Gif示例图</h4><p><img src="/2015/04/21/resizable-nstextattachment/blog_resizable_nstextattachment_1.gif" alt="Gif示例图"></p><a id="more"></a><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><p>首先要明确我们要什么，很简单，就是<strong>指定NSTextAttachment在被绘制时的大小</strong>。</p><p>所以，按照这个思路，就可以去找找NSTextAttachment类的相关方法，看能不能通过继承或其他的方式改变大小。</p><h3 id="方法1-NSTextAttachmentContainer"><a href="#方法1-NSTextAttachmentContainer" class="headerlink" title="方法1 - NSTextAttachmentContainer"></a>方法1 - NSTextAttachmentContainer</h3><p>NSTextAttachment实现了“<strong>NSTextAttachmentContainer</strong>”这个Protocol，而这个Protocol里面有如下方法：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(CGRect)</span>attachmentBoundsForTextContainer:<span class="params">(NSTextContainer *)</span>textContainer</span><br><span class="line">                      proposedLineFragment:<span class="params">(CGRect)</span>lineFrag</span><br><span class="line">                             glyphPosition:<span class="params">(CGPoint)</span>position</span><br><span class="line">                            characterIndex:<span class="params">(NSUInteger)</span>charIndex</span><br></pre></td></tr></table></figure><p>再看看其解释：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Returns <span class="keyword">the</span> layout bounds <span class="keyword">of</span> <span class="keyword">the</span> <span class="keyword">text</span> attachment <span class="built_in">to</span> <span class="keyword">the</span> layout manager. (required)</span><br></pre></td></tr></table></figure></p><p>也就是说，在绘制NSTextAttachment的内容的时候，内容的“Bounds”是通过这个方法获得的。所以，可以重写这个方法，来达到我们的目的。</p><h3 id="方法2-直接修改bounds"><a href="#方法2-直接修改bounds" class="headerlink" title="方法2 - 直接修改bounds"></a>方法2 - 直接修改bounds</h3><p>NSTextAttachment还有一个属性<code>@property(nonatomic) CGRect bounds</code>，其解释如下：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Defines the layout bounds <span class="keyword">of</span> the receiver<span class="symbol">'s</span> graphical representation <span class="keyword">in</span> the <span class="literal">text</span> coordinate system.</span><br></pre></td></tr></table></figure></p><p>所以，修改这个也可以达到目的。</p><h2 id="实现方法1-继续扩展NSTextAttachment类"><a href="#实现方法1-继续扩展NSTextAttachment类" class="headerlink" title="实现方法1 - 继续扩展NSTextAttachment类"></a>实现方法1 - 继续扩展NSTextAttachment类</h2><h3 id="保存自定义Size"><a href="#保存自定义Size" class="headerlink" title="保存自定义Size"></a>保存自定义Size</h3><p>根据之前的定义，我们在自定义的类“EmojiTextAttachment”中再加一个保存大小的属性，如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EmojiTextAttachment类定义</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">EmojiTextAttachment </span>: NSTextAttachment</span><br><span class="line"><span class="comment">//表情的字符串表示，见前文</span></span><br><span class="line"><span class="variable">@property</span>(strong, nonatomic) NSString *emojiTag;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增：保存当前表情图片的大小</span></span><br><span class="line"><span class="variable">@property</span>(assign, nonatomic) CGSize emojiSize;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>有了“<strong>emojiSize</strong>”这个属性，我们就可以在自由的指定每个NSTextAttachment的大小。</p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>接下来就是重写方法，不多说，见代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EmojiTextAttachment实现</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EmojiTextAttachment</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重点！重写NSTextAttachmentContainer Protocol的方法</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)attachmentBoundsForTextContainer:(<span class="built_in">NSTextContainer</span> *)textContainer proposedLineFragment:(<span class="built_in">CGRect</span>)lineFrag glyphPosition:(<span class="built_in">CGPoint</span>)position characterIndex:(<span class="built_in">NSUInteger</span>)charIndex &#123;</span><br><span class="line"><span class="comment">// 返回我们指定的size</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, _emojiSize.width, _emojiSize.height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="实现方法2"><a href="#实现方法2" class="headerlink" title="实现方法2"></a>实现方法2</h2><p>直接在创建表情NSTextAttachment的时候设置<code>bounds</code>属性即可。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>增加了emojiSize属性后，我们就可以在创建表情，甚至创建后，自由的调整每个NSTextAttachment的大小。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一共只增加了十几行代码，但是效果还是不错哒~</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/NSTextAttachment_Class_TextKit/index.html#//apple_ref/occ/instp/NSTextAttachment/fileType" target="_blank" rel="noopener">NSTextAttachment</a></li><li><a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/NSTextAttachmentContainer_Protocol/index.html#//apple_ref/occ/intfm/NSTextAttachmentContainer/attachmentBoundsForTextContainer:proposedLineFragment:glyphPosition:characterIndex:" target="_blank" rel="noopener">NSTextAttachmentContainer</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;更新&quot;&gt;&lt;a href=&quot;#更新&quot; class=&quot;headerlink&quot; title=&quot;更新&quot;&gt;&lt;/a&gt;更新&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;2015-11-27：增加了利用NSTextAttachment的bounds属性修改大小的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文是基于&lt;a href=&quot;http://tutuge.me/2015/03/07/UITextView编辑时插入自定义表情-简单的图文混编/&quot;&gt;UITextView编辑时插入自定义表情-简单的图文混编&lt;/a&gt;写的，主要实现了在UITextView插入表情图片时，自定义表情大小的功能。&lt;/p&gt;
&lt;h4 id=&quot;Github&quot;&gt;&lt;a href=&quot;#Github&quot; class=&quot;headerlink&quot; title=&quot;Github&quot;&gt;&lt;/a&gt;Github&lt;/h4&gt;&lt;p&gt;本文代码工程地址：&lt;a href=&quot;https://github.com/zekunyan/UITextViewDIYEmojiExample&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/zekunyan/UITextViewDIYEmojiExample&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;Gif示例图&quot;&gt;&lt;a href=&quot;#Gif示例图&quot; class=&quot;headerlink&quot; title=&quot;Gif示例图&quot;&gt;&lt;/a&gt;Gif示例图&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/2015/04/21/resizable-nstextattachment/blog_resizable_nstextattachment_1.gif&quot; alt=&quot;Gif示例图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>RPC框架Thrift例子-PHP调用C++后端程序</title>
    <link href="http://tutuge.me/2015/04/19/thrift-example-cpp-and-php/"/>
    <id>http://tutuge.me/2015/04/19/thrift-example-cpp-and-php/</id>
    <published>2015-04-19T09:04:56.000Z</published>
    <updated>2018-10-07T17:37:28.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><ul><li>2016-02-22: Response对象不用主动创建。</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间用了一下Facebook的开源RPC框架Thrift，做PHP客户端调用C++后端程序，真心觉得Thrift不错！</p><p>本文项目地址：<a href="https://github.com/zekunyan/ThriftDemo_PHP_CPP" target="_blank" rel="noopener">https://github.com/zekunyan/ThriftDemo_PHP_CPP</a></p><p>先看看本文的例子示意图：</p><p><img src="/2015/04/19/thrift-example-cpp-and-php/blog_thrift_example_cpp_and_php_1.jpg" alt="通信示意图"></p><p><strong>流程</strong></p><ol><li>PHP客户端发起请求，请求参数是“Request”类型，里面有studentID参数。</li><li>CPP服务端收到请求返回数据，返回类型为“Response”，里面包含了student的信息，此处只是简单的示例。</li></ol><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h3><p>远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。 – 维基百科 - <a href="http://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8" target="_blank" rel="noopener">远程过程调用</a></p><p>通俗点讲，就是跨计算机、跨网络调用。</p><h3 id="什么是Thrift"><a href="#什么是Thrift" class="headerlink" title="什么是Thrift"></a>什么是Thrift</h3><p>Apache Thrift 是Facebook实现的一种高效的、支持多种编程语言的远程服务调用(RPC)的框架。它采用接口描述语言定义并创建服务，支持可扩展的跨语言服务开发，所包含的代码生成引擎可以在多种语言中，如 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, Smalltalk 等创建高效的、无缝的服务，其传输数据采用二进制格式，相对 XML 和 JSON 体积更小，对于高并发、大数据量和多语言的环境更有优势。 – <a href="https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/" target="_blank" rel="noopener">Apache Thrift - 可伸缩的跨语言服务开发框架</a></p><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><ol><li>配置环境。C++的如CMake、make、g++；PHP的如php、php-fpm、Apache（Nginx）。</li><li>根据需求，编写thrift接口定义文件（IDL定义文件）。</li><li>使用thrift程序，为不同的语言生成代码。</li><li>根据需求，修改生成的代码（主要是Server端），编写实际的业务逻辑。</li><li>编译、部署。</li></ol><h2 id="Thrift的接口定义文件"><a href="#Thrift的接口定义文件" class="headerlink" title="Thrift的接口定义文件"></a>Thrift的接口定义文件</h2><p>在利用Thrift开发的过程中，重点就是编写接口定义文件。<br>一般来说，接口定义文件决定了RPC过程中的通信数据结构、通信接口定义等。</p><p>总的来说，thrift的接口定义语法类似于C语言，包含了struct、enum、map、list等基础数据结构，同时支持大部分基本数据类型，如32位整型“i32”等。</p><p>详细的接口定义请参考：</p><ul><li><a href="http://thrift.apache.org/docs/idl" target="_blank" rel="noopener">Thrift interface description language</a></li><li><a href="https://git-wip-us.apache.org/repos/asf?p=thrift.git;a=blob_plain;f=tutorial/tutorial.thrift" target="_blank" rel="noopener">example.thrift</a></li></ul><p>看看本例子中的定义文件“TTG.thrift”：</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cpp TTG</span><br><span class="line"><span class="keyword">namespace</span> php TTG</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ResponseState</span> </span>&#123;</span><br><span class="line">    StateOk = <span class="number">0</span>,</span><br><span class="line">    StateError = <span class="number">1</span>,</span><br><span class="line">    StateEmpty = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="built_in">i32</span> studentID = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="built_in">i32</span> studentID = <span class="number">0</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="built_in">string</span> name,</span><br><span class="line">    <span class="number">3</span>: list&lt;<span class="keyword">string</span>&gt; infos,</span><br><span class="line">    <span class="number">4</span>: ResponseState state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">TTGService</span> </span>&#123;</span><br><span class="line">    Response getStudentInfo(<span class="number">1</span>: Request request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>先定义命名空间，尽量减少命名冲突。</li><li>Request类型：PHP客户端请求的数据类型。</li><li>Response类型：CPP服务端返回的数据类型。</li><li>ResponseState枚举：定义返回的状态。</li><li>TTGService：服务接口定义。</li></ol><h2 id="生成对应语言的代码！"><a href="#生成对应语言的代码！" class="headerlink" title="生成对应语言的代码！"></a>生成对应语言的代码！</h2><p>是的，生成代码！这是我觉得Thrift框架最“神奇”的地方。我们只需要执行几条命令，就可以根据接口定义文件“生成”对应语言的代码。然后我们只需要将对应的业务逻辑加入到生成的代码中即可。</p><p>如生成CPP服务端的代码：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thrift <span class="comment">--gen cpp TTG.thrift</span></span><br></pre></td></tr></table></figure><p>然后就会生成如下代码。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TTGService.cpp</span><br><span class="line">TTGService.h</span><br><span class="line">TTGService_server<span class="selector-class">.skeleton</span><span class="selector-class">.cpp</span></span><br><span class="line">TTG_constants.cpp</span><br><span class="line">TTG_constants.h</span><br><span class="line">TTG_types.cpp</span><br><span class="line">TTG_types.h</span><br></pre></td></tr></table></figure><h2 id="根据需要修改生成的代码"><a href="#根据需要修改生成的代码" class="headerlink" title="根据需要修改生成的代码"></a>根据需要修改生成的代码</h2><p>生成CPP、PHP端的代码以后，我们就可以根据需要修改、添加业务代码。</p><h3 id="CPP服务端"><a href="#CPP服务端" class="headerlink" title="CPP服务端"></a>CPP服务端</h3><p>在生成CPP的代码时，会生成一个“TTGService_server.skeleton.cpp”文件，这个就是我们的CPP服务端的代码“架子”。其中重点如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现调用的接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TTGServiceHandler</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> TTGServiceIf &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">TTGServiceHandler() &#123;</span><br><span class="line">    <span class="comment">// Your initialization goes here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口实现部分，实现getStudentInfo这个接口的具体细节，如根据request创建、返回对应的response</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getStudentInfo</span><span class="params">(Response&amp; _return, <span class="keyword">const</span> Request&amp; request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your implementation goes here</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"getStudentInfo\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>我们将其改成：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> getStudentInfo(Response &amp;_<span class="keyword">return</span>, <span class="keyword">const</span> Request &amp;request) &#123;</span><br><span class="line">    <span class="comment">// 输出请求参数</span></span><br><span class="line">    cout&lt;&lt;<span class="string">"Request: "</span>&lt;&lt;request.studentID&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填充数据，Response对象不用主动创建，进入函数时已经创建好了</span></span><br><span class="line">    _<span class="keyword">return</span>.studentID = request.studentID;</span><br><span class="line">    _<span class="keyword">return</span>.name = <span class="string">"tutuge"</span>;</span><br><span class="line">    _<span class="keyword">return</span>.infos.push_back(<span class="string">"Info 1"</span>);</span><br><span class="line">    _<span class="keyword">return</span>.infos.push_back(<span class="string">"Info 2"</span>);</span><br><span class="line">    _<span class="keyword">return</span>.state = ResponseState::StateOk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，CPP服务端的编写就完成了，接下来我们只需要编译、链接，执行最终生成的可执行文件即可。</p><h3 id="PHP客户端"><a href="#PHP客户端" class="headerlink" title="PHP客户端"></a>PHP客户端</h3><p>PHP客户端的编写比较简单，直接参考代码吧：<a href="https://github.com/zekunyan/ThriftDemo_PHP_CPP/blob/master/PHP/client.php" target="_blank" rel="noopener">https://github.com/zekunyan/ThriftDemo_PHP_CPP/blob/master/PHP/client.php</a></p><h2 id="编译、链接，运行"><a href="#编译、链接，运行" class="headerlink" title="编译、链接，运行"></a>编译、链接，运行</h2><p>用CMake，或者直接编写makefile均可，保证Thrift装好就行了。</p><p>直接运行最后生成的可执行文件TTG.run即可。</p><p>从浏览器，或者直接运行client.php，即可看到如下输出：</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">object(TTG\Response)[<span class="number">9</span>]</span><br><span class="line">  <span class="keyword">public</span> <span class="string">'studentID'</span> =&gt; <span class="keyword">int</span> <span class="number">100</span></span><br><span class="line">  <span class="keyword">public</span> <span class="string">'name'</span> =&gt; string <span class="string">'tutuge'</span> (length=<span class="number">6</span>)</span><br><span class="line">  <span class="keyword">public</span> <span class="string">'infos'</span> =&gt;</span><br><span class="line">    <span class="keyword">array</span> (size=<span class="number">2</span>)</span><br><span class="line">      <span class="number">0</span> =&gt; string <span class="string">'Info 1'</span> (length=<span class="number">6</span>)</span><br><span class="line">      <span class="number">1</span> =&gt; string <span class="string">'Info 2'</span> (length=<span class="number">6</span>)</span><br><span class="line">  <span class="keyword">public</span> <span class="string">'state'</span> =&gt; <span class="keyword">int</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Thrift是个好东西！就是文档好少=。=</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://thrift.apache.org/" target="_blank" rel="noopener">Apache Thrift</a></li><li><a href="http://thrift.apache.org/tutorial/php" target="_blank" rel="noopener">Thrift PHP Tutorial</a></li><li><a href="http://thrift.apache.org/tutorial/cpp" target="_blank" rel="noopener">Thrift C++ Tutorial</a></li><li><a href="http://en.wikipedia.org/wiki/Apache_Thrift" target="_blank" rel="noopener">Apache Thrift</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/" target="_blank" rel="noopener">Apache Thrift - 可伸缩的跨语言服务开发框架</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;更新&quot;&gt;&lt;a href=&quot;#更新&quot; class=&quot;headerlink&quot; title=&quot;更新&quot;&gt;&lt;/a&gt;更新&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;2016-02-22: Response对象不用主动创建。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间用了一下Facebook的开源RPC框架Thrift，做PHP客户端调用C++后端程序，真心觉得Thrift不错！&lt;/p&gt;
&lt;p&gt;本文项目地址：&lt;a href=&quot;https://github.com/zekunyan/ThriftDemo_PHP_CPP&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/zekunyan/ThriftDemo_PHP_CPP&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先看看本文的例子示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2015/04/19/thrift-example-cpp-and-php/blog_thrift_example_cpp_and_php_1.jpg&quot; alt=&quot;通信示意图&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PHP客户端发起请求，请求参数是“Request”类型，里面有studentID参数。&lt;/li&gt;
&lt;li&gt;CPP服务端收到请求返回数据，返回类型为“Response”，里面包含了student的信息，此处只是简单的示例。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="服务端" scheme="http://tutuge.me/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="C++" scheme="http://tutuge.me/tags/C/"/>
    
      <category term="PHP" scheme="http://tutuge.me/tags/PHP/"/>
    
      <category term="后端" scheme="http://tutuge.me/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>GCD使用经验与技巧浅谈</title>
    <link href="http://tutuge.me/2015/04/03/something-about-gcd/"/>
    <id>http://tutuge.me/2015/04/03/something-about-gcd/</id>
    <published>2015-04-03T13:59:56.000Z</published>
    <updated>2018-10-07T17:37:28.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>GCD(Grand Central Dispatch)可以说是Mac、iOS开发中的一大“利器”，本文就总结一些有关使用GCD的经验与技巧。</p><h2 id="dispatch-once-t必须是全局或static变量"><a href="#dispatch-once-t必须是全局或static变量" class="headerlink" title="dispatch_once_t必须是全局或static变量"></a>dispatch_once_t必须是全局或static变量</h2><p>这一条算是“老生常谈”了，但我认为还是有必要强调一次，毕竟非全局或非static的dispatch_once_t变量在使用时会导致非常不好排查的bug，正确的如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态变量，保证只有一份实例，才能确保只执行一次</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">   <span class="comment">//单例代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其实就是保证<strong>dispatch_once_t</strong>只有一份实例。</p><a id="more"></a><h2 id="dispatch-queue-create的第二个参数"><a href="#dispatch-queue-create的第二个参数" class="headerlink" title="dispatch_queue_create的第二个参数"></a>dispatch_queue_create的第二个参数</h2><p><strong>dispatch_queue_create</strong>，创建队列用的，它的参数只有两个，原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> dispatch_queue_create ( <span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="keyword">dispatch_queue_attr_t</span> attr );</span><br></pre></td></tr></table></figure><p>在网上的大部分教程里（甚至Apple自己的文档里），都是这么创建串行队列的：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t<span class="built_in"> queue </span>= dispatch_queue_create(<span class="string">"com.example.MyQueue"</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>看，第二个参数传的是“<strong>NULL</strong>”。  但是dispatch_queue_attr_t类型是有已经定义好的常量的，所以我认为，为了更加的清晰、严谨，最好如下创建队列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串行队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.example.MyQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line"><span class="comment">//并行队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.example.MyQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure><p>常量就是为了使代码更加“易懂”，更加清晰，既然有，为啥不用呢~</p><h2 id="dispatch-after是延迟提交，不是延迟运行"><a href="#dispatch-after是延迟提交，不是延迟运行" class="headerlink" title="dispatch_after是延迟提交，不是延迟运行"></a>dispatch_after是<strong>延迟提交</strong>，不是<strong>延迟运行</strong></h2><p>先看看官方文档的说明：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enqueue <span class="keyword">a</span> block <span class="keyword">for</span> execution <span class="keyword">at</span> <span class="keyword">the</span> specified <span class="built_in">time</span>.</span><br></pre></td></tr></table></figure><p><strong>Enqueue</strong>，就是入队，指的就是将一个Block在特定的延时以后，加入到指定的队列中，<strong>不是在特定的时间后立即运行！</strong>。</p><p>看看如下代码示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建串行队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"me.tutuge.test.gcd"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line"><span class="comment">//立即打印一条信息</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Begin add block..."</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交一个block</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">//Sleep 10秒</span></span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"First block done..."</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5 秒以后提交block</span></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">5</span> * <span class="built_in">NSEC_PER_SEC</span>)), queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"After..."</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2015<span class="selector-tag">-03-31</span> 20<span class="selector-pseudo">:57</span><span class="selector-pseudo">:27.122</span> <span class="selector-tag">GCDTest</span><span class="selector-attr">[45633:1812016]</span> <span class="selector-tag">Begin</span> <span class="selector-tag">add</span> <span class="selector-tag">block</span>...</span><br><span class="line">2015<span class="selector-tag">-03-31</span> 20<span class="selector-pseudo">:57</span><span class="selector-pseudo">:37.127</span> <span class="selector-tag">GCDTest</span><span class="selector-attr">[45633:1812041]</span> <span class="selector-tag">First</span> <span class="selector-tag">block</span> <span class="selector-tag">done</span>...</span><br><span class="line">2015<span class="selector-tag">-03-31</span> 20<span class="selector-pseudo">:57</span><span class="selector-pseudo">:37.127</span> <span class="selector-tag">GCDTest</span><span class="selector-attr">[45633:1812041]</span> <span class="selector-tag">After</span>...</span><br></pre></td></tr></table></figure><p>从结果也验证了，dispatch_after只是延时提交block，并不是延时后立即执行。所以想用dispatch_after精确控制运行状态的朋友可要注意了~</p><h2 id="正确创建dispatch-time-t"><a href="#正确创建dispatch-time-t" class="headerlink" title="正确创建dispatch_time_t"></a>正确创建dispatch_time_t</h2><p>用dispatch_after的时候就会用到dispatch_time_t变量，但是如何创建合适的时间呢？答案就是用<strong>dispatch_time</strong>函数，其原型如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_time_t </span><span class="keyword">dispatch_time </span>( <span class="keyword">dispatch_time_t </span>when, int64_t delta )<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>第一个参数一般是<strong>DISPATCH_TIME_NOW</strong>，表示从现在开始。<br>那么第二个参数就是真正的延时的具体时间。</p><p>这里要特别注意的是，<strong>delta</strong>参数是“<strong>纳秒！</strong>”，就是说，延时1秒的话，delta应该是“1000000000”=。=，太长了，所以理所当然系统提供了常量，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSEC_PER_SEC 1000000000ull</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USEC_PER_SEC 1000000ull</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSEC_PER_USEC 1000ull</span></span><br></pre></td></tr></table></figure><p>关键词解释：</p><ul><li>NSEC：纳秒。</li><li>USEC：微妙。</li><li>SEC：秒</li><li>PER：每</li></ul><p>所以：</p><ol><li>NSEC_PER_SEC，每秒有多少纳秒。</li><li>USEC_PER_SEC，每秒有多少毫秒。（注意是指在纳秒的基础上）</li><li>NSEC_PER_USEC，每毫秒有多少纳秒。</li></ol><p>所以，延时<strong>1秒</strong>可以写成如下几种：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_time(DISPATCH_TIME_NOW, </span><span class="number">1</span> * NSEC_PER_SEC)<span class="comment">;</span></span><br><span class="line"><span class="keyword">dispatch_time(DISPATCH_TIME_NOW, </span><span class="number">1000</span> * USEC_PER_SEC)<span class="comment">;</span></span><br><span class="line"><span class="keyword">dispatch_time(DISPATCH_TIME_NOW, </span>USEC_PER_SEC * NSEC_PER_USEC)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>最后一个“<strong>USEC_PER_SEC * NSEC_PER_USEC</strong>”，翻译过来就是“<strong>每秒的毫秒数乘以每毫秒的纳秒数</strong>”，也就是“<strong>每秒的纳秒数</strong>”，所以，延时500毫秒之类的，也就不难了吧~</p><h2 id="dispatch-suspend-立即停止队列的运行"><a href="#dispatch-suspend-立即停止队列的运行" class="headerlink" title="dispatch_suspend != 立即停止队列的运行"></a>dispatch_suspend != 立即停止队列的运行</h2><p><strong>dispatch_suspend</strong>，<strong>dispatch_resume</strong>提供了“挂起、恢复”队列的功能，简单来说，就是可以暂停、恢复队列上的任务。但是这里的“<strong>挂起</strong>”，并不能保证可以<strong>立即</strong>停止队列上正在运行的block，看如下例子：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"me.tutuge.test.gcd"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交第一个block，延时5秒打印。</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"After 5 seconds..."</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交第二个block，也是延时5秒打印</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"After 5 seconds again..."</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//延时一秒</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"sleep 1 second..."</span>);</span><br><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//挂起队列</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"suspend..."</span>);</span><br><span class="line">dispatch_suspend(queue);</span><br><span class="line"></span><br><span class="line"><span class="comment">//延时10秒</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"sleep 10 second..."</span>);</span><br><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//恢复队列</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"resume..."</span>);</span><br><span class="line">dispatch_resume(queue);</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2015<span class="selector-tag">-04-01</span> 00<span class="selector-pseudo">:32</span><span class="selector-pseudo">:09.903</span> <span class="selector-tag">GCDTest</span><span class="selector-attr">[47201:1883834]</span> <span class="selector-tag">sleep</span> 1 <span class="selector-tag">second</span>...</span><br><span class="line">2015<span class="selector-tag">-04-01</span> 00<span class="selector-pseudo">:32</span><span class="selector-pseudo">:10.910</span> <span class="selector-tag">GCDTest</span><span class="selector-attr">[47201:1883834]</span> <span class="selector-tag">suspend</span>...</span><br><span class="line">2015<span class="selector-tag">-04-01</span> 00<span class="selector-pseudo">:32</span><span class="selector-pseudo">:10.910</span> <span class="selector-tag">GCDTest</span><span class="selector-attr">[47201:1883834]</span> <span class="selector-tag">sleep</span> 10 <span class="selector-tag">second</span>...</span><br><span class="line">2015<span class="selector-tag">-04-01</span> 00<span class="selector-pseudo">:32</span><span class="selector-pseudo">:14.908</span> <span class="selector-tag">GCDTest</span><span class="selector-attr">[47201:1883856]</span> <span class="selector-tag">After</span> 5 <span class="selector-tag">seconds</span>...</span><br><span class="line">2015<span class="selector-tag">-04-01</span> 00<span class="selector-pseudo">:32</span><span class="selector-pseudo">:20.911</span> <span class="selector-tag">GCDTest</span><span class="selector-attr">[47201:1883834]</span> <span class="selector-tag">resume</span>...</span><br><span class="line">2015<span class="selector-tag">-04-01</span> 00<span class="selector-pseudo">:32</span><span class="selector-pseudo">:25.912</span> <span class="selector-tag">GCDTest</span><span class="selector-attr">[47201:1883856]</span> <span class="selector-tag">After</span> 5 <span class="selector-tag">seconds</span> <span class="selector-tag">again</span>...</span><br></pre></td></tr></table></figure><p>可知，在dispatch_suspend挂起队列后，第一个block<strong>还是在运行</strong>，并且正常输出。<br>结合文档，我们可以得知，dispatch_suspend并不会立即暂停正在运行的block，而是在当前block执行完成后，暂停后续的block执行。</p><p>所以下次想暂停正在队列上运行的block时，还是不要用dispatch_suspend了吧~</p><h2 id="“同步”的dispatch-apply"><a href="#“同步”的dispatch-apply" class="headerlink" title="“同步”的dispatch_apply"></a>“同步”的dispatch_apply</h2><p>dispatch_apply的作用是在一个队列（串行或并行）上“运行”多次block，其实就是简化了用循环去向队列依次添加block任务。但是我个人觉得这个函数就是个“坑”，先看看如下代码运行结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建异步串行队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"me.tutuge.test.gcd"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行block3次</span></span><br><span class="line">dispatch_apply(<span class="number">3</span>, <span class="built_in">queue</span>, ^(<span class="keyword">size_t</span> i) &#123;</span><br><span class="line">    NSLog(@<span class="string">"apply loop: %zu"</span>, i);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印信息</span></span><br><span class="line">NSLog(@<span class="string">"After apply"</span>);</span><br></pre></td></tr></table></figure><p>运行的结果是：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2015<span class="selector-tag">-04-01</span> 00<span class="selector-pseudo">:55</span><span class="selector-pseudo">:40.854</span> <span class="selector-tag">GCDTest</span><span class="selector-attr">[47402:1893289]</span> <span class="selector-tag">apply</span> <span class="selector-tag">loop</span>: 0</span><br><span class="line">2015<span class="selector-tag">-04-01</span> 00<span class="selector-pseudo">:55</span><span class="selector-pseudo">:40.856</span> <span class="selector-tag">GCDTest</span><span class="selector-attr">[47402:1893289]</span> <span class="selector-tag">apply</span> <span class="selector-tag">loop</span>: 1</span><br><span class="line">2015<span class="selector-tag">-04-01</span> 00<span class="selector-pseudo">:55</span><span class="selector-pseudo">:40.856</span> <span class="selector-tag">GCDTest</span><span class="selector-attr">[47402:1893289]</span> <span class="selector-tag">apply</span> <span class="selector-tag">loop</span>: 2</span><br><span class="line">2015<span class="selector-tag">-04-01</span> 00<span class="selector-pseudo">:55</span><span class="selector-pseudo">:40.856</span> <span class="selector-tag">GCDTest</span><span class="selector-attr">[47402:1893289]</span> <span class="selector-tag">After</span> <span class="selector-tag">apply</span></span><br></pre></td></tr></table></figure><p>看，明明是提交到异步的队列去运行，但是“After apply”居然在apply后打印，也就是说，dispatch_apply将外面的线程（main线程）<strong>“阻塞”</strong>了！</p><p>查看官方文档，dispatch_apply确实会“等待”其所有的循环运行完毕才往下执行=。=，看来要小心使用了。</p><h2 id="避免死锁！"><a href="#避免死锁！" class="headerlink" title="避免死锁！"></a>避免死锁！</h2><h4 id="dispatch-sync导致的死锁"><a href="#dispatch-sync导致的死锁" class="headerlink" title="dispatch_sync导致的死锁"></a>dispatch_sync导致的死锁</h4><p>涉及到多线程的时候，不可避免的就会有“死锁”这个问题，在使用GCD时，往往一不小心，就可能造成死锁，看看下面的“<strong>死锁</strong>”例子：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在main线程使用“同步”方法提交Block，必定会死锁。</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"I am block..."</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>你可能会说，这么低级的错误，我怎么会犯，那么，看看下面的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)updateUI1 &#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Update ui 1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//死锁！</span></span><br><span class="line">        [<span class="keyword">self</span> updateUI2];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)updateUI2 &#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Update ui 2"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在你不注意的时候，嵌套调用可能就会造成死锁！所以为了“世界和平”=。=，我们还是少用<strong>dispatch_sync</strong>吧。</p><h4 id="dispatch-apply导致的死锁！"><a href="#dispatch-apply导致的死锁！" class="headerlink" title="dispatch_apply导致的死锁！"></a>dispatch_apply导致的死锁！</h4><p>啥，dispatch_apply导致的死锁？。。。是的，前一节讲到，dispatch_apply会<strong>等</strong>循环执行完成，这不就差不多是<strong>阻塞</strong>了吗。看如下例子：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(<span class="string">"me.tutuge.test.gcd"</span>, DISPATCH_QUEUE_SERIAL)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_apply(<span class="number">3</span>, queue, ^(<span class="name">size_t</span> i) &#123;</span><br><span class="line">NSLog(@<span class="string">"apply loop: %zu"</span>, i)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    //再来一个dispatch_apply！死锁！</span><br><span class="line">dispatch_apply(<span class="number">3</span>, queue, ^(<span class="name">size_t</span> j) &#123;</span><br><span class="line">NSLog(@<span class="string">"apply loop inside %zu"</span>, j)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这端代码只会输出“apply loop: 1”。。。就没有然后了=。=</p><p>所以，一定要避免dispatch_apply的<strong>嵌套调用</strong>。</p><h2 id="灵活使用dispatch-group"><a href="#灵活使用dispatch-group" class="headerlink" title="灵活使用dispatch_group"></a>灵活使用dispatch_group</h2><p>很多时候我们需要等待一系列任务（block）执行完成，然后再做一些收尾的工作。如果是有序的任务，可以分步骤完成的，直接使用串行队列就行。但是如果是一系列<strong>并行</strong>执行的任务呢？这个时候，就需要dispatch_group帮忙了~总的来说，dispatch_group的使用分如下几步：</p><ol><li>创建dispatch_group_t</li><li>添加任务（block）</li><li>添加结束任务（如清理操作、通知UI等）</li></ol><p>下面着重讲讲在后面两步。</p><h4 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h4><p>添加任务可以分为以下两种情况：</p><ol><li>自己创建队列：使用<strong>dispatch_group_async</strong>。</li><li>无法直接使用队列变量（如使用AFNetworking添加异步任务）：使用<strong>dispatch_group_enter</strong>，<strong>dispatch_group_leave</strong>。</li></ol><p>自己创建队列时，当然就用dispatch_group_async函数，简单有效，简单例子如下：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省去创建group、queue代码。。。</span></span><br><span class="line"></span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    <span class="comment">//Do you work...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当你无法直接使用队列变量时，就无法使用dispatch_group_async了，下面以使用AFNetworking时的情况：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];</span><br><span class="line"></span><br><span class="line"><span class="comment">//Enter group</span></span><br><span class="line">dispatch_group_enter(<span class="keyword">group</span>);</span><br><span class="line">[manager GET:@"http:<span class="comment">//www.baidu.com" parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123;</span></span><br><span class="line">    <span class="comment">//Deal with result...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Leave group</span></span><br><span class="line">    dispatch_group_leave(<span class="keyword">group</span>);</span><br><span class="line">&#125;    failure:^(AFHTTPRequestOperation *operation, NSError *<span class="keyword">error</span>) &#123;</span><br><span class="line">    <span class="comment">//Deal with error...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Leave group</span></span><br><span class="line">    dispatch_group_leave(<span class="keyword">group</span>);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//More request...</span></span><br></pre></td></tr></table></figure><p>使用<strong>dispatch_group_enter</strong>，<strong>dispatch_group_leave</strong>就可以方便的将一系列网络请求“<strong>打包</strong>”起来~</p><h4 id="添加结束任务"><a href="#添加结束任务" class="headerlink" title="添加结束任务"></a>添加结束任务</h4><p>添加结束任务也可以分为两种情况，如下：</p><ol><li>在当前线程<strong>阻塞的同步等待</strong>：dispatch_group_wait。</li><li>添加一个异步执行的任务作为结束任务：dispatch_group_notify</li></ol><p>这两个比较简单，就不再贴代码了=。=</p><h2 id="使用dispatch-barrier-async-dispatch-barrier-sync的注意事项"><a href="#使用dispatch-barrier-async-dispatch-barrier-sync的注意事项" class="headerlink" title="使用dispatch_barrier_async,dispatch_barrier_sync的注意事项"></a>使用dispatch_barrier_async,dispatch_barrier_sync的注意事项</h2><p>dispatch_barrier_async的作用就是向某个队列插入一个block，当目前正在执行的block运行完成后，阻塞这个block后面添加的block，只运行这个block直到完成，然后再继续后续的任务，有点“唯我独尊”的感觉=。=</p><p>值得注意的是：</p><ol><li>dispatch_barrier_(a)sync只在自己创建的并发队列上有效，在全局(Global)并发队列、串行队列上，效果跟<strong>dispatch_(a)sync</strong>效果一样。</li><li>既然在串行队列上跟<strong>dispatch_(a)sync</strong>效果一样，那就要小心别死锁！</li></ol><h2 id="dispatch-set-context与dispatch-set-finalizer-f的配合使用"><a href="#dispatch-set-context与dispatch-set-finalizer-f的配合使用" class="headerlink" title="dispatch_set_context与dispatch_set_finalizer_f的配合使用"></a>dispatch_set_context与dispatch_set_finalizer_f的配合使用</h2><p>dispatch_set_context可以为队列添加<strong>上下文数据</strong>，但是因为GCD是C语言接口形式的，所以其context参数类型是“<strong>void *</strong>”。也就是说，我们创建context时有如下几种选择：</p><ol><li>用C语言的malloc创建context数据。</li><li>用C++的new创建类对象。</li><li>用Objective-C的对象，但是要用__bridge等关键字转为Core Foundation对象。</li></ol><p>以上所有创建context的方法都有一个必须的要求，就是都要<strong>释放内存！</strong>，无论是用<strong>free、delete还是CF的CFRelease</strong>，我们都要确保在队列不用的时候，释放context的内存，否则就会造成内存泄露。</p><p>所以，使用dispatch_set_context的时候，最好结合dispatch_set_finalizer_f使用，为队列设置“析构函数”，在这个函数里面释放内存，大致如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanStaff</span><span class="params">(<span class="keyword">void</span> *context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//释放context的内存！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//CFRelease(context);</span></span><br><span class="line">    <span class="comment">//free(context);</span></span><br><span class="line">    <span class="comment">//delete context;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//在队列创建后，设置其“析构函数”</span></span><br><span class="line">dispatch_set_finalizer_f(<span class="built_in">queue</span>, cleanStaff);</span><br></pre></td></tr></table></figure><p>详细用法，请看我之前写的Blog<a href="http://tutuge.me/2015/03/29/bind-data-to-gcd-queue/">为GCD队列绑定NSObject类型上下文数据-利用__bridge_retained(transfer)转移内存管理权</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实本文更像是总结了GCD中的“坑”=。=</p><p>至于经验，总结一条，就是使用任何技术，都要研究透彻，否则后患无穷啊~</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.apple.com/library/prerelease/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html" target="_blank" rel="noopener">Grand Central Dispatch (GCD) Reference</a></li><li><a href="https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091" target="_blank" rel="noopener">Concurrency Programming Guide</a></li><li><a href="http://commandshift.co.uk/blog/2014/03/19/using-dispatch-groups-to-wait-for-multiple-web-services" target="_blank" rel="noopener">Using Dispatch Groups to Wait for Multiple Web Services</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;GCD(Grand Central Dispatch)可以说是Mac、iOS开发中的一大“利器”，本文就总结一些有关使用GCD的经验与技巧。&lt;/p&gt;
&lt;h2 id=&quot;dispatch-once-t必须是全局或static变量&quot;&gt;&lt;a href=&quot;#dispatch-once-t必须是全局或static变量&quot; class=&quot;headerlink&quot; title=&quot;dispatch_once_t必须是全局或static变量&quot;&gt;&lt;/a&gt;dispatch_once_t必须是全局或static变量&lt;/h2&gt;&lt;p&gt;这一条算是“老生常谈”了，但我认为还是有必要强调一次，毕竟非全局或非static的dispatch_once_t变量在使用时会导致非常不好排查的bug，正确的如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//静态变量，保证只有一份实例，才能确保只执行一次&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;dispatch_once_t&lt;/span&gt; onceToken;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;dispatch_once&lt;/span&gt;(&amp;amp;onceToken, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//单例代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其实就是保证&lt;strong&gt;dispatch_once_t&lt;/strong&gt;只有一份实例。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>为GCD队列绑定NSObject类型上下文数据-利用__bridge_retained(transfer)转移内存管理权</title>
    <link href="http://tutuge.me/2015/03/29/bind-data-to-gcd-queue/"/>
    <id>http://tutuge.me/2015/03/29/bind-data-to-gcd-queue/</id>
    <published>2015-03-29T11:27:40.000Z</published>
    <updated>2018-10-07T17:37:29.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2015-5-28更新"><a href="#2015-5-28更新" class="headerlink" title="2015-5-28更新"></a>2015-5-28更新</h2><p>下面评论的好友“@Jim”给了种新的思路，就是在清除context的函数里面，用“<strong>_bridge_transfer</strong>”转换context，把context的内存管理权限重新交给ARC，这样，就不用显式调用“<strong>CFRelease</strong>”了。如下：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> cleanStaff(<span class="literal">void</span> *context) &#123;</span><br><span class="line">    <span class="comment">//这里用_bridge_transfer转换，将内存管理权限交还给ARC</span></span><br><span class="line">    <span class="built_in">Data</span> *<span class="built_in">data</span> = (_bridge_transfer <span class="built_in">Data</span> *)(context);</span><br><span class="line">    NSLog(@<span class="string">"In clean, context number: %d"</span>, <span class="built_in">data</span>.number);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不用显式释放context的内存！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看过GCD（Grand Central Dispatch）的Apple<a href="https://developer.apple.com/library/prerelease/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html" target="_blank" rel="noopener">官方文档</a>的朋友一定见过“<strong>dispatch_set_context</strong>”和“<strong>dispatch_get_context</strong>”这两个函数，那么这两个函数该怎么用呢？</p><p>我们都知道，GCD的接口参数都是“C语言类型“的，那么，我们如何将NSObject类型（Foundation框架）的数据，传入GCD的接口呢？（即：Core Foundation和Foundation对象的转换）</p><h2 id="本文关键字"><a href="#本文关键字" class="headerlink" title="本文关键字"></a>本文关键字</h2><ul><li>GCD：dispatch_set_context，dispatch_get_context</li><li>__bridge，__bridge_retained，__bridge_transfer</li><li>Core Foundation, NSObject</li></ul><a id="more"></a><h2 id="dispatch-set-get-context"><a href="#dispatch-set-get-context" class="headerlink" title="dispatch_set(get)_context"></a>dispatch_set(get)_context</h2><p>先看看这两个函数的原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置context</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_set_context</span> <span class="params">(<span class="keyword">dispatch_object_t</span> object, <span class="keyword">void</span> *context)</span></span>;</span><br><span class="line"><span class="comment">//获取context</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">dispatch_get_context</span> <span class="params">(<span class="keyword">dispatch_object_t</span> object)</span></span>;</span><br></pre></td></tr></table></figure><p>这里的object一般指的就是通过dispatch_queue_create创建的队列。</p><p>所以，这两个函数分别完成了将context“绑定”到特定GCD队列和从GCD队列获取对应context的任务。</p><h3 id="什么是context"><a href="#什么是context" class="headerlink" title="什么是context"></a>什么是context</h3><p>在上述函数原型中，context是一个“<strong>void类型指针</strong>”，学过C语言的朋友应该都知道，void型指针可以指向任意类型，就是说，context在这里可以是任意类型的指针。</p><p>从这里可以得知，我们可以为队列“<strong>set</strong>”任意类型的数据，并在合适的时候取出来用。</p><h2 id="用malloc创建context并绑定到队列上"><a href="#用malloc创建context并绑定到队列上" class="headerlink" title="用malloc创建context并绑定到队列上"></a>用malloc创建context并绑定到队列上</h2><p>参考<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW13" target="_blank" rel="noopener">Apple官方的例子</a>，我们先用传统的<strong>malloc</strong>创建context，看看如下简短例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义context，即一个结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">&#125; Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义队列的finalizer函数，用于释放context内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanStaff</span><span class="params">(<span class="keyword">void</span> *context)</span> </span>&#123;</span><br><span class="line">    NSLog(@<span class="string">"In clean, context number: %d"</span>, ((Data *)context)-&gt;number);</span><br><span class="line">    <span class="comment">//释放，如果是new出来的对象，就要用delete</span></span><br><span class="line">    <span class="built_in">free</span>(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)runTest &#123;</span><br><span class="line">    <span class="comment">//创建队列</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"me.tutuge.test.gcd"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Data类型context数据并初始化</span></span><br><span class="line">    Data *myData = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Data));</span><br><span class="line">    myData-&gt;number = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定context</span></span><br><span class="line">    dispatch_set_context(<span class="built_in">queue</span>, myData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置finalizer函数，用于在队列执行完成后释放对应context内存</span></span><br><span class="line">    dispatch_set_finalizer_f(<span class="built_in">queue</span>, cleanStaff);</span><br><span class="line"></span><br><span class="line">    dispatch_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">        <span class="comment">//获取队列的context数据</span></span><br><span class="line">        Data *data = dispatch_get_context(<span class="built_in">queue</span>);</span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        NSLog(@<span class="string">"1: context number: %d"</span>, data-&gt;number);</span><br><span class="line">        <span class="comment">//修改context保存的数据</span></span><br><span class="line">        data-&gt;number = <span class="number">20</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码运行后如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2015<span class="selector-tag">-03-29</span> 20<span class="selector-pseudo">:28</span><span class="selector-pseudo">:16.854</span> <span class="selector-tag">GCDTest</span><span class="selector-attr">[37787:1443423]</span> 1: <span class="selector-tag">context</span> <span class="selector-tag">number</span>: 10</span><br><span class="line">2015<span class="selector-tag">-03-29</span> 20<span class="selector-pseudo">:28</span><span class="selector-pseudo">:16.855</span> <span class="selector-tag">GCDTest</span><span class="selector-attr">[37787:1443423]</span> <span class="selector-tag">In</span> <span class="selector-tag">clean</span>, <span class="selector-tag">context</span> <span class="selector-tag">number</span>: 20</span><br></pre></td></tr></table></figure><p>看，通过为队列设置context，我们就能为队列绑定自定义的数据，然后在合适的时候取出来用。</p><h2 id="NSObject类型的context"><a href="#NSObject类型的context" class="headerlink" title="NSObject类型的context"></a>NSObject类型的context</h2><p>在Mac、iOS的开发过程中，我们大部分用的都是Foundation框架下的类，就是如NSString、NSDictionary这些NSObject类型的类。  </p><p>但是上面的<strong>dispatch_set(get)_context</strong>接受的context参数是C语言类型的，即Core Foundation类型的，我们如何转换呢？</p><p><strong>由于ARC不能管理Core Foundation Object的生命周期</strong>，所以我们必须先转换context的“类型”，以便转换内存管理权。</p><h3 id="bridge"><a href="#bridge" class="headerlink" title="__bridge"></a>__bridge</h3><p>Apple已经为我们提供了用于转换的关键字，如下：</p><ul><li>__bridge: 只做了类型转换，不修改内存管理权；</li><li>__bridge_retained（即CFBridgingRetain）转换类型，同时将内存管理权从ARC中移除，后面需要使用CFRelease来释放对象；</li><li>__bridge_transfer（即CFBridgingRelease）将Core Foundation的对象转换为Objective-C的对象，同时将内存管理权交给ARC。</li></ul><h3 id="重新定义context"><a href="#重新定义context" class="headerlink" title="重新定义context"></a>重新定义context</h3><p>为了方便下面的说明，我们先定义context类。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">Data </span>: NSObject</span><br><span class="line"><span class="variable">@property</span>(assign, nonatomic) int number;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> Data</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承dealloc方法，便于观察对象何时被释放</span></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"Data dealloc..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><p>看，我们继承了<strong>dealloc</strong>方法，这样就能知道Data类型对象什么时候被释放。</p><h3 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h3><p><strong>__bridge</strong>的转换是没有转移内存管理权的，这点要特别注意。</p><p>如果在传context对象时，用的是<strong>__bridge</strong>转换，那么context对象的内存管理权还在ARC手里，一旦当前作用域执行完，context就会被释放，而如果队列的任务用了context对象，就会造成“<strong>EXC_BAD_ACCESS</strong>”崩溃！</p><h3 id="正确的用法"><a href="#正确的用法" class="headerlink" title="正确的用法"></a>正确的用法</h3><p>重写上面的例子，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义队列的finalizer函数，用于释放context内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanStaff</span><span class="params">(<span class="keyword">void</span> *context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里用__bridge转换，不改变内存管理权</span></span><br><span class="line">    Data *data = (__bridge Data *)(context);</span><br><span class="line">    NSLog(@<span class="string">"In clean, context number: %d"</span>, data.number);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放context的内存！</span></span><br><span class="line">    CFRelease(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testBody &#123;</span><br><span class="line">    <span class="comment">//创建队列</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"me.tutuge.test.gcd"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Data类型context数据并初始化</span></span><br><span class="line">    Data *myData = [Data <span class="keyword">new</span>];</span><br><span class="line">    myData.number = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定context</span></span><br><span class="line">    <span class="comment">//这里用__bridge_retained转换，将context的内存管理权从ARC移除，交由我们自己手动释放！</span></span><br><span class="line">    dispatch_set_context(<span class="built_in">queue</span>, (__bridge_retained <span class="keyword">void</span> *)(myData));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置finalizer函数，用于在队列执行完成后释放对应context内存</span></span><br><span class="line">    dispatch_set_finalizer_f(<span class="built_in">queue</span>, cleanStaff);</span><br><span class="line"></span><br><span class="line">    dispatch_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">        <span class="comment">//获取队列的context数据</span></span><br><span class="line">        <span class="comment">//这里用__bridge转换，不改变内存管理权</span></span><br><span class="line">        Data *data = (__bridge Data *)(dispatch_get_context(<span class="built_in">queue</span>));</span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        NSLog(@<span class="string">"1: context number: %d"</span>, data.number);</span><br><span class="line">        <span class="comment">//修改context保存的数据</span></span><br><span class="line">        data.number = <span class="number">20</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ul><li>在dispatch_set_context的时候用<strong>__bridge_retained</strong>转换，将context的内存管理权从ARC移除，交给我们自己管理。</li><li>在队列任务中，用dispatch_get_context获取context的时候，用<strong>__bridge</strong>转换，维持context的内存管理权不变，防止出了作用域context被释放。</li><li>最后用<strong>CFRelease</strong>释放context内存。</li></ul><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2015<span class="selector-tag">-03-29</span> 21<span class="selector-pseudo">:12</span><span class="selector-pseudo">:41.631</span> <span class="selector-tag">GCDTest</span><span class="selector-attr">[38131:1465900]</span> 1: <span class="selector-tag">context</span> <span class="selector-tag">number</span>: 10</span><br><span class="line">2015<span class="selector-tag">-03-29</span> 21<span class="selector-pseudo">:12</span><span class="selector-pseudo">:41.632</span> <span class="selector-tag">GCDTest</span><span class="selector-attr">[38131:1465900]</span> <span class="selector-tag">In</span> <span class="selector-tag">clean</span>, <span class="selector-tag">context</span> <span class="selector-tag">number</span>: 20</span><br><span class="line">2015<span class="selector-tag">-03-29</span> 21<span class="selector-pseudo">:12</span><span class="selector-pseudo">:41.632</span> <span class="selector-tag">GCDTest</span><span class="selector-attr">[38131:1465900]</span> <span class="selector-tag">Data</span> <span class="selector-tag">dealloc</span>...</span><br></pre></td></tr></table></figure><p>由结果可知，我们的context对象在最后显式调用<strong>CFRelease</strong>才被释放。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，就是合理运用__bridge_retained(transfer)关键字转换对象的内存管理权，让我们自己控制对象的生命周期。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.apple.com/library/prerelease/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html" target="_blank" rel="noopener">Grand Central Dispatch (GCD) Reference</a></li><li><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW13" target="_blank" rel="noopener">Concurrency Programming Guide</a></li><li><a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html" target="_blank" rel="noopener">Toll-Free Bridged Types</a></li><li><a href="http://blog.csdn.net/diyagoanyhacker/article/details/7573801" target="_blank" rel="noopener">Core Foundation 框架</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2015-5-28更新&quot;&gt;&lt;a href=&quot;#2015-5-28更新&quot; class=&quot;headerlink&quot; title=&quot;2015-5-28更新&quot;&gt;&lt;/a&gt;2015-5-28更新&lt;/h2&gt;&lt;p&gt;下面评论的好友“@Jim”给了种新的思路，就是在清除context的函数里面，用“&lt;strong&gt;_bridge_transfer&lt;/strong&gt;”转换context，把context的内存管理权限重新交给ARC，这样，就不用显式调用“&lt;strong&gt;CFRelease&lt;/strong&gt;”了。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight lasso&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;void&lt;/span&gt; cleanStaff(&lt;span class=&quot;literal&quot;&gt;void&lt;/span&gt; *context) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//这里用_bridge_transfer转换，将内存管理权限交还给ARC&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; *&lt;span class=&quot;built_in&quot;&gt;data&lt;/span&gt; = (_bridge_transfer &lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; *)(context);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;In clean, context number: %d&quot;&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;data&lt;/span&gt;.number);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//不用显式释放context的内存！&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;看过GCD（Grand Central Dispatch）的Apple&lt;a href=&quot;https://developer.apple.com/library/prerelease/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;的朋友一定见过“&lt;strong&gt;dispatch_set_context&lt;/strong&gt;”和“&lt;strong&gt;dispatch_get_context&lt;/strong&gt;”这两个函数，那么这两个函数该怎么用呢？&lt;/p&gt;
&lt;p&gt;我们都知道，GCD的接口参数都是“C语言类型“的，那么，我们如何将NSObject类型（Foundation框架）的数据，传入GCD的接口呢？（即：Core Foundation和Foundation对象的转换）&lt;/p&gt;
&lt;h2 id=&quot;本文关键字&quot;&gt;&lt;a href=&quot;#本文关键字&quot; class=&quot;headerlink&quot; title=&quot;本文关键字&quot;&gt;&lt;/a&gt;本文关键字&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;GCD：dispatch_set_context，dispatch_get_context&lt;/li&gt;
&lt;li&gt;__bridge，__bridge_retained，__bridge_transfer&lt;/li&gt;
&lt;li&gt;Core Foundation, NSObject&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5</title>
    <link href="http://tutuge.me/2015/03/21/effective-objective-c-5-enum/"/>
    <id>http://tutuge.me/2015/03/21/effective-objective-c-5-enum/</id>
    <published>2015-03-21T12:52:57.000Z</published>
    <updated>2018-10-07T17:37:28.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Enum，也就是枚举，从C语言开始就有了，C++、Java、Objective-C、Swift这些语言，当然都有对应的枚举类型，功能可能有多有少，但是最核心的还是一个—规范的定义代码中的状态、选项等“常量”。</p><h2 id="Item-5-Use-Enumerations-for-States-Options-and-Status-Codes"><a href="#Item-5-Use-Enumerations-for-States-Options-and-Status-Codes" class="headerlink" title="Item 5 - Use Enumerations for States, Options, and Status Codes"></a>Item 5 - Use Enumerations for States, Options, and Status Codes</h2><p>本节的内容就是如何正确的使用枚举。</p><h2 id="状态与选项的区别（states-and-options）"><a href="#状态与选项的区别（states-and-options）" class="headerlink" title="状态与选项的区别（states and options）"></a>状态与选项的区别（states and options）</h2><p>在用<strong>enum</strong>之前，我个人觉得，区分一下状态和选项的概念还是很必要的。</p><p><strong>状态</strong>，同时只能有一种，如“<strong>OK</strong>”，“<strong>Error</strong>”，不可能同时是OK和Error。<br><strong>选项</strong>，同时可以有一种或一种以上，如App可以<strong>同时</strong>支持横屏和竖屏，横屏竖屏在这个时候就是“屏幕方向”的两种不同的选项。</p><p>接下来，我们看看如何用枚举定义状态和选项。</p><a id="more"></a><h2 id="enum与状态（states）"><a href="#enum与状态（states）" class="headerlink" title="enum与状态（states）"></a>enum与状态（states）</h2><h4 id="不好的做法"><a href="#不好的做法" class="headerlink" title="不好的做法"></a>不好的做法</h4><p>经常看到这样的写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATE_OK 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATE_ERROR 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATE_UNKNOW 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接用int型变量接收</span></span><br><span class="line"><span class="keyword">int</span> STATE = STATE_UNKNOW;</span><br></pre></td></tr></table></figure><p>这样做有如下“不恰当”：</p><ul><li>宏定义没有类型约束，只是单纯的替换。</li><li>无法限制状态的所有情况，如，认为的将STATE赋值成3，程序可能就会出错，找不到匹配的状态，因为编译器不会对“<strong>STATE = 3;</strong>”提出警告。</li></ul><h4 id="正确的做法"><a href="#正确的做法" class="headerlink" title="正确的做法"></a>正确的做法</h4><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">enum</span> <span class="title">_TTGState</span> &#123;</span></span><br><span class="line">    TTGStateOK  = <span class="number">0</span>,</span><br><span class="line">    TTGStateError,</span><br><span class="line">    TTGStateUnknow</span><br><span class="line">&#125; TTGState;</span><br><span class="line"></span><br><span class="line">/<span class="regexp">/指明枚举类型</span></span><br><span class="line"><span class="regexp">TTGState state = TTGStateOK;</span></span><br></pre></td></tr></table></figure><p>用的时候就如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">dealWithState:</span>(TTGState)state &#123;</span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">TTGStateOK:</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">TTGStateError:</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">TTGStateUnknow:</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="enum与选项-options"><a href="#enum与选项-options" class="headerlink" title="enum与选项 (options)"></a>enum与选项 (options)</h2><p>选项，就是说一个“选项变量”的类型要能够同时表示一个或多个组合的选择，如下例子：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方向，可同时支持一个或多个方向</span></span><br><span class="line">typedef enum _TTGDirection &#123;</span><br><span class="line">    TTGDirectionNone = <span class="number">0</span>,</span><br><span class="line">    TTGDirectionTop = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    TTGDirectionLeft = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    TTGDirectionRight = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">    TTGDirectionBottom = <span class="number">1</span> &lt;&lt; <span class="number">3</span></span><br><span class="line">&#125; TTGDirection;</span><br></pre></td></tr></table></figure><p>看，这里的选项是用<strong>位运算</strong>的方式定义的，这样的好处就是，我们的选项变量可以如下表示：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用“或”运算同时赋值多个选项</span></span><br><span class="line">TTGDirection <span class="built_in">direction</span> = TTGDirectionTop | TTGDirectionLeft | TTGDirectionBottom;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用“与”运算取出对应位</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">direction</span> &amp; TTGDirectionTop) &#123;</span><br><span class="line">    NSLog(@<span class="string">"top"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">direction</span> &amp; TTGDirectionLeft) &#123;</span><br><span class="line">    NSLog(@<span class="string">"left"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">direction</span> &amp; TTGDirectionRight) &#123;</span><br><span class="line">    NSLog(@<span class="string">"right"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">direction</span> &amp; TTGDirectionBottom) &#123;</span><br><span class="line">    NSLog(@<span class="string">"bottom"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>direction</strong>变量的实际内存如下：</p><p><img src="/2015/03/21/effective-objective-c-5-enum/blog_effective_objective_c_5_enum_2.jpg" alt="内存示意图"></p><p>这样，用位运算，就可以同时支持多个值。</p><h2 id="enum在Objective-C中的“升级版”"><a href="#enum在Objective-C中的“升级版”" class="headerlink" title="enum在Objective-C中的“升级版”"></a>enum在Objective-C中的“升级版”</h2><p>一般来说，我们不能指定枚举变量的实际类型是什么，就是说，我们不知道枚举最后是int型，还是其他的什么类型。但是从C++ 11开始，我们可以为枚举指定其实际的存储类型，如下语法：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TTGState</span> : <span class="title">NSInteger</span> &#123;/*...*/&#125;;</span></span><br></pre></td></tr></table></figure><p>但是，我们在定义枚举的时候如何保证兼容性呢？Foundation框架已经为我们提供了更加“统一、便捷”的枚举定义方法，我们重新定义上面的例子：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//<span class="type">NS_ENUM</span>，定义状态等普通枚举</span><br><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSUInteger</span>, <span class="type">TTGState</span>) &#123;</span><br><span class="line">    <span class="type">TTGStateOK</span> = 0,</span><br><span class="line">    <span class="type">TTGStateError</span>,</span><br><span class="line">    <span class="type">TTGStateUnknow</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//<span class="type">NS_OPTIONS</span>，定义选项</span><br><span class="line">typedef <span class="type">NS_OPTIONS</span>(<span class="type">NSUInteger</span>, <span class="type">TTGDirection</span>) &#123;</span><br><span class="line">    <span class="type">TTGDirectionNone</span> = 0,</span><br><span class="line">    <span class="type">TTGDirectionTop</span> = 1 &lt;&lt; 0,</span><br><span class="line">    <span class="type">TTGDirectionLeft</span> = 1 &lt;&lt; 1,</span><br><span class="line">    <span class="type">TTGDirectionRight</span> = 1 &lt;&lt; 2,</span><br><span class="line">    <span class="type">TTGDirectionBottom</span> = 1 &lt;&lt; 3</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以，在开发Mac、iOS程序中，最好所有的枚举都用“<strong>NS_ENUM</strong>”和“<strong>NS_OPTIONS</strong>”定义，保证统一。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>充分的用好枚举，可以增强代码的可读性，减少各种“错误”，让代码更加的规范。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Enum，也就是枚举，从C语言开始就有了，C++、Java、Objective-C、Swift这些语言，当然都有对应的枚举类型，功能可能有多有少，但是最核心的还是一个—规范的定义代码中的状态、选项等“常量”。&lt;/p&gt;
&lt;h2 id=&quot;Item-5-Use-Enumerations-for-States-Options-and-Status-Codes&quot;&gt;&lt;a href=&quot;#Item-5-Use-Enumerations-for-States-Options-and-Status-Codes&quot; class=&quot;headerlink&quot; title=&quot;Item 5 - Use Enumerations for States, Options, and Status Codes&quot;&gt;&lt;/a&gt;Item 5 - Use Enumerations for States, Options, and Status Codes&lt;/h2&gt;&lt;p&gt;本节的内容就是如何正确的使用枚举。&lt;/p&gt;
&lt;h2 id=&quot;状态与选项的区别（states-and-options）&quot;&gt;&lt;a href=&quot;#状态与选项的区别（states-and-options）&quot; class=&quot;headerlink&quot; title=&quot;状态与选项的区别（states and options）&quot;&gt;&lt;/a&gt;状态与选项的区别（states and options）&lt;/h2&gt;&lt;p&gt;在用&lt;strong&gt;enum&lt;/strong&gt;之前，我个人觉得，区分一下状态和选项的概念还是很必要的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;状态&lt;/strong&gt;，同时只能有一种，如“&lt;strong&gt;OK&lt;/strong&gt;”，“&lt;strong&gt;Error&lt;/strong&gt;”，不可能同时是OK和Error。&lt;br&gt;&lt;strong&gt;选项&lt;/strong&gt;，同时可以有一种或一种以上，如App可以&lt;strong&gt;同时&lt;/strong&gt;支持横屏和竖屏，横屏竖屏在这个时候就是“屏幕方向”的两种不同的选项。&lt;/p&gt;
&lt;p&gt;接下来，我们看看如何用枚举定义状态和选项。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>@autoreleasepool-内存的分配与释放</title>
    <link href="http://tutuge.me/2015/03/17/what-is-autoreleasepool/"/>
    <id>http://tutuge.me/2015/03/17/what-is-autoreleasepool/</id>
    <published>2015-03-17T12:21:56.000Z</published>
    <updated>2018-10-07T17:37:29.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开发过iOS、Mac的朋友应该对“<strong>@autoreleasepool</strong>”不陌生。只要在Xcode里创建一个工程，就能看到下面这样的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iOS program</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Command line program</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看，每个<strong>main</strong>函数的主体都被<strong>@autoreleasepool</strong>的Block块包在里面，也就是说，接下来所有的对象创建都在这个block里面。</p><p>那么，<strong>@autoreleasepool</strong>的作用到底是什么呢？我们开发中可以用它来做什么呢？</p><p>可以在某些情况下，大幅度降低程序的内存占用，如下图:</p><p><img src="https://camo.githubusercontent.com/2c1f07459d33c72de07d8a9305703b2ba40abfc4/687474703a2f2f7a6f72726f6368656e2e71696e6975646e2e636f6d2f626c6f675f776861745f69735f6175746f72656c65617365706f6f6c5f312e706e673f696d61676556696577322f302f682f343030" alt="autoreleasepool测试内存占用图"></p><ul><li>测试的内容：500000次循环，每次循环创建一个NSNumber实例和两个NSString实例。</li><li>图：红线表示没有用<strong>@autoreleasepool</strong>时的内存占用。</li><li>图：绿线表示用了<strong>@autoreleasepool</strong>优化后的内存占用！</li></ul><p>效果是不是很明显！</p><p>代码Github地址：<a href="https://github.com/zekunyan/AutoReleasePoolTestExample" target="_blank" rel="noopener">AutoReleasePoolTestExample</a> Xcode 6, iOS 8, iPhone 5模拟器.</p><a id="more"></a><h2 id="MRC-与-ARC"><a href="#MRC-与-ARC" class="headerlink" title="MRC 与 ARC"></a>MRC 与 ARC</h2><p>MRC（Mannul Reference Counting）和ARC(Automatic Reference Counting)，分别对应着手动引用计数和自动引用计数。</p><p>对！是计数，不是“<strong>GC、垃圾回收</strong>”什么的，就是说，在Objective-C的开发中，ARC不代表像Java那样有GC做垃圾回收，所以本质上还是要“手动”管理内存的。也就是说，我们在ARC环境下写的代码，不用自己手动插入“<strong>retain、release这些消息</strong>”，ARC会在编译时为我们在合适的位置插入，释放不必要的内存。</p><p>而<strong>@autoreleasepool</strong>就跟对象的<strong>release</strong>密切相关。</p><h2 id="autoreleasepool-干了啥"><a href="#autoreleasepool-干了啥" class="headerlink" title="@autoreleasepool 干了啥"></a>@autoreleasepool 干了啥</h2><p>在MRC时代，如果我们想先retain一个对象，但是并不知道在什么时候可以release它，我们可以像下面这么做：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">NSAutoreleasePool</span> *pool = [[<span class="symbol">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="symbol">NSString</span>* str = [[[<span class="symbol">NSString</span> alloc] initWithString:@<span class="string">"tutuge"</span>] autorelease];</span><br><span class="line">//use str...</span><br><span class="line"></span><br><span class="line">[pool release];</span><br><span class="line">//str is released</span><br></pre></td></tr></table></figure><p>就是说，我们可以在创建对象的时候给对象发送“<strong>autorelease</strong>”消息，然后当<strong>NSAutoreleasePool</strong>结束的时候，“标记过”autorelease的对象都会被“<strong>release</strong>”掉，也就是会被释放掉。</p><p>但是在ARC时代，我们不用手动发送<strong>autorelease</strong>消息，ARC会自动帮我们加。而这个时候，<strong>@autoreleasepool</strong>做的事情，跟<strong>NSAutoreleasePool</strong>就一模一样了。</p><h2 id="什么时候用-autoreleasepool"><a href="#什么时候用-autoreleasepool" class="headerlink" title="什么时候用@autoreleasepool"></a>什么时候用@autoreleasepool</h2><p>根据<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html" target="_blank" rel="noopener">Apple的文档</a>，使用场景如下：</p><ul><li>写基于命令行的的程序时，就是没有UI框架，如AppKit等Cocoa框架时。</li><li>写循环，循环里面包含了大量临时创建的对象。（本文的例子）</li><li>创建了新的线程。（非Cocoa程序创建线程时才需要）</li><li>长时间在后台运行的任务。</li></ul><h2 id="利用-autoreleasepool优化循环"><a href="#利用-autoreleasepool优化循环" class="headerlink" title="利用@autoreleasepool优化循环"></a>利用@autoreleasepool优化循环</h2><p>利用@autoreleasepool优化循环的内存占用，我觉得最有用的一点，下面就说说这个点。<br>如下面的循环，次数非常多，而且循环体里面的对象都是临时创建使用的，就可以用<strong>@autoreleasepool</strong>包起来，让每次循环结束时，可以及时的释放临时对象的内存。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来自Apple文档，见参考</span></span><br><span class="line"><span class="built_in">NSArray</span> *urls = &lt;<span class="meta"># An array of file URLs #&gt;;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSURL</span> *url <span class="keyword">in</span> urls) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSError</span> *error;</span><br><span class="line">        <span class="built_in">NSString</span> *fileContents = [<span class="built_in">NSString</span> stringWithContentsOfURL:url</span><br><span class="line">                                        encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line">        <span class="comment">/* Process the string, creating and autoreleasing more objects. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么做的效果是极其显著地，就如本文最开始的图一样，可以自己把示例工程下回来运行下试试~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>@autoreleasepool</strong>看起来很不“起眼”，平常开发很容易就忽略它了，但是仔细一看，确如此有用~</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html" target="_blank" rel="noopener">Using Autorelease Pool Blocks</a></li><li><a href="http://stackoverflow.com/questions/14677049/what-is-autoreleasepool-objective-c" target="_blank" rel="noopener">What is autoreleasepool? - Objective-C</a></li><li><a href="http://stackoverflow.com/questions/9086913/objective-c-why-is-autorelease-autoreleasepool-still-needed-with-arc" target="_blank" rel="noopener">Objective-C: Why is autorelease (@autoreleasepool) still needed with ARC?</a></li><li><a href="http://blog.zilongshanren.com/blog/2013/12/20/what-is-autorelease-pool/" target="_blank" rel="noopener">What-is-autorelease-pool?</a></li><li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html" target="_blank" rel="noopener">NSAutoreleasePool</a></li></ul><h3 id="示例中的第三方库"><a href="#示例中的第三方库" class="headerlink" title="示例中的第三方库"></a>示例中的第三方库</h3><p><a href="https://github.com/kevinzhow/PNChart" target="_blank" rel="noopener">PNChart</a></p><h3 id="运行中用代码获取App运行消耗内存"><a href="#运行中用代码获取App运行消耗内存" class="headerlink" title="运行中用代码获取App运行消耗内存"></a>运行中用代码获取App运行消耗内存</h3><p><a href="http://stackoverflow.com/questions/787160/programmatically-retrieve-memory-usage-on-iphone" target="_blank" rel="noopener">Programmatically retrieve memory usage on iPhone</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;开发过iOS、Mac的朋友应该对“&lt;strong&gt;@autoreleasepool&lt;/strong&gt;”不陌生。只要在Xcode里创建一个工程，就能看到下面这样的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//iOS program&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; main(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * argv[]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;@autoreleasepool&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;UIApplicationMain&lt;/span&gt;(argc, argv, &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;NSStringFromClass&lt;/span&gt;([AppDelegate &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;]));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Command line program&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; main(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *argv[]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;@autoreleasepool&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;看，每个&lt;strong&gt;main&lt;/strong&gt;函数的主体都被&lt;strong&gt;@autoreleasepool&lt;/strong&gt;的Block块包在里面，也就是说，接下来所有的对象创建都在这个block里面。&lt;/p&gt;
&lt;p&gt;那么，&lt;strong&gt;@autoreleasepool&lt;/strong&gt;的作用到底是什么呢？我们开发中可以用它来做什么呢？&lt;/p&gt;
&lt;p&gt;可以在某些情况下，大幅度降低程序的内存占用，如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/2c1f07459d33c72de07d8a9305703b2ba40abfc4/687474703a2f2f7a6f72726f6368656e2e71696e6975646e2e636f6d2f626c6f675f776861745f69735f6175746f72656c65617365706f6f6c5f312e706e673f696d61676556696577322f302f682f343030&quot; alt=&quot;autoreleasepool测试内存占用图&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试的内容：500000次循环，每次循环创建一个NSNumber实例和两个NSString实例。&lt;/li&gt;
&lt;li&gt;图：红线表示没有用&lt;strong&gt;@autoreleasepool&lt;/strong&gt;时的内存占用。&lt;/li&gt;
&lt;li&gt;图：绿线表示用了&lt;strong&gt;@autoreleasepool&lt;/strong&gt;优化后的内存占用！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;效果是不是很明显！&lt;/p&gt;
&lt;p&gt;代码Github地址：&lt;a href=&quot;https://github.com/zekunyan/AutoReleasePoolTestExample&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AutoReleasePoolTestExample&lt;/a&gt; Xcode 6, iOS 8, iPhone 5模拟器.&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>有关宏定义的经验与技巧-简化代码-增强Log</title>
    <link href="http://tutuge.me/2015/03/15/%E6%9C%89%E5%85%B3%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E7%BB%8F%E9%AA%8C%E4%B8%8E%E6%8A%80%E5%B7%A7-%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81-%E5%A2%9E%E5%BC%BALog/"/>
    <id>http://tutuge.me/2015/03/15/有关宏定义的经验与技巧-简化代码-增强Log/</id>
    <published>2015-03-15T07:34:28.000Z</published>
    <updated>2018-10-07T17:37:29.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>宏定义、#define啥的，我们经常遇到。<br>一般来说，最常用的可能就是定义一些常量、简单的“函数”，如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span>定义常量PI</span><br><span class="line"><span class="comment">#define PI 3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>定义“函数”MIN</span><br><span class="line"><span class="comment">#define MIN(A,B) ((A) &lt; (B) ? (A) : (B))</span></span><br></pre></td></tr></table></figure><p>但是，这样定义常量、函数，有一定的风险。（见：<a href="http://tutuge.me/2015/03/11/Effective-Objective-C-读书笔记-Item-4-如何正确定义常量/">Effective-Objective-C-读书笔记-Item-4-如何正确定义常量</a>, <a href="http://onevcat.com/2014/01/black-magic-in-macro/" target="_blank" rel="noopener">宏定义的黑魔法 - 宏菜鸟起飞手册</a>）</p><p>本文就列出几条我个人在iOS开发当中常用的经验与技巧。</p><a id="more"></a><h2 id="简化代码"><a href="#简化代码" class="headerlink" title="简化代码"></a>简化代码</h2><p>在开发当中，我们可能会大量的写一些重复的，甚至具有“危险”的代码，用宏定义#define，往往可以简化代码，看看下面几个例子。</p><h3 id="GCD与-define"><a href="#GCD与-define" class="headerlink" title="GCD与#define"></a>GCD与#define</h3><p><strong>dispatch_once</strong><br>项目中往往少不了各种单例类，我们一般会如下定义：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype)sharedService </span>&#123;</span><br><span class="line">    static XXX *<span class="keyword">sharedService </span>= nil<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    static <span class="keyword">dispatch_once_t </span>onceToken<span class="comment">;</span></span><br><span class="line">    <span class="keyword">dispatch_once, </span>^&#123;</span><br><span class="line">        <span class="keyword">sharedService </span>= [XXX new]<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    return <span class="keyword">sharedService;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p>这时候，就要注意几点：</p><ul><li>dispatch_once_t必须是<strong>static</strong>的，否则会各种报错=。=。</li><li><strong>dispatch_once</strong>的第一个参数必须取onceToken的地址，就是要“<strong>&amp;onceToken</strong>。”</li></ul><p>看，写个小小的单例都要这么注意，错了一点都很危险啊，而且总要重复写这几行。所以这个时候需要让宏定义帮忙：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_ONCE_BLOCK(onceBlock) static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, onceBlock);</span></span><br><span class="line"></span><br><span class="line">+ (instancetype)sharedService &#123;</span><br><span class="line">    <span class="keyword">static</span> XXX *sharedService = nil;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接一行搞定</span></span><br><span class="line">    DISPATCH_ONCE_BLOCK(^&#123;</span><br><span class="line">        sharedService = [XXX <span class="keyword">new</span>];</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sharedService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看，是不是变得更加简洁、“安全了”~</p><p><strong>dispatch_async</strong><br>除了dispatch_once，另一个常用的就是dispatch_async。不多说，直接看例子：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Main线程上运行</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">DISPATCH_ON_MAIN_THREAD</span>(mainQueueBlock) <span class="selector-tag">dispatch_async</span>(dispatch_get_main_queue(), mainQueueBlock);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Global Queue上运行</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">DISPATCH_ON_GLOBAL_QUEUE_HIGH</span>(globalQueueBlocl) <span class="selector-tag">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), globalQueueBlocl);</span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">DISPATCH_ON_GLOBAL_QUEUE_DEFAULT</span>(globalQueueBlocl) <span class="selector-tag">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), globalQueueBlocl);</span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">DISPATCH_ON_GLOBAL_QUEUE_LOW</span>(globalQueueBlocl) <span class="selector-tag">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>), globalQueueBlocl);</span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">DISPATCH_ON_GLOBAL_QUEUE_BACKGROUND</span>(globalQueueBlocl) <span class="selector-tag">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>), globalQueueBlocl);</span><br><span class="line"></span><br><span class="line"><span class="comment">//主线程上</span></span><br><span class="line"><span class="selector-tag">DISPATCH_ON_MAIN_THREAD</span>(^&#123;</span><br><span class="line">    <span class="comment">//更新UI</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Global Queue</span></span><br><span class="line"><span class="selector-tag">DISPATCH_ON_GLOBAL_QUEUE_DEFAULT</span>(^&#123;</span><br><span class="line">    <span class="comment">//异步耗时任务</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>再也不用写一大堆”dispatch_async(dispatch_get_global_queue”了~看起来是不是很清爽~</p><h3 id="能一行搞定，干嘛还要写多行"><a href="#能一行搞定，干嘛还要写多行" class="headerlink" title="能一行搞定，干嘛还要写多行"></a>能一行搞定，干嘛还要写多行</h3><p>很多时候，我们写的函数、方法都会在起始的地方加一些公共的判断，条件满足了才可以继续往下运行，如“用户是否登录”、“某个模块是否加载完成”等等，所以，我们可能会写如下样子的代码：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doSomething &#123;</span><br><span class="line">    <span class="keyword">if</span> (![[XXXAccountService sharedService] isLogin]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//do staff...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doSomething2 &#123;</span><br><span class="line">    <span class="keyword">if</span> (![[XXXAccountService sharedService] isLogin]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//do staff...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次都要这么写，是不是感觉很浪费时间？而且重复的好多=。=<br>所以，我们要用#define，把3行变成一行:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_LOGIN_IN <span class="meta-keyword">if</span> (![[XXXAccountService sharedService] isLogin]) &#123;return;&#125;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doSomething &#123;</span><br><span class="line">    CHECK_LOGIN_IN</span><br><span class="line">    <span class="comment">//do staff...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doSomething2 &#123;</span><br><span class="line">    CHECK_LOGIN_IN</span><br><span class="line">    <span class="comment">//do staff...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实#define的原理就是不管三七二十一，直接做替换，所以我们完全可以利用这个特点，发挥自己的想象，简化代码~</p><h2 id="宏定义与Log"><a href="#宏定义与Log" class="headerlink" title="宏定义与Log"></a>宏定义与Log</h2><p>打Log，是个永恒的话题。</p><h3 id="NSLog增强版"><a href="#NSLog增强版" class="headerlink" title="NSLog增强版"></a>NSLog增强版</h3><p>我们会经常用到<strong>NSLog</strong>打Log，但是，这个函数能提供的信息非常少，所以，下面就是一个增强版, 最好定义在项目的pch文件中：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define NSLog(format, ...) \</span></span><br><span class="line">    <span class="keyword">do</span> &#123; <span class="string">\</span></span><br><span class="line">        NSLog(@<span class="string">"&lt;%@ : %d : %s&gt;-: %@"</span>, <span class="string">\</span></span><br><span class="line">        [[NSString stringWithUTF8String:__FILE__] lastPathComponent], <span class="string">\</span></span><br><span class="line">        __LINE__, <span class="string">\</span></span><br><span class="line">        __FUNCTION__, <span class="string">\</span></span><br><span class="line">        [NSString stringWithFormat:format, <span class="comment">##__VA_ARGS__]); \</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        NSLog(@<span class="string">"Blog: %@"</span>, @<span class="string">"http://tutuge.me"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;main.<span class="string">m :</span> <span class="number">22</span> : main&gt;-: <span class="string">Blog:</span> <span class="string">http:</span><span class="comment">//tutuge.me</span></span><br></pre></td></tr></table></figure><p>看，这下Log就带上了文件名、行号、函数名，一下子就清楚多了~<br>至于为什么要用这个奇怪的“do{…}while(0)”，其实就是为了防止在不同的使用场景中导致语法错误，详细请见：<a href="http://onevcat.com/2014/01/black-magic-in-macro/" target="_blank" rel="noopener">宏定义的黑魔法 - 宏菜鸟起飞手册</a></p><h3 id="为Log增加全局开关"><a href="#为Log增加全局开关" class="headerlink" title="为Log增加全局开关"></a>为Log增加全局开关</h3><p>开发中，我们往往会在许多地方加上Log，但是在发布的时候，又不想显示这些Log，这个时候难道要一个一个的删除打Log的地方？<br>所以，为了增加开关，我们需要将上面的增强型NSLog改造一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否要Log</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NEED_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSLog(format, ...) \</span></span><br><span class="line">    <span class="comment">//Log定义...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> NSLog(format, ...) do&#123; &#125; while(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>所以，当我们需要Log的时候，在上面定义的之前加上下面这一行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEED_DEBUG</span></span><br></pre></td></tr></table></figure><p>就可以打开Log了。不加的话，就不会有Log~简单的条件编译~</p><h3 id="为Log增加等级"><a href="#为Log增加等级" class="headerlink" title="为Log增加等级"></a>为Log增加等级</h3><p>开发过Android的应该都知道，Android里面可以很方便的用Log.i、Log.d输出不同“等级”的Log，调试更加方便，NSLog却不行。所以，还是要借助宏定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Debug等级Log, 在此之前定义自己的NSLog</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOG_LEVEL_DEBUG</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> DLog(format, ...) NSLog(@<span class="meta-string">"&lt;DEBUG&gt;: %@"</span>, [NSString stringWithFormat:format, ##__VA_ARGS__])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> DLog(format, ...) do&#123; &#125; while(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Info等级Log</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOG_LEVEL_INFO</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ILog(format, ...) NSLog(@<span class="meta-string">"&lt;Info&gt;: %@"</span>, [NSString stringWithFormat:format, ##__VA_ARGS__])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ILog(format, ...) do&#123; &#125; while(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Error等级Log</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOG_LEVEL_ERROR</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ELog(format, ...) NSLog(@<span class="meta-string">"&lt;Error&gt;: %@"</span>, [NSString stringWithFormat:format, ##__VA_ARGS__])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ELog(format, ...) do&#123; &#125; while(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>当我们在打Log的时候，就可以根据需要，用不同等级的Log，而且可以方便的定制需要输出哪几种，并且之前的“增强版”NSLog也可以使用。</p><p>完整的请看<a href="https://gist.github.com/zekunyan/2f2356136b9b40348584" target="_blank" rel="noopener">Gist</a>.</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>还有一些简单好用的宏定义，在这就只举几个典型的例子了~</p><h3 id="打印自定义类型信息"><a href="#打印自定义类型信息" class="headerlink" title="打印自定义类型信息"></a>打印自定义类型信息</h3><p>假如有如下结构体定义(自定义类的话，直接重写description方法即可):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复数结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> r; <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">float</span> i; <span class="comment">//虚部</span></span><br><span class="line">&#125; Complex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义打印Complex类型的宏</span></span><br><span class="line"><span class="comment">//输出：(1+2i), (1-2i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSLogComplex(complex) NSLog(@<span class="meta-string">"Complex: (%g%s%gi)"</span>, complex.r, (complex.i &gt; 0 ? <span class="meta-string">"+"</span> : <span class="meta-string">""</span>), complex.i)</span></span><br></pre></td></tr></table></figure><h3 id="常用函数简化、单例获取"><a href="#常用函数简化、单例获取" class="headerlink" title="常用函数简化、单例获取"></a>常用函数简化、单例获取</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取View的属性</span></span><br><span class="line"><span class="number">#def</span>ine GetViewWidth(view)  view<span class="selector-class">.frame</span><span class="selector-class">.size</span><span class="selector-class">.width</span></span><br><span class="line"><span class="number">#def</span>ine GetViewHeight(view) view<span class="selector-class">.frame</span><span class="selector-class">.size</span><span class="selector-class">.height</span></span><br><span class="line"><span class="number">#def</span>ine GetViewX(view)      view<span class="selector-class">.frame</span><span class="selector-class">.origin</span><span class="selector-class">.x</span></span><br><span class="line"><span class="number">#def</span>ine GetViewY(view)      view<span class="selector-class">.frame</span><span class="selector-class">.origin</span><span class="selector-class">.y</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//屏幕常量</span></span><br><span class="line"><span class="number">#def</span>ine GetScreenWidth      [[UIScreen mainScreen] bounds]<span class="selector-class">.size</span><span class="selector-class">.width</span></span><br><span class="line"><span class="number">#def</span>ine GetScreenHeight     [[UIScreen mainScreen] bounds]<span class="selector-class">.size</span><span class="selector-class">.height</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取图片资源</span></span><br><span class="line"><span class="number">#def</span>ine GetImage(imageName) [UIImage imageNamed:[NSString stringWithFormat:@<span class="string">"%@"</span>,imageName]]</span><br><span class="line"></span><br><span class="line"><span class="comment">//等等~只要你想得到~</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>宏定义的各种Tip还远远不止这些，合理使用它，可以有效改善代码的阅读质量~</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://gcc.gnu.org/onlinedocs/cpp/index.html" target="_blank" rel="noopener">The C Preprocessor</a></li><li><a href="http://onevcat.com/2014/01/black-magic-in-macro/" target="_blank" rel="noopener">宏定义的黑魔法 - 宏菜鸟起飞手册</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;宏定义、#define啥的，我们经常遇到。&lt;br&gt;一般来说，最常用的可能就是定义一些常量、简单的“函数”，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight awk&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;定义常量PI&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#define PI 3.1415926&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;定义“函数”MIN&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#define MIN(A,B) ((A) &amp;lt; (B) ? (A) : (B))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是，这样定义常量、函数，有一定的风险。（见：&lt;a href=&quot;http://tutuge.me/2015/03/11/Effective-Objective-C-读书笔记-Item-4-如何正确定义常量/&quot;&gt;Effective-Objective-C-读书笔记-Item-4-如何正确定义常量&lt;/a&gt;, &lt;a href=&quot;http://onevcat.com/2014/01/black-magic-in-macro/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;宏定义的黑魔法 - 宏菜鸟起飞手册&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;本文就列出几条我个人在iOS开发当中常用的经验与技巧。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="技巧" scheme="http://tutuge.me/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Effective-Objective-C-读书笔记-Item-4-如何正确定义常量</title>
    <link href="http://tutuge.me/2015/03/11/Effective-Objective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Item-4-%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F/"/>
    <id>http://tutuge.me/2015/03/11/Effective-Objective-C-读书笔记-Item-4-如何正确定义常量/</id>
    <published>2015-03-10T16:07:23.000Z</published>
    <updated>2018-10-07T17:37:28.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写博客果然比光看书要花时间=。=，书都快看完了，才写到第4节。但是总结一遍，的确印象深刻啊~~</p><p>这次的主题是“<strong>常量</strong>”，非常常用，又非常重要的东西~良好的代码规范、设计，少不了各种<strong>常量</strong>。</p><h2 id="Item-4-Prefer-Typed-Constants-to-Preprocessor-define"><a href="#Item-4-Prefer-Typed-Constants-to-Preprocessor-define" class="headerlink" title="Item 4 - Prefer Typed Constants to Preprocessor #define"></a>Item 4 - Prefer Typed Constants to Preprocessor #define</h2><p>本节着重对比了常量的定义形式，类型常量和#define的区别、各自的特点。最后得出，我们应该用带有类型的常量，而不是#define。</p><a id="more"></a><h2 id="一个简单的示例"><a href="#一个简单的示例" class="headerlink" title="一个简单的示例"></a>一个简单的示例</h2><p>应用中，少不了各种动画，也就少不了设定动画的时间长度，一般来说，我们会设定短、中、长几种时间常量，用于不同的场合，了解C语言的童鞋估计对“<strong>#define</strong>”宏定义不陌生，于是，可能就会如下这么定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANIMATION_DURATION_SHORT 0.3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANIMATION_DURATION_MIDDLE 0.6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANIMATION_DURATION_LONG 1.0</span></span><br></pre></td></tr></table></figure><p>于是，所有用到动画时长的地方，直接用这几个宏定义就行了。</p><p>乍一看，似乎没什么问题。</p><h3 id="类型-不可变"><a href="#类型-不可变" class="headerlink" title="类型+不可变"></a>类型+不可变</h3><p>先来看看宏定义干了什么。<br>总的来说，#define就是“替换”，在编译时，将一切宏定义替换成定义后面的内容。（参考<a href="http://baike.baidu.com/view/2076445.htm" target="_blank" rel="noopener">百度百科</a>）</p><p>关键在于：</p><ul><li>宏定义不会检查替换的“<strong>类型</strong>”，只要遇到，就做替换。</li><li>宏定义不保证“<strong>不可变</strong>”，因为可以<strong>重复定义</strong>，不能保证值不变。(这个我觉得是最容易让人忽略的地方)</li></ul><p>所以，用宏定义定义常量，很“危险”。</p><h2 id="正确的做法"><a href="#正确的做法" class="headerlink" title="正确的做法"></a>正确的做法</h2><p>恰当的常量，应该具备合适的常量名字、正确的类型，还有const、extern等关键字的修饰，当然，还要根据常量适用的“<strong>范围</strong>”，做出恰当的处理。一下举例说明。</p><h3 id="只在函数中用的常量"><a href="#只在函数中用的常量" class="headerlink" title="只在函数中用的常量"></a>只在函数中用的常量</h3><p>只在函数中用的常量：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)runAnimation &#123;</span><br><span class="line">    <span class="comment">//动画时间长度常量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> kAnimationDurationLong = <span class="number">1.0</span>f;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>static、const定义了它是静态不可变的；<strong>NSTimeInterval</strong>则“精确”指定了常量的类型。</p><h3 id="只在一个“-m”文件中使用的常量"><a href="#只在一个“-m”文件中使用的常量" class="headerlink" title="只在一个“.m”文件中使用的常量"></a>只在一个“<strong>.m</strong>”文件中使用的常量</h3><p>在类的实现文件“xxx.m”文件中定义常量，也是很常见的。</p><p>你可能会觉得，既然是一个类使用的，那就放在类的头文件里面定义不就好了。</p><p><strong>但是这么想是错的=。=</strong></p><p><strong>因为所有要用到这个类的文件，都会无形当中包含了这些常量声明，将不必要的数据暴露在外面，这样是违反设计原则的，并且，如果常量名字取得不恰当，还有可能造成冲突。</strong></p><p>所以，应该如下:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XXX.m</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//必须要static</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> kAnimationDurationLong = <span class="number">1.0</span>f;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XXX</span></span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>需要注意的点：</p><ul><li>一定要放在.m文件中。</li><li>必须是<strong>static</strong>，表示此常量作用域只在此.m文件中。如果不加static的话，常量就会在全局作用域中声明，可能会导致跟其他的常量冲突。</li><li>const，当然。</li><li>NSTimeInterval，确定的类型。</li><li>kAnimationDurationLong，“<strong>k</strong>”开头的命名，也算是Apple的规范了吧，内部常量统一以“<strong>k</strong>”开头。</li></ul><h3 id="全局常量"><a href="#全局常量" class="headerlink" title="全局常量"></a>全局常量</h3><p>一般来说，最常见的全局常量就是发广播Notification时用的Notification的名字，往往都是一些字符串，下面就以这个为例子：</p><p>假设我们的类叫“<strong>TTGClass</strong>”，我们的类会向外发送Notification，所以需要定义一个Notification的名字常量供外界注册，如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TTGClass.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> TTGClassWorkBeginNotification;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TTGClass.m</span></span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> TTGClassWorkBeginNotification = <span class="string">@"TTGClassWorkBeginNotification"</span>;</span><br></pre></td></tr></table></figure><p>关键：</p><ul><li>头文件中只是做声明，不做定义。所以用extern表示常量在别处定义的，尽量隐藏细节。</li><li>同<strong>类名</strong>做常量名字的开头，<strong>这个非常关键，因为Objective-C里面没有像Java那样的“包”机制，所以必须靠命名来划分不同的类，常量当然也要遵循这个规则。</strong></li><li>NSString，确定的类型；const，表明常量；Notification后缀，表明用途。这些都是需要注意的。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>良好的代码，总是少不了定义各种常量，以避免“魔鬼数字、魔鬼字符串”。所以我们应该尽量避免少用#define定义常量，而是用带有类型的、const的常量，并且尽可能的缩小常量的作用域。</p><p>暴露的细节越少，出错的机会也就越小（忘了从哪里看到的=。=）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;写博客果然比光看书要花时间=。=，书都快看完了，才写到第4节。但是总结一遍，的确印象深刻啊~~&lt;/p&gt;
&lt;p&gt;这次的主题是“&lt;strong&gt;常量&lt;/strong&gt;”，非常常用，又非常重要的东西~良好的代码规范、设计，少不了各种&lt;strong&gt;常量&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;Item-4-Prefer-Typed-Constants-to-Preprocessor-define&quot;&gt;&lt;a href=&quot;#Item-4-Prefer-Typed-Constants-to-Preprocessor-define&quot; class=&quot;headerlink&quot; title=&quot;Item 4 - Prefer Typed Constants to Preprocessor #define&quot;&gt;&lt;/a&gt;Item 4 - Prefer Typed Constants to Preprocessor #define&lt;/h2&gt;&lt;p&gt;本节着重对比了常量的定义形式，类型常量和#define的区别、各自的特点。最后得出，我们应该用带有类型的常量，而不是#define。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="翻译" scheme="http://tutuge.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="笔记" scheme="http://tutuge.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>UITextView编辑时插入自定义表情-简单的图文混编</title>
    <link href="http://tutuge.me/2015/03/07/UITextView%E7%BC%96%E8%BE%91%E6%97%B6%E6%8F%92%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E6%83%85-%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BE%E6%96%87%E6%B7%B7%E7%BC%96/"/>
    <id>http://tutuge.me/2015/03/07/UITextView编辑时插入自定义表情-简单的图文混编/</id>
    <published>2015-03-07T03:04:38.000Z</published>
    <updated>2018-10-07T17:37:29.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在iOS开发中，经常需要用UITextView作为编辑文本的输入控件。<br>但是如何在编辑时插入自定义表情呢？就是像发微博时那样？</p><p>本文简单的用<strong>NSTextAttachment</strong>、<strong>NSAttributedString</strong>的特性，实现了</p><ul><li>在UITextView中编辑文字时插入自定义表情图片</li><li>同时可以返回带有表情“<strong>替换符</strong>”的纯文本字符串。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>本文代码工程地址：<a href="https://github.com/zekunyan/UITextViewDIYEmojiExample" target="_blank" rel="noopener">https://github.com/zekunyan/UITextViewDIYEmojiExample</a></p><p>效果图：</p><p><img src="/2015/03/07/UITextView编辑时插入自定义表情-简单的图文混编/inputEmoji_Sample.gif" alt="效果图"></p><a id="more"></a><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><ul><li>NSAttributedString及其子类，用于显示富文本。</li><li>NSTextAttachment，NSAttributedString的一种样式类，可以在文本中显示图片。</li><li>NSTextStorage，UITextView中的实际的文本封装。（见参考中的UITextView文档）</li></ul><h3 id="表情与其标志"><a href="#表情与其标志" class="headerlink" title="表情与其标志"></a>表情与其标志</h3><p>首先需要明确的是，我们的自定义表情一定是有一一对应的“<strong>标志</strong>”的，如“<strong>[/emoji_haha]</strong>”。</p><p>就是说，为了方便处理，方便在数据库、网络传输中保存、传输带有表情图片的文本，我们必须要为每种表情取特定的“<strong>名字</strong>”，数据库中储存的、网络传输的文本就只包含这些标志名字就行，在显示的时候做对应的替换。</p><p>如：</p><p><strong>tutuge.me<img src="/2015/03/07/UITextView编辑时插入自定义表情-简单的图文混编/blog_uitextview_input_emoji_emoji_1.png" alt="表情"></strong></p><p>对应的纯文本就是：</p><p><strong>tutuge.me[/emoji_1]</strong></p><h2 id="插入并显示表情图片"><a href="#插入并显示表情图片" class="headerlink" title="插入并显示表情图片"></a>插入并显示表情图片</h2><p>插入表情很简单，直接实例化<strong>NSTextAttachment</strong>类，将需要的表情的UIImage实例赋值给NSTextAttachment的image属性，然后用“<strong>[NSAttributedString attributedStringWithAttachment:]</strong>”方法实例化一个NSAttributedString的对象，插入到UITextView的textStorage对应的位置即可。</p><p>如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSTextAttachment *emojiTextAttachment = [NSTextAttachment <span class="keyword">new</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置表情图片</span></span><br><span class="line">emojiTextAttachment.image = emojiImage;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入表情</span></span><br><span class="line">[textView.textStorage <span class="string">insertAttributedString:</span>[NSAttributedString <span class="string">attributedStringWithAttachment:</span>emojiTextAttachment]</span><br><span class="line"><span class="symbol">                                     atIndex:</span>textView.selectedRange.location];</span><br></pre></td></tr></table></figure><p>这样，就能在UITextView当前光标位置插入表情图片了。</p><h2 id="获取带有表情标志的文本字符串"><a href="#获取带有表情标志的文本字符串" class="headerlink" title="获取带有表情标志的文本字符串"></a>获取带有表情标志的文本字符串</h2><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p>NSTextAttachment被插入到NSAttributedString中的时候，<strong>就被当成了一个字符处理！！！</strong>。<br>就是说，只从UITextView的text中，是找不回文本里面不同的表情所对应的标志的！</p><h3 id="解决点"><a href="#解决点" class="headerlink" title="解决点"></a>解决点</h3><ol><li>我们要能遍历出当前文本中所有的表情，也就是NSTextAttachment类。</li><li>我们要能知道遍历出的表情，对应的标志是什么。</li></ol><h3 id="遍历所有的NSTextAttachment类属性"><a href="#遍历所有的NSTextAttachment类属性" class="headerlink" title="遍历所有的NSTextAttachment类属性"></a>遍历所有的NSTextAttachment类属性</h3><p>遍历，嗯，先看看Apple有没有提供相应的方法，能遍历NSAttributedString（及其子类）的属性的。查阅文档：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAttributedString_Class/index.html#//apple_ref/occ/instm/NSAttributedString" target="_blank" rel="noopener">NSAttributedString Class Reference</a>，可以找到这么一个方法：“<strong>- enumerateAttribute:inRange:options:usingBlock:</strong>”，其原型如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)enumerateAttribute:(<span class="built_in">NSString</span> *)attrName</span><br><span class="line">                   inRange:(<span class="built_in">NSRange</span>)enumerationRange</span><br><span class="line">                   options:(<span class="built_in">NSAttributedStringEnumerationOptions</span>)opts</span><br><span class="line">                usingBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> value, <span class="built_in">NSRange</span> range, <span class="built_in">BOOL</span> *stop))block</span><br></pre></td></tr></table></figure><p>用处：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Executes <span class="keyword">the</span> Block <span class="keyword">for</span> <span class="keyword">the</span> specified attribute run <span class="keyword">in</span> <span class="keyword">the</span> specified range.</span><br></pre></td></tr></table></figure><p>看，就是这个方法~就能遍历出NSTextAttachment对象了~</p><h3 id="创建NSTextAttachment的子类"><a href="#创建NSTextAttachment的子类" class="headerlink" title="创建NSTextAttachment的子类"></a>创建NSTextAttachment的子类</h3><p>如何绑定NSTextAttachment所表示的表情和与其对应的标志？创建子类嘛~直接在子类中增加属性，保存标志不就行了。<br>如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">EmojiTextAttachment </span>: NSTextAttachment</span><br><span class="line"><span class="variable">@property</span>(strong, nonatomic) NSString *emojiTag;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>所以，这个时候，插入表情的代码应该就是下面这样：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EmojiTextAttachment *emojiTextAttachment = [EmojiTextAttachment <span class="keyword">new</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存表情标志</span></span><br><span class="line">emojiTextAttachment.emojiTag = emojiTag;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置表情图片</span></span><br><span class="line">emojiTextAttachment.image = emojiImage;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入表情</span></span><br><span class="line">[textView.textStorage <span class="string">insertAttributedString:</span>[NSAttributedString <span class="string">attributedStringWithAttachment:</span>emojiTextAttachment]</span><br><span class="line"><span class="symbol">                                      atIndex:</span>textView.selectedRange.location];</span><br></pre></td></tr></table></figure><h3 id="创建NSAttributedString的Category"><a href="#创建NSAttributedString的Category" class="headerlink" title="创建NSAttributedString的Category"></a>创建NSAttributedString的Category</h3><p>最后，就是将这个遍历表情、拼接最终文本字符串的方法设置成NSAttributedString的自定义Category方法，以方便直接调用。<br>当然，这里面有些细节的处理，如替换表情标志时的字符串偏移量计算等，看代码吧。</p><p>如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NSAttributedString+EmojiExtension.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSAttributedString</span> (<span class="title">EmojiExtension</span>)</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)getPlainString;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//NSAttributedString+EmojiExtension.m</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSAttributedString</span> (<span class="title">EmojiExtension</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)getPlainString &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终纯文本</span></span><br><span class="line">    <span class="built_in">NSMutableString</span> *plainString = [<span class="built_in">NSMutableString</span> stringWithString:<span class="keyword">self</span>.string];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//替换下标的偏移量</span></span><br><span class="line">    __block <span class="built_in">NSUInteger</span> base = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    [<span class="keyword">self</span> enumerateAttribute:<span class="built_in">NSAttachmentAttributeName</span> inRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="keyword">self</span>.length)</span><br><span class="line">                    options:<span class="number">0</span></span><br><span class="line">                 usingBlock:^(<span class="keyword">id</span> value, <span class="built_in">NSRange</span> range, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//检查类型是否是自定义NSTextAttachment类</span></span><br><span class="line">                    <span class="keyword">if</span> (value &amp;&amp; [value isKindOfClass:[EmojiTextAttachment <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                        <span class="comment">//替换</span></span><br><span class="line">                        [plainString replaceCharactersInRange:<span class="built_in">NSMakeRange</span>(range.location + base, range.length)</span><br><span class="line">                                                    withString:((EmojiTextAttachment *) value).emojiTag];</span><br><span class="line"></span><br><span class="line">                       <span class="comment">//增加偏移量</span></span><br><span class="line">                        base += ((EmojiTextAttachment *) value).emojiTag.length - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> plainString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>直接调用getPlainString方法即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实本文也是来源于最近的项目需求，在网上一直找不到比较好的解决方案，就自己摸索出来一个。至于复杂的图文混合编辑，当然还是Core Text来的强大（自己也在学习中）~</p><p>如果有更好地办法，一定要告诉我啊~~~</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITextView_Class/#//apple_ref/occ/instp/UITextView/textStorage" target="_blank" rel="noopener">UITextView Class Reference</a></li><li><a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAttributedString_Class/index.html#//apple_ref/occ/instm/NSAttributedString/enumerateAttribute:inRange:options:usingBlock:" target="_blank" rel="noopener">NSAttributedString Class Reference</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在iOS开发中，经常需要用UITextView作为编辑文本的输入控件。&lt;br&gt;但是如何在编辑时插入自定义表情呢？就是像发微博时那样？&lt;/p&gt;
&lt;p&gt;本文简单的用&lt;strong&gt;NSTextAttachment&lt;/strong&gt;、&lt;strong&gt;NSAttributedString&lt;/strong&gt;的特性，实现了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在UITextView中编辑文字时插入自定义表情图片&lt;/li&gt;
&lt;li&gt;同时可以返回带有表情“&lt;strong&gt;替换符&lt;/strong&gt;”的纯文本字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;p&gt;本文代码工程地址：&lt;a href=&quot;https://github.com/zekunyan/UITextViewDIYEmojiExample&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/zekunyan/UITextViewDIYEmojiExample&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2015/03/07/UITextView编辑时插入自定义表情-简单的图文混编/inputEmoji_Sample.gif&quot; alt=&quot;效果图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>关于评论不见了=。=</title>
    <link href="http://tutuge.me/2015/03/06/%E5%85%B3%E4%BA%8E%E8%AF%84%E8%AE%BA%E4%B8%8D%E8%A7%81%E4%BA%86/"/>
    <id>http://tutuge.me/2015/03/06/关于评论不见了/</id>
    <published>2015-03-06T01:09:32.000Z</published>
    <updated>2018-10-07T17:37:29.568Z</updated>
    
    <content type="html"><![CDATA[<p>前天升级了一次Hexo，原来的主题说啥也用不了了=。=（前端知识不足，正在补~）导致只能换主题，多说的评论就这样不见了。。。原来有留言的各位筒子，没看到，不好意思啊=。=</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前天升级了一次Hexo，原来的主题说啥也用不了了=。=（前端知识不足，正在补~）导致只能换主题，多说的评论就这样不见了。。。原来有留言的各位筒子，没看到，不好意思啊=。=&lt;/p&gt;

      
    
    </summary>
    
      <category term="其它" scheme="http://tutuge.me/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="杂烩" scheme="http://tutuge.me/tags/%E6%9D%82%E7%83%A9/"/>
    
  </entry>
  
  <entry>
    <title>Entity和Model的不同-关于代码的数据层</title>
    <link href="http://tutuge.me/2015/03/01/Entity%E5%92%8CModel%E7%9A%84%E4%B8%8D%E5%90%8C-%E5%85%B3%E4%BA%8E%E4%BB%A3%E7%A0%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%B1%82/"/>
    <id>http://tutuge.me/2015/03/01/Entity和Model的不同-关于代码的数据层/</id>
    <published>2015-03-01T15:03:10.000Z</published>
    <updated>2018-10-07T17:37:29.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经常都能在一些博客、文档中看到“<strong>Model</strong>”、“<strong>Entity</strong>”的字样。如<strong>MVC</strong>模式中的“<strong>M就是Model</strong>”，“<strong>MVVM对应的Model-View-ViewModel</strong>”，数据库抽象层里面的“<strong>Model</strong>“等。</p><p>它们的区别到底是什么？</p><p>其实没有真正官方的对Entity和Model的定义，在此我只是说说我自己的理解。</p><a id="more"></a><h2 id="什么是Entity"><a href="#什么是Entity" class="headerlink" title="什么是Entity"></a>什么是<strong>Entity</strong></h2><p>先看看这个单词是什么意思：<br><a href="http://www.iciba.com/entity" target="_blank" rel="noopener">爱词霸</a>：n: 实体，实际存在物，本质。</p><p>在代码中，我们经常会遇到一些具有“<strong>现实</strong>”意义的“<strong>个体</strong>”，如一个用户，一首歌曲，一条评论等等，它们都是在逻辑上完整的一个整体，都具有相似的结构，但是却因为“<strong>属性</strong>”的不同而不同。</p><p>看看一个典型的Entity类：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Entity类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserEntity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">public</span> int age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Entity对象</span></span><br><span class="line">UserEntity john = <span class="keyword">new</span> <span class="type">UserEntity</span>();</span><br><span class="line">john.name = <span class="string">"John"</span>;</span><br><span class="line">john.age = <span class="number">20</span>;</span><br><span class="line">john.address = <span class="string">"China Hubei Wuhan"</span>;</span><br><span class="line"></span><br><span class="line">UserEntity tom = <span class="keyword">new</span> <span class="type">UserEntity</span>();</span><br><span class="line">tom.name = <span class="string">"Tom"</span>;</span><br><span class="line">tom.age = <span class="number">30</span>;</span><br><span class="line">tom.address = <span class="string">"USA Californian"</span>;</span><br></pre></td></tr></table></figure><p>所以：</p><ul><li>Entity类，或者说<strong>实体类</strong>，代表了一种“个体”，类中的属性（就是各种变量）则是这个“个体”的具体体现。如UserEntity类，里面有name、age属性，就是说Entity类“<strong>描述</strong>”了某种个体。</li><li>Entity类的具体对象，代表了一个具体的实体，一般来说，在代码当中，一个具体的Entity类对象所代表的实体应当是唯一的。</li><li>往往Entity类的定义跟数据库中的表定义是一一对应的。</li><li>而Entity的具体对象往往对应数据库中的一行数据。</li><li>Entity是代码中操作数据的“<strong>最小单元</strong>”。</li></ul><h2 id="什么是Model"><a href="#什么是Model" class="headerlink" title="什么是Model"></a>什么是Model</h2><h3 id="各种用法"><a href="#各种用法" class="headerlink" title="各种用法"></a>各种用法</h3><p>其实很多时候，Model有如下几种用法：</p><ol><li>当成Entity用，完全不具备其他业务逻辑代码。</li><li>当成<strong>数据库接口层</strong>，就是将数据库的读写，增删改查都封装在了Model中，往往就会有如“<strong>getUserByID</strong>”这样的方法。</li><li>当成纯粹的业务处理类。</li></ol><p>所以仁者见仁，智者见智，其实都可以。</p><p>在此说说我的认识。</p><h3 id="我的认识"><a href="#我的认识" class="headerlink" title="我的认识"></a>我的认识</h3><p>先看看Model单词的意思:<br><a href="http://www.iciba.com/model" target="_blank" rel="noopener">爱词霸</a>：n: 模型；模式；典型。</p><p>既然是模型，而不是“数据”，所以我觉得，<strong>Model应该是利用Entity实体，来组合、处理、整合更上层、更抽象数据的类</strong>。</p><p>还是基于上面的“<strong>UserEntity</strong>”，看看下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserListModel</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> UserEntity[] users;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数，初始化用户列表等。</span></span><br><span class="line"></span><br><span class="line">    <span class="function">UserEntity <span class="title">getUserByName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//查找...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> transformUserAddressFormat &#123;</span><br><span class="line">        <span class="comment">//转化地址格式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是说，Entity还是原本的概念，只不过Model是基于Entity的更高层的数据抽象与处理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>说实话，Entity、Model，它们的职责到底是什么，真的不好说明白，大家也就做个参考吧=。=</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://stackoverflow.com/questions/3029952/ddd-and-mvc-difference-between-model-and-entity" target="_blank" rel="noopener">DDD and MVC: Difference between ‘Model’ and ‘Entity’</a></li><li><a href="http://whatis.techtarget.com/definition/entity" target="_blank" rel="noopener">Whatis.com Entity</a></li><li><a href="http://blogsh.de/2011/09/08/models-vs-entities" target="_blank" rel="noopener">Models vs. Entities</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;经常都能在一些博客、文档中看到“&lt;strong&gt;Model&lt;/strong&gt;”、“&lt;strong&gt;Entity&lt;/strong&gt;”的字样。如&lt;strong&gt;MVC&lt;/strong&gt;模式中的“&lt;strong&gt;M就是Model&lt;/strong&gt;”，“&lt;strong&gt;MVVM对应的Model-View-ViewModel&lt;/strong&gt;”，数据库抽象层里面的“&lt;strong&gt;Model&lt;/strong&gt;“等。&lt;/p&gt;
&lt;p&gt;它们的区别到底是什么？&lt;/p&gt;
&lt;p&gt;其实没有真正官方的对Entity和Model的定义，在此我只是说说我自己的理解。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>一次审核被拒的经历-关于iCloud到底应该备份什么数据</title>
    <link href="http://tutuge.me/2015/02/28/%E4%B8%80%E6%AC%A1%E5%AE%A1%E6%A0%B8%E8%A2%AB%E6%8B%92%E7%9A%84%E7%BB%8F%E5%8E%86-%E5%85%B3%E4%BA%8EiCloud%E5%88%B0%E5%BA%95%E5%BA%94%E8%AF%A5%E5%A4%87%E4%BB%BD%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE/"/>
    <id>http://tutuge.me/2015/02/28/一次审核被拒的经历-关于iCloud到底应该备份什么数据/</id>
    <published>2015-02-28T10:18:11.000Z</published>
    <updated>2018-10-07T17:37:29.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>项目最近一次审核被拒了=。=<br>仔细看了一下后，发现是没有遵守“<strong>iOS Data Storage Guidelines</strong>”。<br>在此总结一下。</p><h2 id="被拒原因"><a href="#被拒原因" class="headerlink" title="被拒原因"></a>被拒原因</h2><p>先看看被拒的反馈信息：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apps must follow the iOS <span class="built_in">Data</span> Storage Guidelines <span class="literal">or</span> they will be rejected</span><br><span class="line"></span><br><span class="line"><span class="keyword">On</span> launch <span class="literal">and</span> content download, your app stores <span class="number">12.14</span> MB, which does <span class="literal">not</span> comply <span class="keyword">with</span> the iOS <span class="built_in">Data</span> Storage Guidelines.</span><br></pre></td></tr></table></figure><p>大致意思就是App下载东西以后，在iCloud里面查看此App需要备份的体积变大了。</p><a id="more"></a><p>再根据 <a href="https://developer.apple.com/icloud/documentation/data-storage/index.html" target="_blank" rel="noopener"><strong>iOS Data Storage Guidelines</strong></a>的说明，得出几点重要信息：</p><ul><li>只有<strong>用户创建的，并且不能被App重现的文档、数据</strong>，才应该被保存在“<strong>&lt;Application_Home&gt;/Documents</strong>”路径下。</li><li>可以重新产生、下载的数据可以放在“<strong>&lt;Application_Home&gt;/Library/Caches</strong>”目录下，如用于缓存的数据库文件。</li><li>纯粹用于缓存的数据可以放在“<strong>&lt;Application_Home&gt;/tmp</strong>”目录下。</li><li>可以通过对NSURL加参数，来保证特定的文件夹及其内容不被iCloud备份，也不会被清除，如Document文件夹。</li></ul><p>所以可以初步得出被拒的原因是因为App中下载的文件也被包含在iCloud备份当中了，而Apple审核人员觉得这些文件不应该被备份。</p><h3 id="真正应该备份的数据"><a href="#真正应该备份的数据" class="headerlink" title="真正应该备份的数据"></a>真正应该备份的数据</h3><p>所以，真正需要备份的文件是<strong>用户创建的，不能通过程序重新产生的</strong>，如记事本应用中用户创建的文本数据，绘画应用中用户画的画等。</p><h2 id="解决当中遇到的坑"><a href="#解决当中遇到的坑" class="headerlink" title="解决当中遇到的坑"></a>解决当中遇到的坑</h2><p>既然知道了原因，那就好办了。</p><p>根据<strong>iOS Data Storage Guidelines</strong>的简短说明，乍一看，<strong>&lt;Application_Home&gt;/Library/Caches</strong>是存放可以重新产生、下载的数据。</p><p>但是有个“陷阱”在这。</p><h3 id="系统可能清空的目录"><a href="#系统可能清空的目录" class="headerlink" title="系统可能清空的目录"></a>系统可能清空的目录</h3><p>根据官方文档“<a href="https://developer.apple.com/library/mac/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple_ref/doc/uid/TP40010672-CH2-SW1" target="_blank" rel="noopener"><strong>File System Programming Guide</strong></a>”可以整理出一下两个系统可能会清除的目录：（在储存空间不够时）</p><ol><li>Library/Caches/</li><li>tmp/</li></ol><p>所以，像App下载的歌曲等资源文件是不能放在上面两个目录中的。</p><h2 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h2><p>所以，为了保险起见，最靠谱的还是放在<strong>&lt;Application_Home&gt;/Documents</strong>中，并且通过设置，不让iCloud备份。</p><p>Apple已经提供了相应的函数，如下（iOS 5.1及以后的版本）：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)addSkipBackupAttributeToItemAtURL:(NSURL *)URL &#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="string">[[NSFileManager defaultManager] fileExistsAtPath: [URL path]]</span>);</span><br><span class="line"></span><br><span class="line">    NSError *<span class="built_in">error</span> = <span class="literal">nil</span>;</span><br><span class="line">    BOOL success = [URL setResourceValue: [NSNumber numberWithBool: YES]</span><br><span class="line">                                  forKey: NSURLIsExcludedFromBackupKey <span class="built_in">error</span>: &amp;<span class="built_in">error</span>];</span><br><span class="line">    <span class="keyword">if</span>(!success)&#123;</span><br><span class="line">        NSLog(@<span class="string">"Error excluding %@ from backup %@"</span>, [URL lastPathComponent], <span class="built_in">error</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li><strong>&lt;Application_Home&gt;/Documents</strong>根目录也可以通过上面的函数设置成不备份。（如应用AVPlayer）</li><li>设置是递归的，所以其所有子目录和文件都不用再设置一次，都会自动不被备份。（测试有效，但是不确定=。=，参考：<a href="http://stackoverflow.com/questions/14376883/is-nsurlisexcludedfrombackupkey-recursive" target="_blank" rel="noopener">is-nsurlisexcludedfrombackupkey-recursive</a>）</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>多看官方说明=。=</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.apple.com/icloud/documentation/data-storage/index.html" target="_blank" rel="noopener">iOS Data Storage Guidelines</a></li><li><a href="https://developer.apple.com/library/ios/qa/qa1719/_index.html" target="_blank" rel="noopener">How do I prevent files from being backed up to iCloud and iTunes?</a></li><li><a href="https://developer.apple.com/library/mac/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple_ref/doc/uid/TP40010672-CH2-SW4" target="_blank" rel="noopener">File System Programming Guide</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;项目最近一次审核被拒了=。=&lt;br&gt;仔细看了一下后，发现是没有遵守“&lt;strong&gt;iOS Data Storage Guidelines&lt;/strong&gt;”。&lt;br&gt;在此总结一下。&lt;/p&gt;
&lt;h2 id=&quot;被拒原因&quot;&gt;&lt;a href=&quot;#被拒原因&quot; class=&quot;headerlink&quot; title=&quot;被拒原因&quot;&gt;&lt;/a&gt;被拒原因&lt;/h2&gt;&lt;p&gt;先看看被拒的反馈信息：&lt;/p&gt;
&lt;figure class=&quot;highlight lasso&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Apps must follow the iOS &lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; Storage Guidelines &lt;span class=&quot;literal&quot;&gt;or&lt;/span&gt; they will be rejected&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;On&lt;/span&gt; launch &lt;span class=&quot;literal&quot;&gt;and&lt;/span&gt; content download, your app stores &lt;span class=&quot;number&quot;&gt;12.14&lt;/span&gt; MB, which does &lt;span class=&quot;literal&quot;&gt;not&lt;/span&gt; comply &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; the iOS &lt;span class=&quot;built_in&quot;&gt;Data&lt;/span&gt; Storage Guidelines.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;大致意思就是App下载东西以后，在iCloud里面查看此App需要备份的体积变大了。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="审核" scheme="http://tutuge.me/tags/%E5%AE%A1%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>Block类型变量-缓存Http请求与回调</title>
    <link href="http://tutuge.me/2015/02/19/Block%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F-%E7%BC%93%E5%AD%98Http%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%9B%9E%E8%B0%83/"/>
    <id>http://tutuge.me/2015/02/19/Block类型变量-缓存Http请求与回调/</id>
    <published>2015-02-18T19:18:36.000Z</published>
    <updated>2018-10-07T17:37:29.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Objective-C中的Blocks实在是太好用了，有了它，我们就可以将“代码块”封装起来，当成变量使用、传递，所以，在Objective-C中，iOS中，许多的回调是用Block来完成的。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我自己在之前的项目中，就遇到过一个问题。因为项目的需要，手机端所有的跟服务器的通信都需要“加密”，在经过一番调研后，我们使用的是类似OAuth机制（至于什么是OAuth，各位Google一下就明白了，大部分的公共API都用到了这种机制）。</p><a id="more"></a><h3 id="缓存Http请求后的回调代码块"><a href="#缓存Http请求后的回调代码块" class="headerlink" title="缓存Http请求后的回调代码块"></a>缓存Http请求后的回调代码块</h3><p>既然是OAuth机制，就是说我们每次向服务器发起的请求，除了跟业务相关的参数，还需要带上AccessToken、UserToken这类的授权参数，而AccessToken在本次请求中是否会过期，在结果返回前是不知道的，所以，为了更好地用户体验，不至于让用户在某个时刻的操作，因为授权过期了而“没有响应”，我们的每次Http请求都必须缓存起来。</p><p>这里的缓存可不是单单指缓存请求的参数、URL，更重要的是缓存Http请求成功或者失败时的“<strong>回调代码块</strong>”。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="AFNetworking的Get方法"><a href="#AFNetworking的Get方法" class="headerlink" title="AFNetworking的Get方法"></a>AFNetworking的Get方法</h3><p>在iOS的项目中，AFNetworking应该算是使用的最多的网络库了，它的Get请求的方法接口如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (AFHTTPRequestOperation *)<span class="selector-tag">GET</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">URLString</span></span><br><span class="line">                     <span class="selector-tag">parameters</span><span class="selector-pseudo">:(id)parameters</span></span><br><span class="line">                        <span class="selector-tag">success</span><span class="selector-pseudo">:(void</span> (^)(AFHTTPRequestOperation *operation, id responseObject))<span class="selector-tag">success</span></span><br><span class="line">                        <span class="selector-tag">failure</span><span class="selector-pseudo">:(void</span> (^)(AFHTTPRequestOperation *operation, NSError *error))<span class="selector-tag">failure</span></span><br></pre></td></tr></table></figure><p>只有四个参数，分别是Url、参数、成功的回调Block，失败的回调Block，看，这里，回调的代码块就被封装到了Block里面，并当成参数传入。</p><h3 id="再次封装"><a href="#再次封装" class="headerlink" title="再次封装"></a>再次封装</h3><p>介于AFNetworking只提供了最基本的Get、Post、Put这些方法，所以，我们往往根据业务的接口做了封装，如先定义了请求的类型枚举：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSUInteger</span>, <span class="type">HTTP_REQUEST_TYPE</span>) &#123;</span><br><span class="line"><span class="type">ICG_GET</span>,</span><br><span class="line"><span class="type">ICG_POST</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后定义了统一的请求入口与回调参数Block：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求成功后的回调</span></span><br><span class="line">typedef <span class="keyword">void</span> (^http_success)(id result);</span><br><span class="line"><span class="comment">//请求失败后的回调</span></span><br><span class="line">typedef <span class="keyword">void</span> (^http_fail)();</span><br><span class="line"></span><br><span class="line"><span class="comment">//统一的请求入口</span></span><br><span class="line">+ (<span class="keyword">void</span>)<span class="string">executeWithType:</span>(HTTP_REQUEST_TYPE)type <span class="string">api:</span>(NSString *)api</span><br><span class="line"><span class="symbol">             parameters:</span>(NSDictionary *)parameters <span class="string">success:</span>(http_success)success <span class="string">fail:</span>(http_fail)fail &#123;</span><br><span class="line">    <span class="comment">//为每个请求增加AccessToken、UserToken等公共参数</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//缓存Http请求</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据type区分具体是哪一种Http请求。</span></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">ICG_GET:</span></span><br><span class="line">            [HttpUtil <span class="string">get:</span>url <span class="string">parameters:</span>paras <span class="string">success:</span>success <span class="string">fail:</span>fail];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">ICG_POST:</span></span><br><span class="line">            [HttpUtil <span class="string">post:</span>url <span class="string">parameters:</span>paras <span class="string">success:</span>success <span class="string">fail:</span>fail];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="symbol">        default:</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="再次封装的好处"><a href="#再次封装的好处" class="headerlink" title="再次封装的好处"></a>再次封装的好处</h3><p>为什么要再次做封装，将基本的Http请求统一入口？道理很简单，就是为了能方便的对每次请求增加额外的处理，并且对上层调用透明。如:</p><ul><li>统一为每个请求增加Log。</li><li>统一为每个请求增加如AccessToken这些额外的参数。</li><li>方便对Http请求做缓存！</li></ul><h3 id="缓存Http请求的数据结构"><a href="#缓存Http请求的数据结构" class="headerlink" title="缓存Http请求的数据结构"></a>缓存Http请求的数据结构</h3><p>既然我们已经有了统一的请求入口，为了缓存，所需要做的就是将能代表一次请求的所有参数缓存起来就行了，如URL、请求参数等，如下数据结构：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">RequestHolder </span>: NSObject</span><br><span class="line"><span class="comment">//URL地址</span></span><br><span class="line"><span class="variable">@property</span>(strong, nonatomic) NSString *url;</span><br><span class="line"><span class="comment">//请求参数</span></span><br><span class="line"><span class="variable">@property</span>(strong, nonatomic) NSMutableDictionary *paras;</span><br><span class="line"><span class="comment">//请求类型，如Get、Post</span></span><br><span class="line"><span class="variable">@property</span>(assign, nonatomic) HTTP_REQUEST_TYPE type;</span><br><span class="line"><span class="comment">//请求成功回调</span></span><br><span class="line"><span class="variable">@property</span>(copy) http_success success;</span><br><span class="line"><span class="comment">//请求失败回调</span></span><br><span class="line"><span class="variable">@property</span>(copy) http_fail fail;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>这几个参数，就可以完整的“代表、重现”一次具体的Http请求。</p><h3 id="如何缓存"><a href="#如何缓存" class="headerlink" title="如何缓存"></a>如何缓存</h3><p>只要App开启，Http请求就会不停地产生，会有源源不断的请求，难道我们把每次请求都缓存起来？</p><p>全部都缓存肯定是不行的，所以我们需要一个缓存策略。</p><p>一个App中，所有的Http请求的路径，也就是Url，不包括参数，应该是数量固定的，如“/user, /comment”，并且，一个请求往往对应的操作、功能也是唯一的，所以，完全可以以请求的<strong>Url</strong>为<strong>Key</strong>，以本次请求的“<strong>RequestHolder</strong>”为<strong>Value</strong>，用Objective-C中的NSDictionary来缓存Http请求。</p><p>所以，缓存请求的方法大致如下：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓存Http请求</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)cacheHttpRequest:(HTTP_REQUEST_TYPE)<span class="class"><span class="keyword">type</span> <span class="title">url</span>:</span>(NSString *)url</span><br><span class="line">            parameters:(NSMutableDictionary *)parameters success:(http_success)success fail:(http_fail)fail &#123;</span><br><span class="line">    <span class="comment">//创建缓存数据结构，保存本次请求的参数、回调</span></span><br><span class="line">    ICGRequestHolder *requestHolder = [ICGRequestHolder <span class="keyword">new</span>];</span><br><span class="line">    requestHolder.url = url;</span><br><span class="line">    requestHolder.paras = parameters;</span><br><span class="line">    requestHolder.success = [success copy];</span><br><span class="line">    requestHolder.fail = [fail copy];</span><br><span class="line">    requestHolder.<span class="keyword">type</span> = <span class="class"><span class="keyword">type</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存本次请求</span></span><br><span class="line">    [_operationQueue addOperationWithBlock:^&#123;</span><br><span class="line">        _cachedRequests[url] = requestHolder;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就能完整的缓存Http请求了。</p><h3 id="从缓存中恢复Http请求"><a href="#从缓存中恢复Http请求" class="headerlink" title="从缓存中恢复Http请求"></a>从缓存中恢复Http请求</h3><p>恢复请求很简单，直接遍历所有缓存的请求，再次发起Http请求即可，就不再贴代码了。</p><h3 id="删除成功的Http请求"><a href="#删除成功的Http请求" class="headerlink" title="删除成功的Http请求"></a>删除成功的Http请求</h3><p>缓存的目的是在请求失败时，如AccessToken超时时，我们可以在重新获取AccessToken后重现上次失败的请求，所以，一旦请求成功时，我们还需要将成功的请求删除，当然，也是利用Url，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">removeRequestForKey:</span>(NSString *)url &#123;</span><br><span class="line">    <span class="comment">//放入队列执行</span></span><br><span class="line">    [_operationQueue <span class="string">addOperationWithBlock:</span>^&#123;</span><br><span class="line">        <span class="comment">//删除Url对应的请求</span></span><br><span class="line">        [_cachedRequests <span class="string">removeObjectForKey:</span>url];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文只是简单地利用Objective-C中的Block特性，实现了Http请求的缓存。目的不是介绍Block，是为了分享我自己在项目中运用Block的例子，如果读者有更好的方法，欢迎留言啊~~</p><h2 id="参考、推荐阅读"><a href="#参考、推荐阅读" class="headerlink" title="参考、推荐阅读"></a>参考、推荐阅读</h2><ul><li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html" target="_blank" rel="noopener">Working with Blocks</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Objective-C中的Blocks实在是太好用了，有了它，我们就可以将“代码块”封装起来，当成变量使用、传递，所以，在Objective-C中，iOS中，许多的回调是用Block来完成的。&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;我自己在之前的项目中，就遇到过一个问题。因为项目的需要，手机端所有的跟服务器的通信都需要“加密”，在经过一番调研后，我们使用的是类似OAuth机制（至于什么是OAuth，各位Google一下就明白了，大部分的公共API都用到了这种机制）。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>提升UITableView性能-复杂页面的优化</title>
    <link href="http://tutuge.me/2015/02/19/%E6%8F%90%E5%8D%87UITableView%E6%80%A7%E8%83%BD-%E5%A4%8D%E6%9D%82%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://tutuge.me/2015/02/19/提升UITableView性能-复杂页面的优化/</id>
    <published>2015-02-18T17:28:41.000Z</published>
    <updated>2018-10-07T17:37:28.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着App的用户界面的内容越来越丰富，再强的手机可能都无法同时渲染复杂的UI界面和保证流畅的体验。所以，我们这些程序猿=。=在写代码的时候就要注意，如何尽可能提高用户的操作流畅性。</p><p>之前的做的项目，<a href="https://itunes.apple.com/us/app/qing-ju-yin-le-quan-guo-zui/id913235479?l=zh&amp;ls=1&amp;mt=8" target="_blank" rel="noopener">青桔音乐iOS客户端</a>里面的首页就是一个类似微信朋友圈的“动态”页面，大致如下：</p><p><img src="/2015/02/19/提升UITableView性能-复杂页面的优化/blog_ios_speed_up_uitableview_1_1.png" alt="青桔动态页面"></p><p>如果是你，你会怎么实现这个页面呢？</p><p>这还用问，当然是用UITableView+自定义的UITableViewCell。</p><p>UITableView是可以滑动的，为了不让用户在滑动中感到有卡顿，该如何优化？下面，我就写一下我自己在做项目时的“经验”~</p><a id="more"></a><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>主要分为以下几点：</p><ul><li>只定义一种Cell。</li><li>提前计算并缓存每个Cell的高度。</li><li>提前创建真正显示的、需要加工的数据并缓存。</li><li>缓存View！</li><li>其它。</li></ul><h3 id="只定义一种Cell"><a href="#只定义一种Cell" class="headerlink" title="只定义一种Cell"></a>只定义一种Cell</h3><p>乍一看，这个界面至少有3种样式的Cell，为什么只定义一种呢？</p><h4 id="分析结构"><a href="#分析结构" class="headerlink" title="分析结构"></a>分析结构</h4><p>仔细分析一下，页面中每个Cell的内容都有头像、标题、正文、评论、其它（歌曲、图片、歌手）。所以，从整体上看，每个Cell的结构是一致的！</p><h4 id="重用-大致固定数量的Cell"><a href="#重用-大致固定数量的Cell" class="headerlink" title="重用=大致固定数量的Cell"></a>重用=大致固定数量的Cell</h4><p>并且，凡是认真研究过UITableView的人应该都知道，Apple已经为我们提供了Cell的重用，如用“<strong>registerNib:forCellReuseIdentifier</strong>”方法注册自定义Cell的Nib，然后在“<strong>cellForRowAtIndexPath</strong>”的时候用“<strong>dequeueReusableCellWithIdentifier</strong>”获取可以重用的Cell，所以，无论UITableView要显示内容有多少，真正创建出的Cell可能只有5、6个。</p><p>所以，我们完全可以只创建一种Cell，虽然这样一个Cell的“体积”可能会很大，但是介于Cell的数量不会很多，所以完全可以接受。</p><h5 id="只定义一种Cell的好处"><a href="#只定义一种Cell的好处" class="headerlink" title="只定义一种Cell的好处"></a><strong>只定义一种Cell的好处</strong></h5><ul><li>减少代码量，减少Nib文件的数量，统一一个Nib文件定义Cell，容易修改、维护。</li><li>基于Cell的重用，真正运行时铺满屏幕所需的Cell数量大致是固定的，设为<strong>N</strong>个。所以如果如果只有一种Cell，那就是只有<strong>N</strong>个Cell的实例；但是如果有<strong>M</strong>种Cell，那么运行时最多可能会是“<strong>M x N = MN</strong>”个Cell的实例，虽然可能并不会占用太多内存，但是能少点不是更好吗。</li></ul><h4 id="善用hidden隐藏（显示）Subview"><a href="#善用hidden隐藏（显示）Subview" class="headerlink" title="善用hidden隐藏（显示）Subview"></a>善用hidden隐藏（显示）Subview</h4><p>既然只定义一种Cell，那该如何显示不同类型的内容呢？<br>答案就是，把所有不同类型的view都定义好，放在cell里面，通过hidden显示、隐藏，来显示不同类型的内容。如下图定义Cell：</p><p><img src="/2015/02/19/提升UITableView性能-复杂页面的优化/blog_ios_speed_up_uitableview_1_2.jpg" alt="Cell示意图"></p><p>图中的Subview1、Subview2、Subview3就是不同类型Cell的不同之处，所以我们在“<strong>cellForRowAtIndexPath</strong>”函数中，设置Cell的样式、内容时，就可以通过显示、隐藏这三个子view来显示。</p><p>毕竟，在用户快速滑动中，只是单纯的显示、隐藏subview比实时创建要快得多。</p><h3 id="提前计算并缓存每个Cell的高度"><a href="#提前计算并缓存每个Cell的高度" class="headerlink" title="提前计算并缓存每个Cell的高度"></a>提前计算并缓存每个Cell的高度</h3><p>开发过Android，用过Android的ListView以后，对UITableView需要提前计算Cell的高度很不适应。=。=</p><p>首先要确定的是，在iOS中，系统会先调用“<strong>tableView:heightForRowAtIndexPath:</strong>”获取每个Cell即将显示的高度，从而确定整个UITableView的布局。然后才调用“<strong>tableView:cellForRowAtIndexPath</strong>”获取每个Cell，我们也是在这里填充、设置Cell的。</p><p><strong>所以，既然高度总会被用到，那就早早的在获取数据时就计算好吧！</strong></p><h4 id="在Model（Entity）中计算并保存Cell的高度"><a href="#在Model（Entity）中计算并保存Cell的高度" class="headerlink" title="在Model（Entity）中计算并保存Cell的高度"></a>在Model（Entity）中计算并保存Cell的高度</h4><p>其实，在Model（Entity）中保存UI的参数是很奇怪的=。=（最好放在ViewModel中，就是MVVM模式的），我们的Entity可能就是下面的样子：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">DataEntity </span>: NSObject</span><br><span class="line"></span><br><span class="line"><span class="comment">//原始数据</span></span><br><span class="line"><span class="variable">@property</span>(copy, nonatomic) NSString *content;</span><br><span class="line"><span class="variable">@property</span>(copy, nonatomic) NSString *title;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Cell 高度</span></span><br><span class="line"><span class="variable">@property</span>(assign, nonatomic) CGFloat cellHeight;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算高度</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">calculateCellHeight</span>;</span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><p>这样，就不用在“<strong>tableView:heightForRowAtIndexPath:</strong>”中每次都计算了。</p><h3 id="提前创建真正显示的、需要加工的数据并缓存"><a href="#提前创建真正显示的、需要加工的数据并缓存" class="headerlink" title="提前创建真正显示的、需要加工的数据并缓存"></a>提前创建真正显示的、需要加工的数据并缓存</h3><p>Cell中显示的内容，很多时候可能并不是直接从服务器拿到的数据，而是经过“加工”的数据。如本文中的“动态”也，每个Cell的标题、正文都有可点击的连接Link、表情图片等富文本内容，而我们一般用NSAttributeString类来显示。</p><p>既然每次都会用到，倒不如在获取到数据的时候就创建、加工好这些内容，等到需要现实的时候，直接拿来用不就行了。</p><p>所以，我们的Entity类可能变成下面这个样子:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DataEntity</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//原始数据</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *content;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *title;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Cell 高度</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> cellHeight;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真正显示的内容</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSAttributedString</span> *showTitle;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSAttributedString</span> *showContent;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算高度</span></span><br><span class="line">- (<span class="keyword">void</span>)calculateCellHeight;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建、加工真正显示的内容</span></span><br><span class="line">- (<span class="keyword">void</span>)setupShowTitileAndContent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这样，在“<strong>tableView:cellForRowAtIndexPath</strong>”中，我们直接拿showTitle、showContent来显示就好，不用再创建。</p><h3 id="缓存View"><a href="#缓存View" class="headerlink" title="缓存View!"></a>缓存View!</h3><p>什么？缓存View？！</p><p>是的，当Cell中的部分View是非常独立的，并且不便于重用的，而且“体积”非常小，在内存可控的前提下，我们完全可以将这些view缓存起来！</p><p>方法当然也是将缓存的view放在Entity中~。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>当然，还有其他的优化方法，简单说一说：</p><ul><li>尽量设置Cell的view为opaque，避免GPU对Cell下面的内容也进行绘制。</li><li>避免大量的图片缩放、颜色渐变等。</li><li>避免同步的从网络、文件获取数据（这个是必须的=。=）</li><li>用shadowPath创建阴影。</li><li>尽量减少subview的数量，如多用drawRect绘制元素，替代用view显示。</li><li>尽量显示“<strong>大小刚好合适</strong>”的图片资源。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，就是：</p><p><strong>缓存一切可以缓存的！就是“用空间替换时间”！</strong></p><p><strong>在UITableView的Delegate、DataSource方法中，减少任何不必要的操作</strong></p><h2 id="参考，推荐阅读"><a href="#参考，推荐阅读" class="headerlink" title="参考，推荐阅读"></a>参考，推荐阅读</h2><ul><li><a href="http://www.raywenderlich.com/31166/25-ios-app-performance-tips-tricks#tableviews" target="_blank" rel="noopener">25 iOS App Performance Tips &amp; Tricks</a></li><li><a href="http://stackoverflow.com/questions/1352479/tricks-for-improving-iphone-uitableview-scrolling-performance" target="_blank" rel="noopener">Tricks for improving iPhone UITableView scrolling performance?</a></li><li><a href="http://stackoverflow.com/questions/6172158/how-can-i-speed-up-a-uitableview" target="_blank" rel="noopener">How can I speed up a UITableView?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;随着App的用户界面的内容越来越丰富，再强的手机可能都无法同时渲染复杂的UI界面和保证流畅的体验。所以，我们这些程序猿=。=在写代码的时候就要注意，如何尽可能提高用户的操作流畅性。&lt;/p&gt;
&lt;p&gt;之前的做的项目，&lt;a href=&quot;https://itunes.apple.com/us/app/qing-ju-yin-le-quan-guo-zui/id913235479?l=zh&amp;amp;ls=1&amp;amp;mt=8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;青桔音乐iOS客户端&lt;/a&gt;里面的首页就是一个类似微信朋友圈的“动态”页面，大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2015/02/19/提升UITableView性能-复杂页面的优化/blog_ios_speed_up_uitableview_1_1.png&quot; alt=&quot;青桔动态页面&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果是你，你会怎么实现这个页面呢？&lt;/p&gt;
&lt;p&gt;这还用问，当然是用UITableView+自定义的UITableViewCell。&lt;/p&gt;
&lt;p&gt;UITableView是可以滑动的，为了不让用户在滑动中感到有卡顿，该如何优化？下面，我就写一下我自己在做项目时的“经验”~&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="性能" scheme="http://tutuge.me/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>NSString的Copy与内存分配</title>
    <link href="http://tutuge.me/2015/02/18/NSString%E7%9A%84Copy%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>http://tutuge.me/2015/02/18/NSString的Copy与内存分配/</id>
    <published>2015-02-18T09:00:47.000Z</published>
    <updated>2018-10-07T17:37:29.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不管是用什么语言开发，字符串应该算是用的最多的了。在Objective-C中，字符串类是NSString，以及其子类NSMutableString等。所以，对于字符串类，编程语言、编译器等往往会做特殊处理。下面我就说说我自己在项目中发现的NSString的“奇怪”的地方。</p><a id="more"></a><h2 id="字符串常量，copy，mutableCopy"><a href="#字符串常量，copy，mutableCopy" class="headerlink" title="字符串常量，copy，mutableCopy"></a>字符串常量，copy，mutableCopy</h2><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>先看看如下面的代码，猜猜会输出什么：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str1 = <span class="string">@"abc"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *str2 = <span class="string">@"abc"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *str3 = [[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@"abc"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *str4 = [str1 <span class="keyword">copy</span>];</span><br><span class="line"><span class="built_in">NSString</span> *str5 = [str1 mutableCopy];</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出内存中的地址</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"str1: %p"</span>, str1);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"str2: %p"</span>, str2);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"str3: %p"</span>, str3);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"str4: %p"</span>, str4);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"str5: %p"</span>, str5);</span><br></pre></td></tr></table></figure><p>直接给出结果：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//地址值由运行时决定，不唯一</span></span><br><span class="line"><span class="symbol">str1:</span> <span class="number">0x10cd12040</span></span><br><span class="line"><span class="symbol">str2:</span> <span class="number">0x10cd12040</span></span><br><span class="line"><span class="symbol">str3:</span> <span class="number">0x10cd12040</span></span><br><span class="line"><span class="symbol">str4:</span> <span class="number">0x10cd12040</span></span><br><span class="line"><span class="symbol">str5:</span> <span class="number">0x7f874b508350</span> <span class="comment">//mutable copy</span></span><br></pre></td></tr></table></figure><p>看，是不是很“神奇”。</p><h3 id="简单解释"><a href="#简单解释" class="headerlink" title="简单解释"></a>简单解释</h3><p>NSString是“不可变（immutable）”的类型，这个是关键。<br>代码中的“@”开头的字符串，其实就是一个字符串常量，运行时会检测这个字符串是否已经存在，存在的话，就直接将这个字符串的地址赋给变量；不存在的话，则创建，再赋值。</p><p><strong>第一行</strong>: “abc”字符串不存在，创建，取得字符串地址“0x10cd12040”，赋给str1.</p><p><strong>第二行</strong>: “abc”字符串已经存在，直接将地址“0x10cd12040”赋给str2.</p><p><strong>第三行</strong>: （记住，NSString是不可变的）alloc并不会分配新的内存，直接将字符串地址“0x10cd12040”赋给str3.</p><p><strong>第四行</strong>: copy，既然是不可变的，也就没有必要分配新内存，直接将地址“0x10cd12040”赋给str4.</p><p><strong>第五行</strong>: mutableCopy其实就是创建一个NSMutableString的实例，既然是“可变（mutable）”的类型了，当然要分配新的内存，所以，字符串的地址也变成新的“0x7f874b508350”。</p><p>可以这么说，编译器、runtime充分利用了NSString是“<strong>不可变（immutable）</strong>”类型这个特点，只要字符串内容一致，就不会分配新的内存储存，字符串在程序中使用量非常大，这么做无疑可以大大节省内存，提升性能。</p><h2 id="Property-和-NSString"><a href="#Property-和-NSString" class="headerlink" title="Property 和 NSString"></a>Property 和 NSString</h2><p>先来看看一个UserEntity类：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UserEntity.h</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">UserEntity </span>: NSObject &lt;NSCopying&gt;</span><br><span class="line"><span class="variable">@property</span>(strong, nonatomic) NSString *name;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>只有一个名为name的NSString类型Property。<br>相信大家对这个不陌生吧。一般我们的应用中会有很多Entity类型，每个Entity类里面肯定避免不了有许多NSString的字符串类型。这里的name的属性是：strong和nonatomic，strong表明name要“持有”一份name所指的字符串的引用，nonatomic表示property类型不用加锁。</p><p>接着咱们看看下面的代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">UserEntity *userEntity = [UserEntity <span class="keyword">new</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建mutable类型的字符串</span></span><br><span class="line">NSMutableString *showName = [[NSMutableString alloc] <span class="string">initWithString:</span>@<span class="string">"tutuge"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//先保存“tutuge”字符串到userEntity的name</span></span><br><span class="line">userEntity.name = showName;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改showName</span></span><br><span class="line">[showName <span class="string">appendString:</span>@<span class="string">" blog"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出userEntity的name属性</span></span><br><span class="line">NSLog(@<span class="string">"Name: %@"</span>, userEntity.name);</span><br></pre></td></tr></table></figure><p>猜猜会输出什么？</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Name:</span> tutuge blog</span><br></pre></td></tr></table></figure><p>看，我们明明是保存的“tutuge”，怎么到后面输出的是“tutuge blog”？</p><h3 id="让NSString类型的Property为Copy型"><a href="#让NSString类型的Property为Copy型" class="headerlink" title="让NSString类型的Property为Copy型"></a>让NSString类型的Property为Copy型</h3><p>因为name的Property属性是strong的，所以赋值后，它跟showName均指向同一个NSMutableString实例，如下：</p><p><img src="/2015/02/18/NSString的Copy与内存分配/blog_ios_nsstring_copy_1_1.jpg" alt="内存示意图"></p><p>所以改变了showName，当然name输出的值也就变了。<br>这个时候，name的property属性就不能是strong了，应该是copy，如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UserEntity.h</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">UserEntity </span>: NSObject &lt;NSCopying&gt;</span><br><span class="line"><span class="variable">@property</span>(copy, nonatomic) NSString *name;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>这样的话，当“<strong>userEntity.name = showName;</strong>”这句运行后，内存布局如下：</p><p><img src="/2015/02/18/NSString的Copy与内存分配/blog_ios_nsstring_copy_1_2.jpg" alt="内存示意图"></p><p>这样，就避免了这个问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很所时候，代码并不是看上去那样“运行”的，多试试，多查阅资料，就能了解其中的奥秘了~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;不管是用什么语言开发，字符串应该算是用的最多的了。在Objective-C中，字符串类是NSString，以及其子类NSMutableString等。所以，对于字符串类，编程语言、编译器等往往会做特殊处理。下面我就说说我自己在项目中发现的NSString的“奇怪”的地方。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>利用NSProxy实现消息转发-模块化的网络接口层设计-原创</title>
    <link href="http://tutuge.me/2015/02/16/%E5%88%A9%E7%94%A8NSProxy%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82%E8%AE%BE%E8%AE%A1-%E5%8E%9F%E5%88%9B/"/>
    <id>http://tutuge.me/2015/02/16/利用NSProxy实现消息转发-模块化的网络接口层设计-原创/</id>
    <published>2015-02-16T10:52:08.000Z</published>
    <updated>2018-10-07T17:37:29.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><ul><li>2015-12-21: 其实用Category按照业务拆分网络请求接口的代码也是非常棒的，目前我自己就是这么做的=。=，文章就当做熟悉下NSProxy吧~</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在做项目的时候，所有业务的网络接口方法，全部都写在了一个文件里面，一开始还好，毕竟每个方法的代码也只是十几行，增加、修改也比较容易。但是随着接口的增多，这个文件慢慢居然超过了1000行，里面几十个方法都写在一起，实在是不好维护。</p><p>虽然保持这样也没有什么，多用用Cmd+F就能找到。但是，真是越看越不顺眼😳， 代码一定要有“美感”啊~😝</p><p>所以在查阅了大量文章后，终于想出了本文即将说明的办法，越发觉得Objective-C的“消息”机制是多么的赞~😚</p><h2 id="Github-示例"><a href="#Github-示例" class="headerlink" title="Github 示例"></a>Github 示例</h2><p>贴上本文中的示例工程：<a href="https://github.com/zekunyan/HttpProxyExample" target="_blank" rel="noopener">https://github.com/zekunyan/HttpProxyExample</a></p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>先抛出问题。</p><p>一款互联网应用，免不了要跟服务器打交道，在iOS项目中，最有名的网络库应该就是<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworking</a>了。所以，很多人就会利用AFnetworking提供的Get、Post等基本Http请求接口，封装自己的网络接口层代码，我自己在项目中也是这么做的。</p><p>但是，AFNetworking只是提供了Get、Post、Json传输等基本的Http请求方法，所以一旦落实到具体的业务相关的请求上，我们要为每个请求（URL）都写一个单独的接口方法。</p><p><strong>那么，问题就来了</strong></p><p>业务相关的接口那么多，举个例子，什么“通过用户ID获取用户基本信息”、“获取用户的所有评论”等，每个请求都是一个方法，这么多方法该怎么组织呢？全部放在一起？那这个接口类岂不是会非常乱？不放在一起？那岂不是会有很多个网络请求类？(至于要不要统一接口入口，我想这个根据项目来决定吧=。=)</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul><li>所有网络接口都从统一的类调用，如HttpProxy。</li><li>网络接口的具体实现，按照业务划分到不同的类中，如“<strong>UserHttpHandler</strong>”、“<strong>CommentHttpHandler</strong>”。</li></ul><p>其实，按照面向对象的原则，就是接口代理类<strong>HttpProxy</strong>拥有若干个按照业务划分的接口（Interface），这些接口的所有方法组成了网络层的不同的Http请求。如下图：</p><p><img src="blog_ios_http_proxy_1_1.jpg" alt="请求示意图"></p><p>那么，调用的时候，所有接口都用HttpProxy调用，如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际调用的是UserHttpHandler类的方法</span></span><br><span class="line"><span class="selector-attr">[[HttpProxy sharedInstance]</span> getUserWithID:@<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际调用的是CommentHttpHandler类的方法</span></span><br><span class="line"><span class="selector-attr">[[HttpProxy sharedInstance]</span> getCommentsWithDate:date];</span><br></pre></td></tr></table></figure><h2 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h2><p>根据前面的描述，我们可以得出，关键就是：<strong>消息转发（Message Forward）</strong></p><p>Objective-C里面没有我们传统的“方法调用”，取而代之的是“消息”，所有的方法都是通过向对象发送“消息”实现调用的。而这个机制，也就为我们的实现提供了方便。</p><p>也就是说：我们要将发给“<strong>HttpProxy</strong>”的消息，让HttpProxy转发给真正能接受这个消息的对象，HttpProxy就是个<strong>代理</strong>。</p><p>苹果已经给我们提供了这个“代理”类了-NSProxy。</p><h2 id="NSProxy"><a href="#NSProxy" class="headerlink" title="NSProxy"></a>NSProxy</h2><p>什么是NSProxy：</p><ul><li>NSProxy没有父类，是顶级类(根类)，跟NSObject同等地位。</li><li>NSProxy和NSObject都实现了“<strong>NSObject</strong> Protocol”。</li><li>NSProxy设计时就是以“抽象类”设计的，专门为<strong>转发消息</strong>而生。</li></ul><p>实现要求:</p><ol><li>继承NSProxy的子类要实现自己的初始化方法，如“init”、“initWith”。</li><li>重写<code>- forwardInvocation:</code>和<code>- methodSignatureForSelector:</code>方法，完成消息转发。</li></ol><p>详细内容参考Apple的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSProxy_Class/index.html#//apple_ref/occ/instm/NSProxy/forwardInvocation:" target="_blank" rel="noopener">文档</a>。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>先不管HttpProxy，咱们看看具体的接口，先举两个例子：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UserHttpHandler.h</span></span><br><span class="line"><span class="comment">//用户相关接口</span></span><br><span class="line"><span class="variable">@protocol</span> UserHttpHandler &lt;NSObject&gt;</span><br><span class="line">- (void)<span class="attribute">getUserWithID</span>:(NSNumber *)userID;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//CommentHttpHandler.h</span></span><br><span class="line"><span class="comment">//评论相关接口</span></span><br><span class="line"><span class="variable">@protocol</span> CommentHttpHandler &lt;NSObject&gt;</span><br><span class="line">- (void)<span class="attribute">getCommentsWithDate</span>:(NSDate *)date;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>好的，接口有了，我们的HttpProxy类应该“实现”了这两个接口。<br>然后，最好是单例类，所以还要有个获取单例的方法。<br>最后，还需要一个向HttpProxy注册具体实现了接口Protocol的方法。</p><p>所以，HttpProxy应该是这个样子的：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HttpProxy.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 继承了NSproxy。 2. “实现”了网络接口Protocol</span></span><br><span class="line"><span class="meta">@interface</span> <span class="string">HttpProxy :</span> NSProxy &lt;UserHttpHandler, CommentHttpHandler&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取单例</span></span><br><span class="line">+ (instancetype)sharedInstance;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册具体实现类</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">registerHttpProtocol:</span>(Protocol *)httpProtocol <span class="string">handler:</span>(id)handler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure><h3 id="找到消息对应的实现类对象"><a href="#找到消息对应的实现类对象" class="headerlink" title="找到消息对应的实现类对象"></a>找到消息对应的实现类对象</h3><p>如何在HttpProxy做消息转发时，找到某个消息对应的真正的实现类对象呢？</p><p>最好的办法就是保存每个接口方法到其实现类对象的映射，可以用Dictionary保存，关系如下图：</p><p><img src="blog_ios_http_proxy_1_2.jpg" alt="image"></p><p>所以，<code>registerHttpProtocol:handler:</code>方法的职责就是：</p><ol><li>遍历Protocol的所有方法（利用Objective-C的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html" target="_blank" rel="noopener">Runtime</a>）。</li><li>保存Protocol所有方法到实现类的对象的映射关系。（用方法的字符串表示作为key，实现类对象为value）</li></ol><p>所以，HttpProxy应该持有一个Dictionary的实例，用于保存映射关系，HttpProxy的实现部分如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HttpProxy.m</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> HttpProxy ()</span><br><span class="line"><span class="comment">//保存映射关系的字典。</span></span><br><span class="line"><span class="variable">@property</span>(strong, nonatomic) NSMutableDictionary *selToHandlerMap;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>注册方法实现如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)registerHttpProtocol:(Protocol *)httpProtocol handler:(<span class="keyword">id</span>)handler &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> numberOfMethods = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Protocol的所有方法</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method_description *methods = protocol_copyMethodDescriptionList(</span><br><span class="line">            httpProtocol, <span class="literal">YES</span>, <span class="literal">YES</span>, &amp;numberOfMethods);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为Protocol的每个方法注册真正的实现类对象handler</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfMethods; i++) &#123;</span><br><span class="line">        <span class="keyword">struct</span> objc_method_description method = methods[i];</span><br><span class="line">        [_selToHandlerMap setValue:handler forKey:<span class="built_in">NSStringFromSelector</span>(method.name)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现消息的转发"><a href="#实现消息的转发" class="headerlink" title="实现消息的转发"></a>实现消息的转发</h3><p>我们已经可以注册接口、保存映射关系了，剩下的就是重写NSProxy的两个方法，以实现消息的转发，至于这两个方法具体作用是什么，读者可以自行查阅相关资料。如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HttpProxy.m</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Method signature</span></span><br><span class="line">- (NSMethodSignature *)<span class="string">methodSignatureForSelector:</span>(SEL)sel &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取method的字符串表示</span></span><br><span class="line">    NSString *methodsName = NSStringFromSelector(sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找对应实现类对象</span></span><br><span class="line">    id handler = [_selToHandlerMap <span class="string">valueForKey:</span>methodsName];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//再次检查handler是否可以相应此消息</span></span><br><span class="line">    <span class="keyword">if</span> (handler != nil &amp;&amp; [handler <span class="string">respondsToSelector:</span>sel]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [handler <span class="string">methodSignatureForSelector:</span>sel];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> <span class="string">methodSignatureForSelector:</span>sel];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转发方法消息</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">forwardInvocation:</span>(NSInvocation *)invocation &#123;</span><br><span class="line">    NSString *methodsName = NSStringFromSelector(invocation.selector);</span><br><span class="line">    id handler = [_selToHandlerMap <span class="string">valueForKey:</span>methodsName];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handler != nil &amp;&amp; [handler <span class="string">respondsToSelector:</span>invocation.selector]) &#123;</span><br><span class="line">        [invocation <span class="string">invokeWithTarget:</span>handler];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">super</span> <span class="string">forwardInvocation:</span>invocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>看看如何使用HttpProxy：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化，注册Protocol对应的实现类对象</span></span><br><span class="line">[[HttpProxy sharedInstance] <span class="string">registerHttpProtocol:</span><span class="meta">@protocol</span>(UserHttpHandler) <span class="string">handler:</span>[UserHttpHandlerImp <span class="keyword">new</span>]];</span><br><span class="line">[[HttpProxy sharedInstance] <span class="string">registerHttpProtocol:</span><span class="meta">@protocol</span>(CommentHttpHandler) <span class="string">handler:</span>[CommentHttpHandlerImp <span class="keyword">new</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">[[HttpProxy sharedInstance] <span class="string">getUserWithID:</span>@<span class="number">100</span>];</span><br><span class="line">[[HttpProxy sharedInstance] <span class="string">getCommentsWithDate:</span>[NSDate <span class="keyword">new</span>]];</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所有的代码及示例都提交到Github了，<a href="https://github.com/zekunyan/HttpProxyExample" target="_blank" rel="noopener">HttpProxyExample</a>。</p><p>总的来说，就是利用Objective-C的“消息”机制，继承NSProxy抽象类，实现自己定义的转发机制，将网络接口层的各个方法的实现与声明分离，提升项目代码的可维护性，更加模块化。如下图表示:</p><p><img src="blog_ios_http_proxy_1_3.jpg" alt="image"></p><p>以上，就是我自己在项目中，利用NSProxy设计并实现的网络接口层结构。💪</p><p>从了解NSProxy、Runtime到设计、实现出这个网络层架构，着实花了点时间，收获真是不少。其实像这种纯代码层次的重构，很多人会觉得“吃力不讨好”😨，但我觉得，正是这样，才能真正让自己提升。</p><p>代码是具有美感的！嗯！😝</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSProxy_Class/index.html#//apple_ref/occ/instm/NSProxy" target="_blank" rel="noopener">NSProxy Class Reference</a></li><li><a href="http://objectivetoast.com/2014/05/12/nsproxy-nsobjects-lesser-known-sibling/" target="_blank" rel="noopener">NSProxy, NSObject’s Lesser-Known Sibling</a></li><li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html" target="_blank" rel="noopener">Objective-C Runtime Programming Guide</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;更新&quot;&gt;&lt;a href=&quot;#更新&quot; class=&quot;headerlink&quot; title=&quot;更新&quot;&gt;&lt;/a&gt;更新&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;2015-12-21: 其实用Category按照业务拆分网络请求接口的代码也是非常棒的，目前我自己就是这么做的=。=，文章就当做熟悉下NSProxy吧~&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前在做项目的时候，所有业务的网络接口方法，全部都写在了一个文件里面，一开始还好，毕竟每个方法的代码也只是十几行，增加、修改也比较容易。但是随着接口的增多，这个文件慢慢居然超过了1000行，里面几十个方法都写在一起，实在是不好维护。&lt;/p&gt;
&lt;p&gt;虽然保持这样也没有什么，多用用Cmd+F就能找到。但是，真是越看越不顺眼😳， 代码一定要有“美感”啊~😝&lt;/p&gt;
&lt;p&gt;所以在查阅了大量文章后，终于想出了本文即将说明的办法，越发觉得Objective-C的“消息”机制是多么的赞~😚&lt;/p&gt;
&lt;h2 id=&quot;Github-示例&quot;&gt;&lt;a href=&quot;#Github-示例&quot; class=&quot;headerlink&quot; title=&quot;Github 示例&quot;&gt;&lt;/a&gt;Github 示例&lt;/h2&gt;&lt;p&gt;贴上本文中的示例工程：&lt;a href=&quot;https://github.com/zekunyan/HttpProxyExample&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/zekunyan/HttpProxyExample&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Effective-Objective-C-读书笔记-Item-3</title>
    <link href="http://tutuge.me/2015/02/14/Effective-Objective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Item-3/"/>
    <id>http://tutuge.me/2015/02/14/Effective-Objective-C-读书笔记-Item-3/</id>
    <published>2015-02-14T08:51:51.000Z</published>
    <updated>2018-10-07T17:37:28.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>item 3讲的是Objective-C里面的“字面量语法”-“Literal Syntax”，个人觉得非常有用。</p><h2 id="Item-3-Prefer-Literal-Syntax-over-the-Equivalent-Methods"><a href="#Item-3-Prefer-Literal-Syntax-over-the-Equivalent-Methods" class="headerlink" title="Item 3 - Prefer Literal Syntax over the Equivalent Methods"></a>Item 3 - Prefer Literal Syntax over the Equivalent Methods</h2><p>本节讲了Objective-C中的“字面量语法”，并且建议我们更多的使用这种语法，而不是使用传统的等价的函数方法。</p><a id="more"></a><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>当我们使用Objective-C编程的时候，总会经常使用到几种Foundation框架中的基本类，如NSString、NSNumber、NSArray、NSDictionary，或者是它们的子类。例如，当我们想创建一个字符串的时候，会这么写：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">NSString</span> *<span class="keyword">str </span>= <span class="comment">@"a string";</span></span><br></pre></td></tr></table></figure><p>不知道各位写这句的时候有没有觉得奇怪？为什么不用先“alloc”，再“initWithXXX”这么来创建呢。是的，这里创建字符串，就用到了Objective-C提供的“字面量语法”-“Literal Syntax”，而这种语法的“标志”就是“@”符号。<br>有了字面量语法，我们就不用每次创建一些基本类型的时候，写一大堆alloc、init了。</p><h2 id="NSNumber"><a href="#NSNumber" class="headerlink" title="NSNumber"></a>NSNumber</h2><p>字符串可以用字面量语法创建，数字类NSNumber肯定也可以，如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *intNum = @<span class="number">1</span>;</span><br><span class="line"><span class="built_in">NSNumber</span> *floatNum = @<span class="number">1.1</span>f;</span><br><span class="line"><span class="built_in">NSNumber</span> *doubleNum = @<span class="number">1.1</span>;</span><br><span class="line"><span class="built_in">NSNumber</span> *boolNum = @YES;</span><br><span class="line"><span class="built_in">NSNumber</span> *charNum = @<span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不用字面量语法</span></span><br><span class="line"><span class="built_in">NSNumber</span> *intNumber = [[<span class="built_in">NSNumber</span> alloc] initWithInt:<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>看，是不是很方便~</p><h2 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a>NSArray</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>数组算是最常用的一种数据结构了，如果没有字面量语法，创建数组可能是这样：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *numbers = [[NSArray alloc] <span class="symbol">initWithObjects:</span><span class="variable">@1</span>, <span class="variable">@1</span>.<span class="number">1</span>, <span class="variable">@2</span>.0f, <span class="variable">@YES</span>, <span class="keyword">nil</span>];</span><br></pre></td></tr></table></figure><p>用字面量语法的话，就是这样：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *numbers = <span class="symbol">@[</span><span class="symbol">@1</span>, <span class="symbol">@1</span><span class="number">.1</span>, <span class="symbol">@2</span><span class="number">.0</span>f, <span class="symbol">@YES]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="存取值"><a href="#存取值" class="headerlink" title="存取值"></a>存取值</h3><p>创建了数组，肯定要从数组里面取值，用NSArray的方法就是这样：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取</span></span><br><span class="line">NSNumber *aNumber = [numbers objectAtIndex:<span class="number">2</span>];</span><br><span class="line"><span class="comment">//存</span></span><br><span class="line">NSMutableArray *mutableArray = [[NSMutableArray alloc] initWithArray:@[@1, @2, @3]];</span><br><span class="line">[mutableArray replaceObjectAtIndex:<span class="number">1</span> withObject:@4];</span><br></pre></td></tr></table></figure><p>跟C语言、Java这些语法很不一样啊，人家都是通过中括号“[]”直接用下标取值就可以。有了字面量同语法，Objective-C也可以这样:</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取</span></span><br><span class="line">NSNumber *aNumber = numbers[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//存</span></span><br><span class="line">NSMutableArray *mutableArray = [[NSMutableArray alloc] initWithArray:@[@1, @2, @3]];</span><br><span class="line">mutableArray[<span class="number">1</span>] = @4;</span><br></pre></td></tr></table></figure><h3 id="要注意的地方"><a href="#要注意的地方" class="headerlink" title="要注意的地方"></a>要注意的地方</h3><p>传统的通过“initWithObjects”方法创建数组的时候，是根据最后的“nil”判断数组是否结束的，也就是说，用于初始化数组的元素中有“nil”值也不会导致异常（Exception），如下语句：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *number1 = @<span class="number">1</span>;</span><br><span class="line"><span class="built_in">NSNumber</span> *number2 = <span class="literal">nil</span>; <span class="comment">//空指针</span></span><br><span class="line"><span class="built_in">NSNumber</span> *number3 = @<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="built_in">NSArray</span> *numbers = [[<span class="built_in">NSArray</span> alloc] initWithObjects:</span><br><span class="line">  number1, number2, number3, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出为1，因为number2，创建到number2就截止了</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"numbers count: %d"</span>, numbers.count);</span><br></pre></td></tr></table></figure><p>但是，如果用字面量语法创建，就是出问题：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *number1 = @<span class="number">1</span>;</span><br><span class="line"><span class="built_in">NSNumber</span> *number2 = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSNumber</span> *number3 = @<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建出现异常！！！</span></span><br><span class="line"><span class="built_in">NSArray</span> *numbers = @[number1, number2, number3];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"numbers count: %d"</span>, numbers.count);</span><br></pre></td></tr></table></figure><p>因为字面量语法只是单纯的将中括号中的元素全部加到数组中，但是，Objective-C中的数组是不可以存放nil值的，所以程序会运行时抛出异常。</p><h2 id="NSDictionary"><a href="#NSDictionary" class="headerlink" title="NSDictionary"></a>NSDictionary</h2><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><p>如果不用字面量语法创建字典，传统的创建函数简直令人匪夷所思：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// number1-&gt;@1</span></span><br><span class="line"><span class="comment">// number2-&gt;@2</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *dict = [[<span class="built_in">NSDictionary</span> alloc] initWithObjectsAndKeys:@<span class="number">1</span>, <span class="string">@"number1"</span>, @<span class="number">2</span>, <span class="string">@"number2"</span>, <span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>是不是很奇怪，<strong>value在前面，key在后面</strong></p><p>所以，还是用新的语法吧：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary <span class="symbol">*</span>dict = <span class="meta">@&#123;</span><span class="meta">@"number1"</span> : <span class="meta">@1,</span> <span class="meta">@"number2"</span> : <span class="meta">@2&#125;;</span></span><br></pre></td></tr></table></figure><p>这样才符合“常识”嘛，key在前，value在后面，跟JSON的定义一样。</p><h3 id="存取值-1"><a href="#存取值-1" class="headerlink" title="存取值"></a>存取值</h3><p>取值的语法跟NSArray的语法很想，只不过是将下标数字变成了key：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统</span></span><br><span class="line">NSNumber *number1 = [dict <span class="string">objectForKey:</span>@<span class="string">"number1"</span>];</span><br><span class="line">[dict <span class="string">setValue:</span>@<span class="number">5</span> <span class="string">forKey:</span>@<span class="string">"number1"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//字面量语法</span></span><br><span class="line">NSNumber *number2 = dict[@<span class="string">"number1"</span>];</span><br><span class="line">dict[@<span class="string">"number1"</span>] = @<span class="number">6</span>;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>需要注意的地方，跟创建数组一样，NSDictionary的value不能为nil值，否则会抛出异常。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，使用字面量语法可以让代码更加清晰、简单，毕竟，更少的代码，有时候意味着更少的错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;item 3讲的是Objective-C里面的“字面量语法”-“Literal Syntax”，个人觉得非常有用。&lt;/p&gt;
&lt;h2 id=&quot;Item-3-Prefer-Literal-Syntax-over-the-Equivalent-Methods&quot;&gt;&lt;a href=&quot;#Item-3-Prefer-Literal-Syntax-over-the-Equivalent-Methods&quot; class=&quot;headerlink&quot; title=&quot;Item 3 - Prefer Literal Syntax over the Equivalent Methods&quot;&gt;&lt;/a&gt;Item 3 - Prefer Literal Syntax over the Equivalent Methods&lt;/h2&gt;&lt;p&gt;本节讲了Objective-C中的“字面量语法”，并且建议我们更多的使用这种语法，而不是使用传统的等价的函数方法。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="翻译" scheme="http://tutuge.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="笔记" scheme="http://tutuge.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Effective-Objective-C-读书笔记-Item-2</title>
    <link href="http://tutuge.me/2015/02/06/Effective-Objective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Item-2/"/>
    <id>http://tutuge.me/2015/02/06/Effective-Objective-C-读书笔记-Item-2/</id>
    <published>2015-02-06T08:43:46.000Z</published>
    <updated>2018-10-07T17:37:28.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第二弹来了。</p><h2 id="Item-2-Minimize-Importing-Headers-in-Headers"><a href="#Item-2-Minimize-Importing-Headers-in-Headers" class="headerlink" title="Item 2 - Minimize Importing Headers in Headers"></a>Item 2 - Minimize Importing Headers in Headers</h2><p>这一节讲的是尽量在一个头文件中减少其它头文件的引入。</p><a id="more"></a><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>Objective-C和C语言、C++很像，都将类的实现与声明分开，用.h后缀名文件表示声明文件，用.m文件实现类。当要用到这个类的时候，只需要引入头文件即可，至于编译器、运行时是如何知道头文件里面的类对应的实现在哪里，在这了不做说明。一下用例子说明，先看看下面的类：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Wheel.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//车轮类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Wheel</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *manufacturer;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> radius;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>第二个类</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Engine.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//发动机类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Engine</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *manufacturer;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> power;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>然后就是车类Car：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Car.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//汽车类，只有一个轮子，不要奇怪=。=</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) Wheel *wheel;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) Engine *engine;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>注意到少了什么东西没有？<br>是的，写过C语言、C++的童鞋一下就能发现，Car类没有引入Engine和Wheel的头文件，肯定会编译出错的，因为编译器不知道Engine、Wheel类是啥。<br>那好，我们加上下面两行：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> <span class="string">"Wheel.h"</span></span><br><span class="line">#<span class="keyword">import</span> <span class="string">"Engine.h"</span></span><br></pre></td></tr></table></figure><p>嗯。这样就不会出错了。但是这样真的好吗？Objective-C给我们提供了@class关键字，就是来解决这个问题的。</p><h2 id="前置声明（forward-declaration）"><a href="#前置声明（forward-declaration）" class="headerlink" title="前置声明（forward declaration）"></a>前置声明（forward declaration）</h2><p>何为前置声明？看看下面的Car类的头文件例子。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Car.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Wheel</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Engine</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) Wheel *wheel;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) Engine *engine;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>@class就是类的前置声明（forward declaration），就是告诉编译器“嗨，不用找了，Wheel类和Engine类是肯定存在的，用到的时候再找”。有了前置声明，我们就不用显式的引入Wheel类和Engine类了。</p><p>当然，在Car类的实现文件.m文件中，我们还是要显式的引入Wheel和Engine类的，因为在这里我们要具体用到这两个类了，当然要知道类的细节。</p><h3 id="为何不要import？"><a href="#为何不要import？" class="headerlink" title="为何不要import？"></a>为何不要import？</h3><p>为什么不直接import呢？因为如果直接用import引入Wheel和Engine的声明，那么任何import引入了Car类的文件，也同时会引入Wheel、Engine类的声明，而且最终我们可能并不一定会直接跟Wheel、Engine类打交道，这样不就引入了“没有用”的类了吗？而且这样做很可能造成文件引入成“环”。</p><p>虽然import可以避免重复声明造成编译出错，传统的C语言、C++在声明的时候也可以通过如下方式避免重复声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WHEEL_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _WHEEL_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明内容...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>但是既然Objective-C有@class这种前置声明的办法，为何不用呢。</p><h2 id="必须用import的时候"><a href="#必须用import的时候" class="headerlink" title="必须用import的时候"></a>必须用import的时候</h2><p>当然，@class这样的前置声明并不能解决一切头文件引入的问题，如下这样的类，就必须要用import：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Car 的声明</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Driver protocol的定义</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Driver.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BigCar</span> : <span class="title">Car</span> &lt;<span class="title">Driver</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>是的，当类需要被继承、定义的protocol需要实现的时候，就需要import相关的头文件了（protocol的实现如果跟类的使用者没有关联，可以定义在类的实现文件中的“扩展category”中）,当然，还有@protocol这样的protocol的前置声明，怎么用就留给读者自己查阅相关资料了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大费周章的讲了这么多，其实目的就是一个：尽量少在头文件里面引入其他头文件。</p><p>最终的目的就是<strong>只暴露最少的细节</strong>。</p><p>写代码有段时间了，一直都在琢磨这句话，希望读者也能好好体会~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;第二弹来了。&lt;/p&gt;
&lt;h2 id=&quot;Item-2-Minimize-Importing-Headers-in-Headers&quot;&gt;&lt;a href=&quot;#Item-2-Minimize-Importing-Headers-in-Headers&quot; class=&quot;headerlink&quot; title=&quot;Item 2 - Minimize Importing Headers in Headers&quot;&gt;&lt;/a&gt;Item 2 - Minimize Importing Headers in Headers&lt;/h2&gt;&lt;p&gt;这一节讲的是尽量在一个头文件中减少其它头文件的引入。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="翻译" scheme="http://tutuge.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="笔记" scheme="http://tutuge.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Effective-Objective-C-读书笔记-Item-1</title>
    <link href="http://tutuge.me/2015/02/05/Effective-Objective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Item-1/"/>
    <id>http://tutuge.me/2015/02/05/Effective-Objective-C-读书笔记-Item-1/</id>
    <published>2015-02-04T17:17:08.000Z</published>
    <updated>2018-10-07T17:37:29.590Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直都在做项目，没什么时间作总结，感觉很不是滋味。现在放假了，嗯，终于有时间了~~哈哈（天生程序猿一枚好不好=。=）<br>最近开始读英文版的Effective Objective-C 2.0，觉得不错，就总结些东西，分享给各位读者吧。</p><h2 id="Item-1-Familiarize-Yourself-with-Objective-C’s-Roots"><a href="#Item-1-Familiarize-Yourself-with-Objective-C’s-Roots" class="headerlink" title="Item 1 - Familiarize Yourself with Objective-C’s Roots"></a>Item 1 - Familiarize Yourself with Objective-C’s Roots</h2><p>第一章的目的，就是让大家熟悉Objective-C，自然，标题的意思也就是“了解Objective-C的基本概念”，不多说，开写。</p><a id="more"></a><h2 id="消息与运行时"><a href="#消息与运行时" class="headerlink" title="消息与运行时"></a>消息与运行时</h2><p>总的来说，Objective-C跟C++、Java这些面向对象的语言是非常相似的，但是还是有许多不同的地方。如果你是第一次看到Objective-C的语法，一定觉得非常奇怪，因为Objective-C使用的是基于消息（Message）的框架，而不是传统的方法、函数调用。如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objective-C</span></span><br><span class="line">Person *person = [Person <span class="keyword">new</span><span class="type"></span>];</span><br><span class="line">[person setName:<span class="type"></span>@<span class="string">"tutuge"</span> age:<span class="type">24</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java</span></span><br><span class="line">Person person = <span class="keyword">new</span> <span class="type">Person</span>();</span><br><span class="line">person.setNameAndAge(<span class="string">"tutuge"</span>, <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++</span></span><br><span class="line">Person *person = <span class="keyword">new</span> <span class="type">Person</span>;</span><br><span class="line">person-&gt;setNameAndAge(<span class="string">"tutuge"</span>, <span class="number">24</span>);</span><br></pre></td></tr></table></figure><p>很奇怪是不是，各种中括号。但是我觉得，Objective—C这么设计就是为了时刻提醒你，“我是基于消息机制的！”。消息，的确是Objective-C与Java、C++这种语言最大的不同，而且，这种不同远不止在语法上面。简单来说如下两点：</p><ul><li><strong>基于消息的调用：</strong> 所有的函数调用都是在“运行时”决定的。</li><li><strong>基于方法的调用：</strong> 所有的函数调用都是在“编译时”决定的，就是编译器编译时决定的。</li></ul><p>其实，连被调方法的对象类型，都是在运行时决定的。所以说，Objective-C的运行时系统，担负了绝大部分的工作。这么设计的优点，举个例子，就是当运行时系统升级时，原有的代码不用重新编译即可“享受”升级带来的好处。</p><h2 id="C的超集"><a href="#C的超集" class="headerlink" title="C的超集"></a>C的超集</h2><p>Objective-C是C语言的超集，所以C语言所具有的一切特性，Objective-C都可以兼容，充分理解C语言的内存模型，对理解Objective-C很有帮助。如下：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">NSString</span> *<span class="keyword">str </span>= <span class="comment">@"a string";</span></span><br></pre></td></tr></table></figure><p>这一行代码跟C语言没有什么不同，（忽略@符号=。=），原理跟C语言也是一致的，就是str指针是NSString类型的指针，指向了一块存着字符串“a string”的内存区域。不同的是，在Objective-C里，所有的对象只可以声明为指针类型，所以如下代码是不合理的：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString str<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>为了更充分的理解，咱们看看如下例子：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">NSString</span> *<span class="keyword">str1 </span>= <span class="comment">@"a string";</span></span><br><span class="line"><span class="symbol">NSString</span> *<span class="keyword">str2 </span>= <span class="keyword">str1;</span></span><br></pre></td></tr></table></figure><p>熟悉C语言的朋友应该知道这是怎么回事，内存当中只有一块区域储存着“a string”这个字符串，str1、str2都是指向着这个区域的字符串指针。如下图：</p><p><img src="/2015/02/05/Effective-Objective-C-读书笔记-Item-1/blog_effective_objective_c_item_1_1.jpg" alt="image"></p><ul><li>str1、str2都在栈内存上分配的，就是字符串（NSString）类型的指针。</li><li>“a string”字符串实际储存在堆内存上。</li><li>str1、str2均指向同一块内存区域。</li></ul><p>此处的栈内存、堆内存跟C语言中的概念也是一样的，不同的是，在Objective-C中，我们不用手动去malloc、free内存，Objective-C使用内存计数计数帮我们管理内存。</p><h2 id="结构体，基本类型"><a href="#结构体，基本类型" class="headerlink" title="结构体，基本类型"></a>结构体，基本类型</h2><p>在Objective-C中，并不是所有的变量都是指针类型的，像int、float、double这些依旧是传统的“栈上分配”的，当然，还有结构体struct、枚举enum、联合union等。如：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CGPoint point = CGPointMake(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">CGRect frame = CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>这的CGPoint、CGRect都是结构体，但是都是直接在栈上分配内存的，以减少过度使用Objective-C类型的类（减少运行时的压力），各位读者使用的时候要注意。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>零散的说了一些Objective-C的特点，远远不足以讲明白Objective-C，我这只是根据Effective Objective-C这本书给个引子，还是推荐Apple的官方教程、文档，要想掌握扎实，还是要一步一步来~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;一直都在做项目，没什么时间作总结，感觉很不是滋味。现在放假了，嗯，终于有时间了~~哈哈（天生程序猿一枚好不好=。=）&lt;br&gt;最近开始读英文版的Effective Objective-C 2.0，觉得不错，就总结些东西，分享给各位读者吧。&lt;/p&gt;
&lt;h2 id=&quot;Item-1-Familiarize-Yourself-with-Objective-C’s-Roots&quot;&gt;&lt;a href=&quot;#Item-1-Familiarize-Yourself-with-Objective-C’s-Roots&quot; class=&quot;headerlink&quot; title=&quot;Item 1 - Familiarize Yourself with Objective-C’s Roots&quot;&gt;&lt;/a&gt;Item 1 - Familiarize Yourself with Objective-C’s Roots&lt;/h2&gt;&lt;p&gt;第一章的目的，就是让大家熟悉Objective-C，自然，标题的意思也就是“了解Objective-C的基本概念”，不多说，开写。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="翻译" scheme="http://tutuge.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="笔记" scheme="http://tutuge.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>iOS项目的目录结构-原创</title>
    <link href="http://tutuge.me/2015/02/01/iOS%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84-%E5%8E%9F%E5%88%9B/"/>
    <id>http://tutuge.me/2015/02/01/iOS项目的目录结构-原创/</id>
    <published>2015-01-31T18:27:21.000Z</published>
    <updated>2018-10-07T17:37:29.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这段时间一直在做iOS的项目（<a href="https://itunes.apple.com/cn/app/qing-ju-yin-le-quan-guo-zui/id913235479?mt=8" target="_blank" rel="noopener">青桔音乐App</a>），随着代码量的上升，逐渐意识到项目的整体目录结构划分是多么重要，清晰的目录结构，能够更好的应对新的需求，更容易重构。虽然一直都是一个人在做=。=，但是还是深深地体会到目录结构的重要性。</p><a id="more"></a><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>说再多都不如来个例子实在，如下：(VC指的是viewController)</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">---General</span></span><br><span class="line">    |<span class="params">---AppDelegate</span></span><br><span class="line">    |<span class="params">---Application</span></span><br><span class="line">    |<span class="params">---Constant</span></span><br><span class="line">    |<span class="params">---UI</span></span><br><span class="line">        |<span class="params">---View</span></span><br><span class="line">        |<span class="params">---VC</span></span><br><span class="line">        <span class="string">...</span></span><br><span class="line">    |<span class="params">---Category</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">|<span class="params">---Entity</span></span><br><span class="line">    |<span class="params">---BaseEntity</span></span><br><span class="line">    |<span class="params">---UserEntity</span></span><br><span class="line">    |<span class="params">---CommentEntity</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">|<span class="params">---Http</span></span><br><span class="line">    |<span class="params">---Api</span></span><br><span class="line">    |<span class="params">---Manager</span></span><br><span class="line">    |<span class="params">---CodeHandler</span></span><br><span class="line">    |<span class="params">---ErrorHandler</span></span><br><span class="line">    |<span class="params">---HttpHandler</span></span><br><span class="line">        |<span class="params">---UserHttpHandler</span></span><br><span class="line">        |<span class="params">---CommentHttpHandler</span></span><br><span class="line">        <span class="string">...</span></span><br><span class="line">|<span class="params">---DB</span></span><br><span class="line">    |<span class="params">---DBHelper</span></span><br><span class="line">    |<span class="params">---DBService</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">|<span class="params">---Util</span></span><br><span class="line">    |<span class="params">---StringUtil</span></span><br><span class="line">    |<span class="params">---NumberUtil</span></span><br><span class="line">    |<span class="params">---TimeUtil</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">|<span class="params">---Service</span></span><br><span class="line">    |<span class="params">---AccountService</span></span><br><span class="line">    |<span class="params">---ShareService</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">|<span class="params">---Lib</span></span><br><span class="line">    |<span class="params">---Umeng</span></span><br><span class="line">    |<span class="params">---QQSDK</span></span><br><span class="line">    |<span class="params">---SVProgressHUD</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">|<span class="params">---Module</span></span><br><span class="line">    |<span class="params">---Login</span></span><br><span class="line">        |<span class="params">---View</span></span><br><span class="line">        |<span class="params">---VC</span></span><br><span class="line">        |<span class="params">---XIB</span></span><br><span class="line">    |<span class="params">---Comment</span></span><br><span class="line">        |<span class="params">---View</span></span><br><span class="line">        |<span class="params">---VC</span></span><br><span class="line">        |<span class="params">---XIB</span></span><br><span class="line">        |<span class="params">---Business</span></span><br><span class="line">    |<span class="params">---Feeds</span></span><br><span class="line">    <span class="string">...</span></span><br></pre></td></tr></table></figure><p>乍一看好多，别被吓到=。=，容我细细讲解。</p><h2 id="详细讲解"><a href="#详细讲解" class="headerlink" title="详细讲解"></a>详细讲解</h2><h3 id="General"><a href="#General" class="headerlink" title="General"></a>General</h3><p>General好理解，放的就是如AppDelegate之类的、项目中最普通的、最常用的组件。</p><p><strong>AppDelegate</strong>:</p><p>App的Delegate类实现，这个必须有，就不用说了吧。</p><p><strong>Application</strong>:</p><p>如果自定义实现了Application类，就放在这里。</p><p><strong>Constant</strong>:</p><p>顾名思义，常量，项目用到的所有公共常量，如enum枚举类型的、Notification的Tag，常用的颜色、字符串等等等，都可以按照自己的需求划分不同的Group，放到Constant里面。</p><p><strong>UI</strong>:</p><p>项目中自定义的UIView、UIViewController子类之类的代码，就对应放在UI下的View、VC中。</p><p><strong>Category</strong>:</p><p>对系统类做的扩展，各种Category，如<code>NSString+XXXExtension</code>这种，就统一放在Category目录下。</p><p>如还有其他的通用组件，也不妨放到这里，做统一的管理。</p><hr><h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><p>Entity，也有人喜欢叫Model（关于Entity和Model的区别，推荐看看<a href="http://blogsh.de/2011/09/08/models-vs-entities/" target="_blank" rel="noopener">这篇文章</a>，个人觉得研究研究Entity和Model概念的区别还是很有好处的），就是程序中的“实体”，如一个用户、一条评论、一首歌等等，简单来说就是一个独立“个体”的集合、打包，具体的自己查查吧，网上一大堆的，感觉跟JavaBean的概念比较像。</p><p>通常来说，每个Entity类都比较简单，只包含若干个属性。但是有时候可能要做统一的处理，如，在从服务器取回的JSON数据解包成具体的Entity类，并且执行一系列初始化操作等等，所以可能要对所有的Entity类做统一处理。所以说，可以定制相应的BaseEntity基类，利用模板方法等办法，定制统一的初始化流程（好像扯远了=。=，这个后面会详细写篇东西分享给大家），BaseEntity就是放这些基类的东西的。</p><p>有了BaseEntity后，对应的各个业务中的具体Entity，如UserEntity、CommentEntity，就可以分门别类的建立单独的Group存放。</p><hr><h3 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h3><p>这个Group里面放跟网络请求相关的东西，详细如下：</p><p><strong>Api</strong>:</p><p>互联网应用少不了跟服务器打交道的各种网络接口，所以我在项目中把所有的API对应的相对URL地址、参数注释要求等等都放在了这里，好统一管理。</p><p><strong>Manager</strong>:</p><p>定义最基本的网络请求，如GET、POST、PUT等请求的基本封装，获取图片的基本封装。<br>一般来说就是定制统一的基本请求接口，对上层提供一致、稳定的服务，真正的网络请求，可以自己用iOS原生的Api写，也可以用AFNetworking等第三方库做封装，图片也可以灵活的用AFNetworking、SDWebImage这些优秀的库实现。还有就是，可以方便的统一对请求做处理，如错误处理、Http的Code、状态处理等等。还可以统一的增加请求参数，如统一为每个请求都增加用户的ID、token什么的。</p><p><strong>CodeHandler</strong></p><p>大部分的API设计都会有相应的状态码、Code，为了方便扩展，可以把这些处理Code的类单独放在这里。</p><p><strong>ErrorHandler</strong></p><p>这个就少不了了，对Http的错误进行单独处理，加Log什么的。</p><p><strong>HttpHandler</strong></p><p>这个Group里面放的是真正实现接口的类，如什么UserHttpHandler、CommentHttpHandler之类的，就是具体实现了接口调用、处理返回数据、回调的类。</p><p>Http里面的各个Group的类其实都是相互关联的，设计的时候可以定制统一的接口（Protocol），然后创建类实现（conform）这些接口，也就是面向接口的编程，以最大限度的减少接口层的各个职能之间的耦合，方便扩展。</p><hr><h3 id="DB"><a href="#DB" class="headerlink" title="DB"></a>DB</h3><p>介于iOS的SQLite不是那么好用，所以非常有必要为操作数据库的类建立单独的地盘=。=</p><p><strong>DBHelper</strong>:</p><p>放基础的操作数据库的类，如简单的查找、插入、更新、事务更新等等操作，为负载的数据库业务逻辑封装底层接口。比如对流行的FMDB进行封装等等。</p><p><strong>DBService</strong>:</p><p>这里放具体的数据库业务实现类，至于为什么叫“Service”，因为我也想不出什么好的名字了=。= 按照自己的业务逻辑组织即可。</p><hr><h3 id="Util"><a href="#Util" class="headerlink" title="Util"></a>Util</h3><p>放常用的工具类的地方。如字符串操作的类StringUtil、时间计算格式化类TimeUtil等，按具体需求而定，这个就不用多说了吧。</p><hr><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>项目的需求多了，业务逻辑的代码就会越来越多，总不能都放在view controller里面吧。一些多处用到的，或者非常独立的业务代码，完全可以抽离出来，实现为单独的、跟界面无关的业务类。因为做的事很杂，所以干脆就叫Service了。</p><p><strong>AccountService</strong>、<strong>ShareService</strong>就是这种类。而且大部分的Service都应该是单例类，如<strong>AccountService</strong>类可能维护着程序运行期间的账户信息，<strong>ShareService</strong>对程序的分享功能做了统一处理等等，具体怎么用就随各位了。</p><hr><h3 id="Lib"><a href="#Lib" class="headerlink" title="Lib"></a>Lib</h3><p>Lib，放各种第三方库，因项目需要修改过的第三方组件等，像什么友盟、QQSDK之类的就可以放这。当然，一些不会做改动的库最好还是用CocoaoPod做统一管理。</p><hr><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>终于讲到了最重要的地方。</p><p>iOS工程中最多的文件往往就是各种View、ViewController类，以前总是看到有人只创建两个Group，一个叫Views，另一个叫ViewControllers，然后所有的Views、ViewController都往里面塞，然后随着需求的增加，这两个Group也臃肿不堪。。。</p><p><strong>办法总是有的。就是为工程划分模块-Module</strong></p><p>如何划分Module？我认为，可以按照以下两点建立：</p><ol><li>以页面跳转分支划分。</li><li>以功能划分。</li></ol><p><strong>以页面跳转分支划分</strong></p><p>就是按照应用的页面设计与业务逻辑，从最顶级开始，一级一级页面往下跳转，找出其中的独立分支，归为一个Module模块。<br>举例来说，应用主界面有4个Tab页，就先分出四个Module，然后一级一级往下跳转，遇到分支就建立新的Module，如此递归的建立，就能大致划分出各个Module。当然，这么做是最粗糙的，还要根据情况，将不同的分支Module合并成一个Module，简化代码的组成。我在这只是提供个划分Module的方法，具体怎么设计就看各位读者了=。=</p><p><strong>以功能划分</strong></p><p>这个好理解，无非就是根据前期项目的功能模块划分工程的代码Module组成。如什么用户设置Module、评论Module、登录Module等等。</p><p>总的来数，就是要用Module将工程的代码分类管理，每个Module具有大致相同的结构，如都可能有本Module用到的View、ViewController，自定义的类Class等等，就是说，按照职能对代码划分，避免将所有的类都堆在一起，也好应对新的需求。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>啰啰嗦嗦说了一大堆，想必各位都看烦了吧=。=刚开始写博客，写到一个地方，又会引出另一块，写着写着容易写偏了。</p><p>写之前我也大致搜了一下，发现网上相关的资料好少，但是实际的经验告诉我，项目工程的目录结构非常重要，无论是对开发还是对后期的维护，所以想着应该写篇东西，分享我自己的经验给大家，有啥问题，多提意见啊~~~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这段时间一直在做iOS的项目（&lt;a href=&quot;https://itunes.apple.com/cn/app/qing-ju-yin-le-quan-guo-zui/id913235479?mt=8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;青桔音乐App&lt;/a&gt;），随着代码量的上升，逐渐意识到项目的整体目录结构划分是多么重要，清晰的目录结构，能够更好的应对新的需求，更容易重构。虽然一直都是一个人在做=。=，但是还是深深地体会到目录结构的重要性。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/categories/iOS/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Android开源库-LinkTextView-原创</title>
    <link href="http://tutuge.me/2014/11/02/LinkTextView-Android%E5%BC%80%E6%BA%90%E5%BA%93-%E5%8E%9F%E5%88%9B/"/>
    <id>http://tutuge.me/2014/11/02/LinkTextView-Android开源库-原创/</id>
    <published>2014-11-01T18:34:46.000Z</published>
    <updated>2018-10-07T17:37:29.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近来因为项目的缘故，仔细研究了一下如何在Android的TextView里面绑定可以点击的链接，并且定制链接的颜色，包括正常状态、按下去时的文字、背景的颜色，当然，还有点击后的回调。</p><p>为了以后方便自己，也为了方便更多的人，就把这些封装成了一个简单的开源库，也算是我自己的<strong><em>第一个开源库</em></strong>吧。</p><h2 id="LinkTextView"><a href="#LinkTextView" class="headerlink" title="LinkTextView"></a>LinkTextView</h2><p>名称：<a href="https://github.com/zekunyan/LinkTextView" target="_blank" rel="noopener">LinkTextView</a>。喜欢的话就Star一下吧。</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><img src="/2014/11/02/LinkTextView-Android开源库-原创/LinkTextView_Sample.gif" alt="示例"></p><a id="more"></a><h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：<br></h3><ol><li>可以方便的对TextView里面的文字增加可点击链接，并且绑定回调。</li><li>可以为每个链接<strong>单独</strong>设置<strong>文字</strong>、链接<strong>背景</strong>的<strong>正常</strong>、<strong>按下</strong>状态下的颜色。</li><li>可以为每个链接绑定任意类型的“附件”对象，作为点击链接时的回调参数。</li></ol><h2 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h2><p>下面分重点讲解一下。</p><h3 id="1-为文字增加可点击链接，绑定回调。"><a href="#1-为文字增加可点击链接，绑定回调。" class="headerlink" title="1. 为文字增加可点击链接，绑定回调。"></a>1. 为文字增加可点击链接，绑定回调。</h3><p>为文字增加链接，已经是老生常谈了，真是一搜一大把，不过在这里还是简单讲一下。</p><p>用过TextView应该都知道这个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setText</span> <span class="params">(CharSequence text)</span></span></span><br></pre></td></tr></table></figure><p>其中CharSequence接口的子接口里面有Spannable，而由这个接口派生出来的类SpannableString，就是我们可以对TextView里面的文字做附加效果的原因。如改变颜色、增加超链接等，有兴趣的各位可以去仔细查查。下面简单的说说怎么加可点击的链接。</p><p><strong>首先创建SpannableString</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpannableString text = <span class="keyword">new</span> SpannableString(<span class="string">"LinkTextView dadada"</span>);</span><br></pre></td></tr></table></figure><p><strong>绑定ClickableSpan回调</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ClickableSpan clickableSpan = <span class="keyword">new</span> ClickableSpan() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//点击了链接，做你想干的事吧=。=</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">text.setSpan(clickableSpan, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><strong>最后再setText</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textView.setText(text);</span><br></pre></td></tr></table></figure><p>看，绑定可以点击的链接就是这么简单。</p><h3 id="2-改变正常、按下时的文字、链接背景颜色。"><a href="#2-改变正常、按下时的文字、链接背景颜色。" class="headerlink" title="2. 改变正常、按下时的文字、链接背景颜色。"></a>2. 改变正常、按下时的文字、链接背景颜色。</h3><p>往往系统默认的链接颜色是不能满足我们的需求的，所以最好能对链接的文字、背景的按下、松开时的颜色做定制。</p><p><strong><em>但是好坑=。=，Google居然没有为ClickableSpan增加按下时的回调</em></strong></p><p>那就只好自己造轮子了。</p><h4 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h4><p>必须要能获取到链接按下时的回调，应该是onTouch什么的，于是，就查到了类：LinkMovementMethod。<br>在TextView中可以用方法：public final void setMovementMethod (MovementMethod movement)设定监听，而LinkMovementMethod类里面就可以监听到链接的onTouch！</p><p><strong>LinkMovementMethod的onTouch就是介个样子的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(TextView textView, Spannable spannable, MotionEvent event)</span></span></span><br></pre></td></tr></table></figure><p>于是，我们可以通过event来判断是按下还是移动等等操作。<br>但是问题是，这里的spannable是整个TextView全部的文字，所以，只能通过event里面的x、y坐标，找到具体点击的是哪个链接。这里，要感谢stack overflow上的大神的<a href="http://stackoverflow.com/questions/20856105/change-the-text-color-of-a-clickablespan-when-pressed" target="_blank" rel="noopener">帖子</a>。</p><p>具体的找点击链接的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TouchableSpan <span class="title">getPressedSpan</span><span class="params">(TextView textView, Spannable spannable, MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取点击的x、y坐标</span></span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">    <span class="comment">//减去Padding</span></span><br><span class="line">    x -= textView.getTotalPaddingLeft();</span><br><span class="line">    y -= textView.getTotalPaddingTop();</span><br><span class="line">    <span class="comment">//加上滚动的偏移</span></span><br><span class="line">    x += textView.getScrollX();</span><br><span class="line">    y += textView.getScrollY();</span><br><span class="line">    <span class="comment">//获取第几行、以及偏移</span></span><br><span class="line">    Layout layout = textView.getLayout();</span><br><span class="line">    <span class="keyword">int</span> line = layout.getLineForVertical(y);</span><br><span class="line">    <span class="keyword">int</span> off = layout.getOffsetForHorizontal(line, x);</span><br><span class="line">    <span class="comment">//获取真正点击的链接</span></span><br><span class="line">    TouchableSpan[] link = spannable.getSpans(off, off, TouchableSpan.class);</span><br><span class="line">    TouchableSpan touchedSpan = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (link.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        touchedSpan = link[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> touchedSpan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，我们已经能获取到链接的点击状态，并且捕捉到具体点击的ClickableSpan。</p><h4 id="接着"><a href="#接着" class="headerlink" title="接着"></a>接着</h4><p>就是改变链接的文字、背景颜色。</p><p>ClickableSpan的方法里面，除了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View widget)</span></span>;</span><br></pre></td></tr></table></figure><p>还有就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDrawState</span><span class="params">(TextPaint textPaint)</span></span>;</span><br></pre></td></tr></table></figure><p>很明显，就是更新文字渲染效果的。我们用如下两个方法，就能实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span> <span class="params">(<span class="keyword">int</span> color)</span></span>;</span><br><span class="line">bgColor属性</span><br></pre></td></tr></table></figure><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>到目前为止，我们已经可以捕捉到链接的点击状态，能获取到真正的点击的链接，还有能刷新链接的颜色了，相信聪明的你一定能自己琢磨出来，怎么样实现文章开头的效果。=v=</p><h4 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h4><ol><li>Android官方文档。</li><li>StackOverFlow的：<a href="http://stackoverflow.com/questions/20856105/change-the-text-color-of-a-clickablespan-when-pressed" target="_blank" rel="noopener">Change the text color of a ClickableSpan when pressed。</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;近来因为项目的缘故，仔细研究了一下如何在Android的TextView里面绑定可以点击的链接，并且定制链接的颜色，包括正常状态、按下去时的文字、背景的颜色，当然，还有点击后的回调。&lt;/p&gt;
&lt;p&gt;为了以后方便自己，也为了方便更多的人，就把这些封装成了一个简单的开源库，也算是我自己的&lt;strong&gt;&lt;em&gt;第一个开源库&lt;/em&gt;&lt;/strong&gt;吧。&lt;/p&gt;
&lt;h2 id=&quot;LinkTextView&quot;&gt;&lt;a href=&quot;#LinkTextView&quot; class=&quot;headerlink&quot; title=&quot;LinkTextView&quot;&gt;&lt;/a&gt;LinkTextView&lt;/h2&gt;&lt;p&gt;名称：&lt;a href=&quot;https://github.com/zekunyan/LinkTextView&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LinkTextView&lt;/a&gt;。喜欢的话就Star一下吧。&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;&lt;a href=&quot;#Example&quot; class=&quot;headerlink&quot; title=&quot;Example&quot;&gt;&lt;/a&gt;Example&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2014/11/02/LinkTextView-Android开源库-原创/LinkTextView_Sample.gif&quot; alt=&quot;示例&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://tutuge.me/categories/Android/"/>
    
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="Android" scheme="http://tutuge.me/tags/Android/"/>
    
      <category term="开源" scheme="http://tutuge.me/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>第一篇Blog</title>
    <link href="http://tutuge.me/2014/11/01/%E7%AC%AC%E4%B8%80%E7%AF%87Blog/"/>
    <id>http://tutuge.me/2014/11/01/第一篇Blog/</id>
    <published>2014-10-31T16:13:15.000Z</published>
    <updated>2018-10-07T17:37:29.550Z</updated>
    
    <content type="html"><![CDATA[<p>拖了很久，终于开始写博客了。<br>一直觉得自己的知识储备不够，一直都在学习，一直都在积累。（其实就是懒好吗=。=）</p><p>说点啥呢，想到啥就说啥吧~</p><a id="more"></a><p>从小就喜欢模型、乐高积木，喜欢拆东西，印象最深的就是把家里的高级录音机拆了，装不回去，塞到了床底下。。。</p><p>上了学之后，又开始捣鼓四驱车，自己做马达，绕线圈，家里零件一大堆，串联一堆电池，组装遥控车，唯一的遗憾，就是没有做成遥控飞机（没钱=、=）。</p><p>接着，家里有了电脑！！！这要感谢老爹，当时花了一万多，液晶显示器，刚上市的奔腾4啊！</p><p>于是，我又开始拆电脑。。。换显卡、超频，跑分，再超频，再跑分，3DMark就是俺的祖宗啊~</p><p>终于，走上了<strong>编程</strong>这条“<strong>不归路</strong>”，义无反顾，一直到了现在。</p><p>用Dev-C++折腾C语言，数据结构、算法，接着又是C++，Window API，QT（这个真觉得不错），MFC（软件课设），Java，Python，Android（上线了几个小应用，拿了Google全国大学生Android应用开发大赛华中地区三等奖），iOS（上线应用，青桔音乐），Linux，还有各种MySQL、MongoDB等数据库的纠结，看各种博客。。。</p><p>每天看的很多，想的也不少，但是终究不够精通，路还很长啊~</p><p>当然，最感谢的就是我的女朋友~陈因素~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;拖了很久，终于开始写博客了。&lt;br&gt;一直觉得自己的知识储备不够，一直都在学习，一直都在积累。（其实就是懒好吗=。=）&lt;/p&gt;
&lt;p&gt;说点啥呢，想到啥就说啥吧~&lt;/p&gt;
    
    </summary>
    
      <category term="其它" scheme="http://tutuge.me/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="杂烩" scheme="http://tutuge.me/tags/%E6%9D%82%E7%83%A9/"/>
    
  </entry>
  
</feed>
