<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[土土哥的技术Blog]]></title>
  <subtitle><![CDATA[iOS,Android程序猿一枚,喜欢Mac、Linux、各种开源技术，各种语言]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://tutuge.me/"/>
  <updated>2015-10-26T09:08:15.000Z</updated>
  <id>http://tutuge.me/</id>
  
  <author>
    <name><![CDATA[燕泽堃]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Swift开源项目: TTGEmojiRate的实现]]></title>
    <link href="http://tutuge.me/2015/10/25/ttgemojirate-lib/"/>
    <id>http://tutuge.me/2015/10/25/ttgemojirate-lib/</id>
    <published>2015-10-25T11:32:42.000Z</published>
    <updated>2015-10-26T09:08:15.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>前段时间在Dribbble上发现了一个<a href="https://dribbble.com/shots/2211556-Rating-Version-A" target="_blank" rel="external">Rating控件</a>的演示动画，控件以Emoji表情为基础，结合了上下滑动手势，正好最近正在深入学习iOS动画、绘图相关的知识，就尝试着用<code>UIBezierPath</code>实现了出来。本文就是TTGEmojiRate的实现过程。</p>
<p>Github: <a href="https://github.com/zekunyan/TTGEmojiRate" target="_blank" rel="external">https://github.com/zekunyan/TTGEmojiRate</a></p>
<p><img src="http://7nj2iz.com1.z0.glb.clouddn.com/TTGEmojiRate_screenshot2.gif" alt="TTGEmojiRate Example"></p>
<a id="more"></a>
<h2 id="分析">分析</h2><p>先看看原本的效果：<a href="https://dribbble.com/shots/2211556-Rating-Version-A" target="_blank" rel="external">Rating Version A - Hoang Nguyen</a></p>
<p><img src="http://7nj2iz.com1.z0.glb.clouddn.com/TTGEmojiRate_Dribbble.gif" alt="Rating Version A - Hoang Nguyen"></p>
<p>可以看出来，主要的特点如下：</p>
<ul>
<li>可以上下拖动，改变Emoji表情嘴的弧度。</li>
<li>拖动的时候Rate的值也会随之变化，从0到5，并且跟表情的“喜怒”相对应。</li>
<li>颜色也会变化，从绿色到蓝色再到红色，也对应表情的“喜怒”。</li>
</ul>
<p>实际实现的时候，增加了眼睛元素，并且增强了自定义，如颜色的变化范围、线条的粗细等都可以设定，基本的思路还是不变的。</p>
<h2 id="实现">实现</h2><h3 id="思路">思路</h3><p>开始写代码之前，先理理思路。<br>拖动的时候，直接影响的应该是Rate值，然后在Rate值改变的时候刷新整个控件，刷新的时候重绘。重绘的时候，嘴、眼睛的弧度，颜色的值都要根据Rate值重新计算，如下图：</p>
<p><img src="http://7nj2iz.com1.z0.glb.clouddn.com/blog_ttgemojirate_1.png" alt="Image"></p>
<h3 id="拖动改变Rate值">拖动改变Rate值</h3><p>这个还是很容易实现的，直接重写<code>UIView</code>的touch相关的三个方法，在里面记录拖动在Y轴上的变化值，然后映射到Rate值上就可以了。</p>
<p>先声明一个CGPoint属性，用来保存手指按下时的点位置：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> touchPoint: CGPoint? = <span class="keyword">nil</span></span><br></pre></td></tr></table></figure></p>
<p>在手指移动的时候，在<code>touchesMoved</code>方法里面计算当前点跟上一次触摸点的Y轴上的<strong>差值</strong>，然后映射到Rate值上。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">touchesMoved</span><span class="params">(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前触摸点</span></span><br><span class="line">    <span class="keyword">let</span> currentPoint = touches.first?.locationInView(<span class="keyword">self</span>)</span><br><span class="line">    <span class="comment">// 改变Rate值</span></span><br><span class="line">    rateValue = rateValue + <span class="type">Float</span>((currentPoint!.y - touchPoint!.y) / <span class="type">CGRectGetHeight</span>(<span class="keyword">self</span>.bounds) * rateDragSensitivity)</span><br><span class="line">    <span class="comment">// 保存当前触摸点</span></span><br><span class="line">    touchPoint = currentPoint</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：</p>
<ul>
<li>计算Y轴差值的时候，除以了当前控件的高度，这是为了保证Rate值按比例增减。</li>
<li>增加了一个<code>rateDragSensitivity</code>属性，用来调节改变Rate值的“灵敏度”</li>
</ul>
<h3 id="UIBezierPath_-_贝塞尔曲线">UIBezierPath - 贝塞尔曲线</h3><p>控件的主要内容都是用<code>UIBezierPath</code>绘制出来的。网上关于<code>UIBezierPath</code>的讲解很多，在这里就不详细说了。<br>简单来说，<code>UIBezierPath</code>用来绘制矢量路径，是一种参数曲线，在使用的时候，只需要先设定好锚点、控制点，系统就可以根据贝塞尔曲线的算法，绘制出对应的线，并且保证锚点和对应的控制点的连线与曲线相切。<br>这里有一个演示绘制贝塞尔曲线过程的网站：<a href="http://myst729.github.io/bezier-curve/" target="_blank" rel="external">Bézier curve</a></p>
<h3 id="脸">脸</h3><p>脸是最简单的，就是一个圆，直接用一个方法就可以：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="func"><span class="keyword">func</span> <span class="title">drawFaceWithRect</span><span class="params">(rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> facePath = <span class="type">UIBezierPath</span>(ovalInRect: rect)</span><br><span class="line">    rateColor.setStroke()</span><br><span class="line">    facePath.lineWidth = rateLineWidth <span class="comment">// 线粗细</span></span><br><span class="line">    facePath.stroke()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际实现的时候可以加上Margin，防止线画到View的边界之外。</p>
<h3 id="嘴、眼睛">嘴、眼睛</h3><p>先看看<code>UIBezierPath</code>提供的可以用来绘制曲线的方法：<br><code>addCurveToPoint(_:controlPoint1:controlPoint2:)</code>和<code>addQuadCurveToPoint(_:controlPoint:)</code>，如下图:</p>
<p><img src="http://7nj2iz.com1.z0.glb.clouddn.com/blog_ttgemojirate_2.png" alt="UIBezierPath"></p>
<p>直观上来讲，嘴、眼睛的绘制跟<code>addQuadCurveToPoint</code>方法绘制的效果基本一致，但是这样的效果没法调整，因为只能控制唯一的一个控制点，所以还是要用<code>addCurveToPoint</code>方法，对称的绘制两条曲线，拼接起来，如下图：</p>
<p><img src="http://7nj2iz.com1.z0.glb.clouddn.com/blog_ttgemojirate_3.png" alt="Curve拼接"></p>
<p>这样的话，就可以通过调整两个控制点，来控制嘴、眼睛的弯曲宽度、形状。</p>
<p>以绘制嘴为例：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> func drawMouthWithRect(<span class="built_in">rect</span>: CGRect) &#123;</span><br><span class="line">    let <span class="variable">width</span> = CGRectGetWidth(<span class="built_in">rect</span>)</span><br><span class="line">    let <span class="variable">height</span> = CGRectGetWidth(<span class="built_in">rect</span>)        </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左端点</span></span><br><span class="line">    let leftPoint = CGPointMake(</span><br><span class="line">        <span class="variable">width</span> * (<span class="number">1</span> - rateMouthWidth) / <span class="number">2</span>,</span><br><span class="line">        <span class="variable">height</span> * (<span class="number">1</span> - rateMouthVerticalPosition))        </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右端点</span></span><br><span class="line">    let rightPoint = CGPointMake(</span><br><span class="line">        <span class="variable">width</span> - leftPoint.x,</span><br><span class="line">        leftPoint.y)        </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中间点 - Y值根据当前的Rate值计算，0.3为系数</span></span><br><span class="line">    let centerPoint = CGPointMake(</span><br><span class="line">        <span class="variable">width</span> / <span class="number">2</span>,</span><br><span class="line">        leftPoint.y + <span class="variable">height</span> * <span class="number">0.3</span> * (CGFloat(rateValue) - <span class="number">2.5</span>) / <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制点跟中间点在X轴上的距离</span></span><br><span class="line">    let halfLipWidth = <span class="variable">width</span> * rateMouthWidth * rateLipWidth / <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建贝塞尔曲线</span></span><br><span class="line">    let mouthPath = UIBezierPath()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动到起始点</span></span><br><span class="line">    mouthPath.moveToPoint(leftPoint)        </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加左半边曲线路径</span></span><br><span class="line">    mouthPath.addCurveToPoint(</span><br><span class="line">        centerPoint,</span><br><span class="line">        controlPoint1: leftPoint,</span><br><span class="line">        controlPoint2: CGPointMake(centerPoint.x - halfLipWidth, centerPoint.y))        </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加右半边曲线路径</span></span><br><span class="line">    mouthPath.addCurveToPoint(</span><br><span class="line">        rightPoint,</span><br><span class="line">        controlPoint1: CGPointMake(centerPoint.x + halfLipWidth, centerPoint.y),</span><br><span class="line">        controlPoint2: rightPoint)        </span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 设定样式</span></span><br><span class="line">    mouthPath.lineCapStyle = CGLineCap.Round;</span><br><span class="line">    rateColor.setStroke()</span><br><span class="line">    mouthPath.lineWidth = rateLineWidth</span><br><span class="line">    mouthPath.<span class="built_in">stroke</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>说明：</p>
<ul>
<li>所有的距离、坐标都是根据当前控件的大小计算出来的。</li>
<li><code>rateMouthWidth</code>为嘴的宽度与整个控件宽度的比值，即相对值。</li>
<li><code>rateMouthVerticalPosition</code>为嘴的左右两个端点的Y轴坐标值，也为相对值。</li>
<li><code>rateLipWidth</code>为中心点的两个控制点的距离与嘴宽度的比值，也是相对值。</li>
</ul>
<p>眼睛的绘制跟嘴原理一致，就不再说明。</p>
<h3 id="颜色的渐变">颜色的渐变</h3><p>Dribbble的演示中，控件的线条颜色也是会变化的，从红色到蓝色再到绿色，是连续变化的。这个时候用常见的<strong>RGB色彩模式</strong>是不好控制的，效果也不好。  </p>
<p>所以这个时候要用<strong>HSB色彩模式</strong>  </p>
<blockquote>
<p>HSB 色彩模式是基于人眼的一种颜色模式。是普及型设计软件中常见的色彩模式，其中H代表色相；S代表饱和度；B代表亮度。- <a href="http://baike.baidu.com/view/1006662.htm" target="_blank" rel="external">百度百科</a></p>
</blockquote>
<p><img src="http://7nj2iz.com1.z0.glb.clouddn.com/blog_ttgemojirate_4.jpg?imageView2/1/w/240/h/192" alt="HSB色彩模式"></p>
<p>对应到<code>UIColor</code>类，就是下面两个方法：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建UIColor</span></span><br><span class="line">init(<span class="built_in">hue</span> <span class="built_in">hue</span>: CGFloat, <span class="built_in">saturation</span> <span class="built_in">saturation</span>: CGFloat, <span class="built_in">brightness</span> <span class="built_in">brightness</span>: CGFloat, <span class="built_in">alpha</span> <span class="built_in">alpha</span>: CGFloat)</span><br><span class="line"><span class="comment">// 获取HSB值，注意参数</span></span><br><span class="line">func getHue(_ <span class="built_in">hue</span>: UnsafeMutablePointer&lt;CGFloat&gt;, <span class="built_in">saturation</span> <span class="built_in">saturation</span>: UnsafeMutablePointer&lt;CGFloat&gt;, <span class="built_in">brightness</span> <span class="built_in">brightness</span>: UnsafeMutablePointer&lt;CGFloat&gt;, <span class="built_in">alpha</span> <span class="built_in">alpha</span>: UnsafeMutablePointer&lt;CGFloat&gt;) -&gt; Bool</span><br></pre></td></tr></table></figure></p>
<p>实现的时候，为了增加可定制性，控件颜色的变化范围是可以设置的，用以下属性保存：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> var <span class="string">rateColorRange:</span> (<span class="string">from:</span> UIColor, <span class="string">to:</span> UIColor)</span><br></pre></td></tr></table></figure></p>
<p>刷新时，就可以根据当前的Rate值，重新计算颜色的HSB和alpha值：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let rate: <span class="built_in">CGFloat</span> = <span class="built_in">CGFloat</span>(rateValue / <span class="number">5</span>) <span class="comment">// Rate值归一化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span><span class="variable">.rateColor</span> = <span class="built_in">UIColor</span><span class="variable">.init</span>(</span><br><span class="line">    hue: hueFrom + hueDelta * rate, <span class="comment">// 色相</span></span><br><span class="line">    saturation: saturationFrom + saturationDelta * rate, <span class="comment">// 饱和度</span></span><br><span class="line">    brightness: brightnessFrom + brightnessDelta * rate, <span class="comment">// 亮度</span></span><br><span class="line">    alpha: alphaFrom + alphaDelta * rate <span class="comment">// 透明度</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>说明：</p>
<ul>
<li>所有的颜色参数都是根据Rate值做线性增减。</li>
<li><code>xxxFrom</code>、<code>xxxDelta</code>分别指HSB和alpha的起始值与变化范围，在设置<code>rateColorRange</code>时计算保存下来。</li>
</ul>
<p>这样，颜色就能做到跟Rate值做连续的线性变化。</p>
<h3 id="善于使用didSet">善于使用didSet</h3><p>实现控件的时候，对外暴露了很多属性，如线的宽度<code>rateLineWidth</code>、嘴的宽度<code>rateMouthWidth</code>等。为了对这些属性做校验，并且在设置后刷新控件，就要用到<code>didSet</code>。</p>
<p><code>didSet</code>在Swift里面，跟类的属性是一一绑定的，在对属性赋值后会被调用。</p>
<p>控件的大部分属性都做了校验、刷新，如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Mouth width. From 0.2 to 0.7.</span></span><br><span class="line">@IBInspectable <span class="keyword">public</span> var rateMouthWidth: CGFloat = <span class="number">0.6</span> &#123;</span><br><span class="line">    didSet &#123;</span><br><span class="line">        <span class="comment">// 判断上限</span></span><br><span class="line">        <span class="keyword">if</span> rateMouthWidth &gt; <span class="number">0.7</span> &#123;</span><br><span class="line">            rateMouthWidth = <span class="number">0.7</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断下限</span></span><br><span class="line">        <span class="keyword">if</span> rateMouthWidth &lt; <span class="number">0.2</span> &#123;</span><br><span class="line">            rateMouthWidth = <span class="number">0.2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 刷新、重绘</span></span><br><span class="line">        self.setNeedsDisplay()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="@IBDesignable、@IBInspectable">@IBDesignable、@IBInspectable</h3><p>为了能在XIB、StoryBoard里面使用、编辑控件，就要用到<code>@IBDesignable</code>和<code>@IBInspectable</code>这两个关键字。</p>
<p>在类的前面加上<code>@IBDesignable</code>关键字，使IB可以预览控件：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@IBDesignable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmojiRateView</span>: <span class="typename">UIView &#123;</span></span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在属性前面加上<code>@IBInspectable</code>，就可以在IB里面编辑属性，实时预览：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@IBInspectable</span> <span class="keyword">public</span> var <span class="string">rateLineWidth:</span> CGFloat = <span class="number">14</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>详细的使用可以参考NSHipster上的文章：<a href="http://nshipster.cn/ibinspectable-ibdesignable/" target="_blank" rel="external">IBInspectable / IBDesignable</a></p>
<p>最后，在IB里面就是下面这样：<br><img src="http://7nj2iz.com1.z0.glb.clouddn.com/TTGEmojiRate_IBExample.png?imageView2/0/w/640" alt="IB example"></p>
<p><strong>By the way =。=</strong><br>属性名字太长，在IB里面显示不完整，咋办。。。</p>
<h3 id="回调">回调</h3><p>拖动改变Rate值的时候，肯定要有回调，如下定义：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="variable"><span class="keyword">var</span> rateValueChangeCallback</span>: ((newRateValue: <span class="typename">Float</span>) -&gt; <span class="typename">Void</span>)? = nil</span><br></pre></td></tr></table></figure></p>
<p>在<code>rateValue</code>的<code>didSet</code>里面回调：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@IBInspectable</span> <span class="keyword">public</span> <span class="keyword">var</span> rateValue: <span class="type">Float</span> = <span class="number">2.5</span> &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 回调</span></span><br><span class="line">        <span class="keyword">self</span>.rateValueChangeCallback?(newRateValue: rateValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结">总结</h2><p>看似简单的一个Rating控件，从构思到实现，再到完善，一点一点朝着完美去做，收获不少~</p>
<p>最后，Dribbble是个好地方，贝塞尔曲线好强大，XCode 7.1写Swift还是有点卡=。=</p>
<p>以上。</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B2%9D%E8%8C%B2%E6%9B%B2%E7%B7%9A" target="_blank" rel="external">维基百科 - 贝塞尔曲线</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/BezierPaths/BezierPaths.html" target="_blank" rel="external">Drawing Shapes Using Bézier Paths</a></li>
<li><a href="http://baike.baidu.com/view/1006662.htm" target="_blank" rel="external">HSB色彩模式</a></li>
<li><a href="http://nshipster.cn/ibinspectable-ibdesignable/" target="_blank" rel="external">IBInspectable / IBDesignable</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>前段时间在Dribbble上发现了一个<a href="https://dribbble.com/shots/2211556-Rating-Version-A">Rating控件</a>的演示动画，控件以Emoji表情为基础，结合了上下滑动手势，正好最近正在深入学习iOS动画、绘图相关的知识，就尝试着用<code>UIBezierPath</code>实现了出来。本文就是TTGEmojiRate的实现过程。</p>
<p>Github: <a href="https://github.com/zekunyan/TTGEmojiRate">https://github.com/zekunyan/TTGEmojiRate</a></p>
<p><img src="http://7nj2iz.com1.z0.glb.clouddn.com/TTGEmojiRate_screenshot2.gif" alt="TTGEmojiRate Example"></p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://tutuge.me/tags/Swift/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift写的库-TTGSnackbar]]></title>
    <link href="http://tutuge.me/2015/10/09/ttgsnackbar-lib/"/>
    <id>http://tutuge.me/2015/10/09/ttgsnackbar-lib/</id>
    <published>2015-10-09T11:49:09.000Z</published>
    <updated>2015-10-10T02:20:28.000Z</updated>
    <content type="html"><![CDATA[<h2 id="TTGSnackbar">TTGSnackbar</h2><p>国庆期间，用Swift写了个简单的控件库：TTGSnackbar，模仿Android的Snackbar。目前更新到了版本0.2.0。支持多种动画，增强了自定义。</p>
<p>Github: <a href="https://github.com/zekunyan/TTGSnackbar" target="_blank" rel="external">https://github.com/zekunyan/TTGSnackbar</a></p>
<p><img src="http://7nj2iz.com1.z0.glb.clouddn.com/TTGSnackbar_1.gif?refresh" alt="示例"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="TTGSnackbar">TTGSnackbar</h2><p>国庆期间，用Swift写了个简单的控件库：TTGSnackbar，模仿Android的Snackbar。目前更新到了版本0.2.0。支持多种动画，增强了自定义。</p>
<p>Github: <a h]]>
    </summary>
    
      <category term="Swift" scheme="http://tutuge.me/tags/Swift/"/>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[有趣的Autolayout示例2-Masonry实现]]></title>
    <link href="http://tutuge.me/2015/08/08/autolayout-example-with-masonry2/"/>
    <id>http://tutuge.me/2015/08/08/autolayout-example-with-masonry2/</id>
    <published>2015-08-07T16:55:52.000Z</published>
    <updated>2015-09-24T10:55:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>Masonry写的Autolayout示例又来了，仍然是三个小例子，分别是<strong>变高度的UITableViewCell、topLayoutGuide与bottomLayoutGuide，还有自定义的baseline</strong>，外加两个基本的知识点讲解，说不上“有趣”=。=，比较基础，写了很多，各位随意看看吧~</p>
<p>上一篇：<a href="http://tutuge.me/2015/05/23/autolayout-example-with-masonry/">有趣的Autolayout示例-Masonry实现</a></p>
<p>Github地址：<br><a href="https://github.com/zekunyan/AutolayoutExampleWithMasonry" target="_blank" rel="external">https://github.com/zekunyan/AutolayoutExampleWithMasonry</a></p>
<p><img src="http://7nj2iz.com1.z0.glb.clouddn.com/blog_autolayout_example_with_masonry2_1.gif" alt="Gif示例"></p>
<a id="more"></a>
<h2 id="知识点">知识点</h2><p>先讲讲两个知识点，很基础，但是很容易被忽略。</p>
<h3 id="坐标系、top、right、offset">坐标系、top、right、offset</h3><p>先看看Masonry的Github主页的示例代码：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UIEdgeInsets padding = UIEdgeInsetsMake(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.equalTo(superview.mas_top).<span class="keyword">with</span>.<span class="command">offset</span>(padding.top);</span><br><span class="line">    make.left.equalTo(superview.mas_left).<span class="keyword">with</span>.<span class="command">offset</span>(padding.left);</span><br><span class="line">    make.bottom.equalTo(superview.mas_bottom).<span class="keyword">with</span>.<span class="command">offset</span>(-padding.bottom);</span><br><span class="line">    make.right.equalTo(superview.mas_right).<span class="keyword">with</span>.<span class="command">offset</span>(-padding.right);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>代码的意思很简单，就是view1的上下左右边距为padding对应的值。</p>
<p>但是，为什么bottom、right的offset是<strong>负数</strong>呢？</p>
<p>其实无论是Autolayout还是直接写frame，最终的结果都是要把我们的控件按照正确的位置绘制在屏幕上，也就是说，在一个统一的坐标系下，如下：</p>
<p><img src="http://7nj2iz.com1.z0.glb.clouddn.com/blog_autolayout_example_with_masonry2_2.png" alt="坐标系"></p>
<p>而在Masonry里面，offset只是做了“加法”运算，举个例，上面的：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">make</span><span class="class">.top</span><span class="class">.equalTo</span>(<span class="tag">superview</span><span class="class">.mas_top</span>)<span class="class">.with</span><span class="class">.offset</span>(<span class="tag">padding</span><span class="class">.top</span>);</span><br></pre></td></tr></table></figure></p>
<p>其实等于下面的式子：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view1.top = superview.top + padding.top<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>转换到坐标系里面，即是：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view1顶部的y坐标 = superview顶部的y坐标 + padding.top<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>所以，如果我们想view1的bottom距底部间距为10，按照offset的“加法运算”，应该是下面这样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view1底部的y坐标 = superview底部的y坐标 + (-<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p>
<p>所以，代码里面的bottom的offset是负数。right也是一个道理。</p>
<p>总的来说，就是布局的时候，始终要在坐标系下考虑。</p>
<h3 id="约束的“等价”性">约束的“等价”性</h3><p>语文不好，还是用公式说明吧=。=<br>先看看Autolayout的基本公式：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewA-<span class="keyword">attribute</span> = viewB-<span class="keyword">attribute</span> * multiplier + <span class="keyword">constant</span></span><br></pre></td></tr></table></figure></p>
<p>这个公式，跟下面的是等价的：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewB-<span class="keyword">attribute</span> = (viewA-<span class="keyword">attribute</span> - <span class="keyword">constant</span>) / multiplier</span><br></pre></td></tr></table></figure></p>
<p>这个转换是如此的简单，小学生都会=。=，只是为了说明，我们在设置约束的时候，既可以从ViewA的角度考虑，也可以从ViewB的角度，两者完全<strong>等价</strong>！。</p>
<p>说白了就是：“ViewA跟ViewB相距10”和“ViewB跟ViewA相距10”是一样的，如下两段代码，效果是一样的（注意正负数）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// View2的顶部距离View1的底部10</span></span><br><span class="line">[view2 mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) &#123;</span><br><span class="line">    <span class="built_in">make</span>.top.equalTo(view1.mas_bottom).with.offset(<span class="number">10</span>);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// View1的底部距离View2的顶部10</span></span><br><span class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) &#123;</span><br><span class="line">    <span class="built_in">make</span>.bottom.equalTo(view2.mas_top).with.offset(-<span class="number">10</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>更进一步说，就是约束只是两个View之间的关系，对于系统来说，ViewA和ViewB的地位是<strong>平等</strong>的，我们设置约束的时候，没有<strong>主次</strong>之分。</p>
<p>所以，我们在设置约束的时候，要从“<strong>整体</strong>”、“<strong>宏观</strong>”上考虑，更好地把握布局，避免重复约束。</p>
<h2 id="Case_1:_变高UITableViewCell">Case 1: 变高UITableViewCell</h2><p>变高的UITableViewCell，这是个永恒的话题=。=</p>
<p>不用Autolayout的话，计算Cell的高度的时候，就只能用sizeThatFits等方法，加上各种“魔鬼”数据的margin、padding来手动拼凑出Cell的高度。这种方法非常耗时，并且难以调试。</p>
<p>有了Autolayout，就再也不用手动算高度了~</p>
<h3 id="UITableViewCell">UITableViewCell</h3><p>先看看Cell的约束。</p>
<h4 id="“自我约束”的Cell">“自我约束”的Cell</h4><p>既然要能让系统自己计算出Cell的高度，我们在设置约束的时候，就要让约束整体是“完整”、“自我约束”的。（这个很难用语言描述。。。）Cell里面的每一个View的大小、位置，都可以从约束中得到体现，而Cell的整体大小，也是从子View的约束综合计算得出的。</p>
<p>如下面的Cell：</p>
<p><img src="http://7nj2iz.com1.z0.glb.clouddn.com/blog_autolayout_example_with_masonry2_3.png" alt="Cell"></p>
<ol>
<li>左上角的图片固定大小。</li>
<li>标题的Label只显示一行，固定高度。</li>
<li>内容的Label根据内容决定高度。</li>
<li>两个Label宽度整体随着Cell的宽度变化。</li>
</ol>
<p>约束的设定如下：</p>
<p><img src="http://7nj2iz.com1.z0.glb.clouddn.com/blog_autolayout_example_with_masonry2_4.png" alt="约束示意"></p>
<p>关键点:  </p>
<ol>
<li>内容Label的bottom和Cell的contentView的约束不可以省，因为cell的高度要由内部的约束决定，所以上下左右的约束一个不能少。</li>
<li>内容Label的高度随着内容变化，即cell的高度随内容变化，这个时候可以设置Label的ContentHugging的优先级最高。</li>
</ol>
<h4 id="UILabel的preferredMaxLayoutWidth">UILabel的preferredMaxLayoutWidth</h4><p>Autolayout下，UILabel在多行显示时，有个很“坑”的属性需要设定，就是preferredMaxLayoutWidth。</p>
<p>定义如下:<br><em><br>This property affects the size of the label when layout constraints are applied to it. During layout, if the text extends beyond the width specified by this property, the additional text is flowed to one or more new lines, thereby increasing the height of the label.
</em></p>
<p>如果我们要使用Autolayout自动计算多行UILabel的高度，这个属性就必须在运行时指定，要不然系统计算不出UILabel的宽度，例如：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算UILabel的preferredMaxLayoutWidth值，多行时必须设置这个值，否则系统无法决定Label的宽度</span></span><br><span class="line">label.preferredMaxWidth = [UIScreen mainScreen].bounds.<span class="built_in">size</span>.<span class="variable">width</span> - margin - padding;</span><br></pre></td></tr></table></figure></p>
<p>手动计算宽度，感觉回到了没有Autolayout的时代=。=</p>
<h4 id="Cell的关键代码">Cell的关键代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Avatar - 头像</span></span><br><span class="line">_avatarImageView = [UIImageView <span class="keyword">new</span>];</span><br><span class="line">[self.contentView addSubview:_avatarImageView];</span><br><span class="line">[_avatarImageView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.width.and.height.equalTo(@<span class="number">44</span>); <span class="comment">// 宽高固定</span></span><br><span class="line">    make.left.and.top.equalTo(self.contentView).with.offset(<span class="number">4</span>);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Title - 单行</span></span><br><span class="line">_titleLabel = [UILabel <span class="keyword">new</span>];</span><br><span class="line">[self.contentView addSubview:_titleLabel];</span><br><span class="line">[_titleLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.height.equalTo(@<span class="number">22</span>); <span class="comment">// 宽高固定</span></span><br><span class="line">    make.top.equalTo(self.contentView).with.offset(<span class="number">4</span>);</span><br><span class="line">    make.left.equalTo(_avatarImageView.mas_right).with.offset(<span class="number">4</span>);</span><br><span class="line">    make.right.equalTo(self.contentView).with.offset(-<span class="number">4</span>);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算UILabel的preferredMaxLayoutWidth值，多行时必须设置这个值，否则系统无法决定Label的宽度</span></span><br><span class="line">CGFloat preferredMaxWidth = [UIScreen mainScreen].bounds.size.width - (<span class="number">16</span> + <span class="number">4</span>) * <span class="number">2</span> - <span class="number">44</span> - <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Content - 多行</span></span><br><span class="line">_contentLabel = [UILabel <span class="keyword">new</span>];</span><br><span class="line">_contentLabel.numberOfLines = <span class="number">0</span>;</span><br><span class="line">_contentLabel.preferredMaxLayoutWidth = preferredMaxWidth; <span class="comment">// 多行时必须设置</span></span><br><span class="line">[self.contentView addSubview:_contentLabel];</span><br><span class="line"></span><br><span class="line">[_contentLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.equalTo(_titleLabel.mas_bottom).with.offset(<span class="number">4</span>);</span><br><span class="line">    make.left.equalTo(_avatarImageView.mas_right).with.offset(<span class="number">4</span>);</span><br><span class="line">    make.right.equalTo(self.contentView).with.offset(-<span class="number">4</span>);</span><br><span class="line">    make.bottom.equalTo(self.contentView).with.offset(-<span class="number">4</span>);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 设置高度的Content Hugging</span></span><br><span class="line">[_contentLabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisVertical];</span><br></pre></td></tr></table></figure>
<h3 id="UITableView">UITableView</h3><p>再看看UITableView。</p>
<h4 id="用systemLayoutSizeFittingSize:获取Cell的高度">用systemLayoutSizeFittingSize:获取Cell的高度</h4><p>在设定好Cell的约束以后，就可以用systemLayoutSizeFittingSize:方法获取Cell的实际高度，它的参数可以设定为两个系统常量，如下：</p>
<ol>
<li>UILayoutFittingCompressedSize: 返回合适的最小大小。</li>
<li>UILayoutFittingExpandedSize: 返回合适的最大大小。</li>
</ol>
<h4 id="模板Cell">模板Cell</h4><p>为了在“- (CGFloat)tableView:(UITableView <em>)tableView heightForRowAtIndexPath:(NSIndexPath </em>)indexPath ”方法中计算Cell的高度，我们需要一个专门用于计算高度的Cell实例，可以说算是Cell的“模板”。一般来说，这个实例可以设置成函数的static变量，并只在第一次使用时初始化一次。</p>
<h4 id="简单缓存高度">简单缓存高度</h4><p>为了避免每次滑动时计算高度，可以将Cell的高度缓存下来。如，保存在每一行对应的数据Model(Entity)中，例如：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">Entity </span>: NSObject</span><br><span class="line"><span class="comment">// Data</span></span><br><span class="line"><span class="variable">@property</span> (copy, nonatomic) NSString *title;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Cache height</span></span><br><span class="line"><span class="variable">@property</span> (assign, nonatomic) CGFloat cellHeight;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p>每次要获取高度时，就可以先检查一下是否有缓存，减少计算量。</p>
<h4 id="设置estimatedRowHeight以减少首次显示的计算量">设置estimatedRowHeight以减少首次显示的计算量</h4><p>默认情况下，首次显示之前，系统都会一次性全部计算出所有Cell的高度，这简直不能忍啊！要是有10000行，那岂不是要卡死=。=</p>
<p>所以iOS 7以后，UITableView有了一个新的属性：estimatedRowHeight。</p>
<p>从属性名上就可以看出，这个属性可以为Cell预先指定一个“估计”的高度值，这样的话，系统就可以先按照估计值布局，然后只获取显示范围内的Cell的高度，这样就不会一次性计算全部的了。</p>
<h4 id="关键代码">关键代码</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="keyword">static</span> Case4Cell *templateCell;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        templateCell = [tableView dequeueReusableCellWithIdentifier:<span class="built_in">NSStringFromClass</span>([Case4Cell class])];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应的数据</span></span><br><span class="line">    Case4DataEntity *dataEntity = _data[(<span class="built_in">NSUInteger</span>) indexPath<span class="variable">.row</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充数据</span></span><br><span class="line">    [templateCell setupData:dataEntity];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断高度是否已经计算过</span></span><br><span class="line">    <span class="keyword">if</span> (dataEntity<span class="variable">.cellHeight</span> &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据当前数据，计算Cell的高度，注意+1</span></span><br><span class="line">        dataEntity<span class="variable">.cellHeight</span> = [templateCell<span class="variable">.contentView</span> systemLayoutSizeFittingSize:<span class="built_in">UILayoutFittingCompressedSize</span>]<span class="variable">.height</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataEntity<span class="variable">.cellHeight</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="iOS_8的新特性">iOS 8的新特性</h3><p>iOS 8大大简化了Cell的高度计算，只要设置好Cell的约束，添加下面几行代码：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tableView.rowHeight = UITableViewAutomaticDimension<span class="comment">;</span></span><br><span class="line">tableView.estimatedRowHeight = 80<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>然后：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="comment">// 只用返回这个！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UITableViewAutomaticDimension</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对！就只用这么几行代码就行！</p>
<h2 id="Case_2:_topLayoutGuide和bottomLayoutGuide">Case 2: topLayoutGuide和bottomLayoutGuide</h2><h3 id="是什么">是什么</h3><p>topLayoutGuide和bottomLayoutGuide都是iOS 7以后，UIViewController的属性。</p>
<p>在文档、头文件中，topLayoutGuide和bottomLayoutGuide的定义如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,retain) <span class="keyword">id</span>&lt;<span class="built_in">UILayoutSupport</span>&gt; topLayoutGuide <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0);</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,retain) <span class="keyword">id</span>&lt;<span class="built_in">UILayoutSupport</span>&gt; bottomLayoutGuide <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0);</span><br></pre></td></tr></table></figure></p>
<p>而UILayoutSupport的定义更是简单：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@protocol</span> UILayoutSupport &lt;NSObject&gt;</span><br><span class="line"><span class="variable">@property</span>(nonatomic,readonly) CGFloat length;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p><strong>以topLayoutGuide为例</strong>：<br><em><br>The topLayoutGuide property comes into play when a view controller is frontmost onscreen. It indicates the highest vertical extent for content that you don’t want to appear behind a translucent or transparent UIKit bar (such as a status or navigation bar). This property implements the UILayoutSupport protocol and you can employ it as a constraint item when using the NSLayoutConstraint class.
</em></p>
<p>简单来说，topLayoutGuide表示当前页面的上方被status bar、navigation bar遮挡的部分。同理，bottomLayoutGuide表示下方被遮挡的部分。</p>
<p>如下图:<br><img src="http://7nj2iz.com1.z0.glb.clouddn.com/blog_autolayout_example_with_masonry2_5.jpg?imageView2/0/w/400/q/100" alt="topLayoutGuide和bottomLayoutGuide"></p>
<h3 id="解决的问题">解决的问题</h3><p>有些时候，一个ViewController可能单独显示出来，也可能内嵌在UINavigationController里面显示出来。在这两种情况下，页面的“<strong>可视范围</strong>”是不一样的，很明显，NavigationBar会遮挡住一部分，用了UITabBarController时，tabBar也会遮挡住下方一部分。再加上各种Bar都可以隐藏，情况会变得更复杂。</p>
<p>难道要为每种情况去写一份布局代码？</p>
<h3 id="如何使用">如何使用</h3><p>为了解决上面的问题，就需要在设置约束时，加进topLayoutGuide和bottomLayoutGuide。</p>
<h4 id="用法1:_强制转换为UIView">用法1: 强制转换为UIView</h4><p>定义上，topLayoutGuide和bottomLayoutGuide都是id，但是实际中是什么呢？跟UIView有什么关系？<br>看看如下代码的运行结果：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">NSLog</span>(@<span class="string">"%d"</span>, [<span class="keyword">self</span>.topLayoutGuide <span class="symbol">isKindOfClass:</span>[<span class="constant">UIView</span> <span class="class"><span class="keyword">class</span>]]);</span></span><br></pre></td></tr></table></figure></p>
<p>结果是：”1”</p>
<p><strong>也就是说，在运行期间，topLayoutGuide和bottomLayoutGuide就是UIView的子类</strong>。</p>
<p>所以，第一种方法就是强制转换成UIView，直接运用在Masonry的约束里面，正如较旧的Masonry官方示例中的一样：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[topView makeConstraints:^<span class="list">(<span class="keyword">MASConstraintMaker</span> *make)</span> <span class="collection">&#123;</span><br><span class="line">    // 强制转换</span><br><span class="line">    UIView *topLayoutGuide = <span class="list">(<span class="keyword">id</span>)</span>self.topLayoutGuide;</span><br><span class="line">    make.top.equalTo<span class="list">(<span class="keyword">topLayoutGuide.mas_bottom</span>)</span><span class="comment">;</span></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>但是这样存在着风险，万一哪天苹果改变了topLayoutGuide和bottomLayoutGuide的实现方法，这么用就Crash了=。=</p>
<h4 id="用法2:_直接使用length属性">用法2: 直接使用length属性</h4><p>第二种方法，就是直接使用UILayoutSupport定义的length属性。<br>这个时候就有个地方要特别注意，在运行到viewDidLoad的时候，length的值是0，因为这个时候界面还没有被绘制，所以一个解决方法就是在ViewController的<strong>updateViewConstraints</strong>方法里面去使用length值添加约束。如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">updateViewConstraints</span> &#123;</span><br><span class="line">    <span class="attr_selector">[_topView mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        // 直接利用其length属性</span><br><span class="line">        make.top.equalTo(self.view.mas_top).with.offset(self.topLayoutGuide.length);</span><br><span class="line">    &#125;]</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attr_selector">[super updateViewConstraints]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="用法3:_使用新版的mas_topLayoutGuide和mas_bottomLayoutGuide">用法3: 使用新版的mas_topLayoutGuide和mas_bottomLayoutGuide</h4><p>在<a href="https://github.com/SnapKit/Masonry/commit/c99e65c2eb40a02106d87a1487f96c0f4b1b72c0" target="_blank" rel="external">Masonry的新版</a>中，为UIViewController增加了一个新的Category: “MASAdditions”，增加了mas_topLayoutGuide和mas_bottomLayoutGuide两个方法，这样的话，我们就可以优雅的使用topLayoutGuide和bottomLayoutGuide了~<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[_topView mas_makeConstraints:^<span class="list">(<span class="keyword">MASConstraintMaker</span> *make)</span> <span class="collection">&#123;</span><br><span class="line">    // 不用强制转换，也不用在updateViewConstraints里面更新了</span><br><span class="line">    make.top.equalTo<span class="list">(<span class="keyword">self.mas_topLayoutGuide</span>)</span><span class="comment">;</span></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="示例">示例</h3><p>直接看Demo吧，比较简单。</p>
<h2 id="Case_3:_自定义baseline">Case 3: 自定义baseline</h2><p>最后一个Case，讲讲baseline。<br>baseline，翻译过来就是“基线”，在Autolayout里面对应着<strong>NSLayoutFormatAlignAllBaseline</strong>，也是一种对齐的标准。例如，UIButton的baseline就是内部的文字，如果一排button按照baseline对齐的话，就是下面这样：<br><img src="http://7nj2iz.com1.z0.glb.clouddn.com/blog_autolayout_example_with_masonry2_6.jpg" alt="按钮按照baseline对其"></p>
<p>对于自定义的View来说，baseline默认就是整个view的底部，如果想改变baseline的话，可以重写UIView的<strong>viewForBaselineLayout</strong>，返回当成baseline的view即可。</p>
<p>如下面的自定义view：</p>
<p><img src="http://7nj2iz.com1.z0.glb.clouddn.com/blog_autolayout_example_with_masonry2_7.jpg" alt="自定义baseline"></p>
<p>很明显，baseline就是显示图片的UIImageView，代码也很简单:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义的View中</span></span><br><span class="line"><span class="comment">// 返回自定义的baseline的view</span></span><br><span class="line">- (<span class="built_in">UIView</span> *)viewForBaselineLayout &#123;</span><br><span class="line">    <span class="keyword">return</span> _imageView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>灵活的使用baseline，可以更加方便的进行布局。</p>
<h2 id="总结">总结</h2><p>写了好长，能全部看完的朋友，嗯，你是个优秀的程序员=。=</p>
<p>后面打算用Swift的SnapKit把所有的Case全部实现一次。</p>
<h2 id="参考">参考</h2><ul>
<li><a href="http://chun.tips/blog/2014/10/23/xi-shu-autolayoutyi-lai-uiviewhe-uiviewcontrollerxin-zeng-de-xiang-guan-api-uiviewpian/" target="_blank" rel="external">细数AutoLayout以来UIView和UIViewController新增的相关API – UIView篇</a></li>
<li><a href="https://developer.apple.com/library/ios/qa/qa1797/_index.html" target="_blank" rel="external">Preventing the Status Bar from Covering Your Views</a></li>
<li><a href="http://www.objc.io/issues/3-views/advanced-auto-layout-toolbox/#intrinsic-content-size" target="_blank" rel="external">Advanced Auto Layout Toolbox</a></li>
<li><a href="http://chun.tips/blog/2014/10/25/xi-shu-autolayoutyi-lai-uiviewhe-uiviewcontrollerxin-zeng-de-xiang-guan-api-uiviewcontrollerpian/" target="_blank" rel="external">细数AutoLayout以来UIView和UIViewController新增的相关API – UIViewController篇</a></li>
<li><a href="http://www.wugaojun.com/blog/2015/05/24/autolayoutshi-zhan-cellgao-du-bu-gu-ding-de-uitableview/" target="_blank" rel="external">AutoLayout实战:cell高度不固定的UITableView</a></li>
<li><a href="http://www.jianshu.com/p/d5d897ffe118" target="_blank" rel="external">AutoLayout下多行UILabel无法显示多行文本的问题</a></li>
<li><a href="https://grayluo.github.io/WeiFocusIo/autolayout/2015/02/01/autolayout5/" target="_blank" rel="external">AutoLayout深入浅出五-UITableView动态高度</a></li>
<li><a href="http://www.brynbodayle.com/faster-uitableviews-with-ios-7/" target="_blank" rel="external">Faster UITableViews with iOS 7</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>Masonry写的Autolayout示例又来了，仍然是三个小例子，分别是<strong>变高度的UITableViewCell、topLayoutGuide与bottomLayoutGuide，还有自定义的baseline</strong>，外加两个基本的知识点讲解，说不上“有趣”=。=，比较基础，写了很多，各位随意看看吧~</p>
<p>上一篇：<a href="http://tutuge.me/2015/05/23/autolayout-example-with-masonry/">有趣的Autolayout示例-Masonry实现</a></p>
<p>Github地址：<br><a href="https://github.com/zekunyan/AutolayoutExampleWithMasonry">https://github.com/zekunyan/AutolayoutExampleWithMasonry</a></p>
<p><img src="http://7nj2iz.com1.z0.glb.clouddn.com/blog_autolayout_example_with_masonry2_1.gif" alt="Gif示例"></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[解决iOS项目的版本兼容问题-结合宏、Category和Runtime]]></title>
    <link href="http://tutuge.me/2015/07/25/compatibility-with-macro-category-and-runtime/"/>
    <id>http://tutuge.me/2015/07/25/compatibility-with-macro-category-and-runtime/</id>
    <published>2015-07-24T16:39:03.000Z</published>
    <updated>2015-11-16T17:03:36.000Z</updated>
    <content type="html"><![CDATA[<h2 id="更新">更新</h2><h3 id="2015-11-16">2015-11-16</h3><p>感谢微博好友<strong>@zyyy_000</strong>的评论，补充了为什么要在<code>+ (void)load</code>方法里面做<strong>Method Swizzling</strong>。</p>
<h2 id="前言">前言</h2><p>最近，在做项目时，因为某种原因，突然要“适配”iOS6（也是醉了。。。），保证极少数的iOS6用户可以“用上”新的版本。哪怕界面上有瑕疵，只要功能正常就行。于是就只好花几天时间对iOS6进行紧急适配（心中一万头驼羊奔跑而过。。。）  </p>
<p>本文总结了一些常规的，和“非常规”的iOS项目向老版本兼容的办法，结合了<strong>宏定义</strong>、<strong>Category</strong>和<strong>Runtime</strong>，大家看着消遣一下就好哈~</p>
<a id="more"></a>
<h2 id="重点概念">重点概念</h2><p>首先强调一些概念。</p>
<h3 id="Deployment_Target_和_Base_SDK">Deployment Target 和 Base SDK</h3><p><strong>Deployment Target</strong><br>指的是你的APP能支持的最低系统版本，如要支持iOS6以上，就设置成iOS6即可。</p>
<p><strong>Base SDK</strong><br>指的是用来编译APP的SDK（Software Development Kit）的版本，一般保持当前XCode支持的最新的就好，如iOS8.4。SDK其实就是包含了所有的你要用到的头文件、链接库的集合，你的APP里面用的各种类、函数，能编译、链接成最后的安装包，就要靠它，苹果每次升级系统，新推出的各种API，也是在SDK里面。所以一般Base SDK肯定是大于等于Deployment Target的版本。</p>
<p><strong>区分</strong><br>既然Base SDK的版本大于等于Deployment Target的版本，那么就要小心了，因为<strong>“只要用到的类、方法，在当前的Base SDK版本里面存在，就可以<em>编译通过</em>！但是一旦运行APP的手机的系统版本低于这些类、方法的最低版本要求，APP就会Crash！”</strong>  </p>
<p>所以并不是说，能编译通过的，就一定能<em>运行成功</em>！还要在<em>运行时检查</em>！简单来说，就是如下图：</p>
<p><img src="http://7nj2iz.com1.z0.glb.clouddn.com/blog_compatibility-with-macro-category-and-runtime_1.png" alt="兼容示意图"></p>
<h3 id="宏只在编译时生效！">宏只在编译时生效！</h3><p>宏定义只是纯粹的文本替换，只在编译时起作用。如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">if</span> __IPHONE_OS_VERSION_MIN_REQUIRED &gt;= <span class="number">70000</span></span></span><br><span class="line">    NSLog(@<span class="string">"Tutuge"</span>);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>被宏定义包起来的代码是否会执行，在编译时就决定好了，无论你是用什么系统运行，宏定义再也没有什么卵用=。=</p>
<h2 id="编译时检查SDK版本，运行时检查系统版本">编译时检查SDK版本，运行时检查系统版本</h2><p>这个是最基本的适配手段。  </p>
<p>用到的宏如下：</p>
<ol>
<li><strong>__IPHONE_OS_VERSION_MAX_ALLOWED</strong>: 值等于Base SDK，即用于检查SDK版本的。</li>
<li><strong>__IPHONE_OS_VERSION_MIN_REQUIRED</strong>: 值等于Deployment Target，检查支持的最小系统版本。</li>
</ol>
<p>运行时检查系统版本：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([UIDevice currentDevice].systemVersion.floatValue &gt; <span class="number">8.0f</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假如我们现在想用iOS8新的<strong>UIAlertController</strong>来显示提示框，应该如下判断：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译时判断：检查SDK版本</span></span><br><span class="line"><span class="preprocessor">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt; 80000</span></span><br><span class="line">    <span class="comment">// 运行时判断：检查当前系统版本</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">UIDevice</span> currentDevice]<span class="variable">.systemVersion</span><span class="variable">.floatValue</span> &gt; <span class="number">8.0</span>f) &#123;</span><br><span class="line">        <span class="built_in">UIAlertController</span> *alertController =</span><br><span class="line">        [<span class="built_in">UIAlertController</span> alertControllerWithTitle:<span class="string">@"Tutuge"</span></span><br><span class="line">                                            message:<span class="string">@"Compatibility"</span></span><br><span class="line">                                     preferredStyle:<span class="built_in">UIAlertControllerStyleAlert</span>];</span><br><span class="line">        [alertController addAction:[<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@"Cancel"</span></span><br><span class="line">                                                            style:<span class="built_in">UIAlertActionStyleCancel</span></span><br><span class="line">                                                          handler:^(<span class="built_in">UIAlertAction</span> *action) &#123;</span><br><span class="line">                                                              <span class="built_in">NSLog</span>(<span class="string">@"Cancel"</span>);</span><br><span class="line">                                                          &#125;]];</span><br><span class="line">        [<span class="keyword">self</span> presentViewController:alertController animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 用旧的代替</span></span><br><span class="line">        <span class="built_in">UIAlertView</span> *alertView = [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"Tutuge"</span></span><br><span class="line">                                                            message:<span class="string">@"Compatibility"</span></span><br><span class="line">                                                           delegate:<span class="literal">nil</span></span><br><span class="line">                                                  cancelButtonTitle:<span class="string">@"Cancel"</span></span><br><span class="line">                                                  otherButtonTitles:<span class="literal">nil</span>];</span><br><span class="line">        [alertView show];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="preprocessor">#else</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="preprocessor">#endif</span></span><br></pre></td></tr></table></figure></p>
<p>总的来说就是编译时、运行时的判断均不能少。</p>
<h2 id="Weakly_Linked_-_运行时检查类、方法是否可用">Weakly Linked - 运行时检查类、方法是否可用</h2><p>除了用宏、系统版本检测，还可以用<strong>Weakly Linked</strong>特性做运行时的检查。</p>
<p>对于iOS4.2以上的，有<strong>NS_CLASS_AVAILABLE</strong>标示的类，可以如下判断是否可用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">if</span> __IPHONE_OS_VERSION_MAX_ALLOWED &gt; <span class="number">80000</span></span></span><br><span class="line">    <span class="comment">// Weakly Linked判断</span></span><br><span class="line">    <span class="keyword">if</span> ([UIAlertController <span class="keyword">class</span>]) &#123;</span><br><span class="line">        <span class="comment">// 使用UIAlertController...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用旧的方案...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>也可以如下判断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class <span class="class"><span class="keyword">class</span> </span>= NSClassFromString (@<span class="string">"UIAlertController"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="class"><span class="keyword">class</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用UIAlertController...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 使用旧的方案...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于方法，如下判断:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">if</span> ([UITableViewCell <span class="attribute">instancesRespondToSelector</span>:<span class="variable">@selector</span> (<span class="attribute">setSeparatorInset</span>:)]) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="tag">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于用哪种方法，统一一下即可。</p>
<h2 id="用Method_Swizzling做兼容">用Method Swizzling做兼容</h2><p>有关Runtime、Method Swizzling的资料很多，各位自行阅读哈~  </p>
<h3 id="在+_(void)load方法里面做替换">在<code>+ (void)load</code>方法里面做替换</h3><p>这里提一下为什么要在<code>+ (void)load</code>方法里面做Method Swizzling。</p>
<p>在Objective-C中，运行时会自动调用每个类的两个方法。<code>+ (void)load</code>会在类、Category初始加载时调用，<code>+ (void)initialize</code>会在第一次调用类的类方法或实例方法之前被调用。  </p>
<p>但是需要注意的是，<code>+ (void)initialize</code>是可以被Category覆盖重写的，并且有多个Category都重写了<code>+ (void)initialize</code>方法时，只会运行其中一个，所以在<code>+ (void)initialize</code>里面做Method Swizzling显然是不行的。</p>
<p>而<code>+ (void)load</code>方法只要实现了，就一定会调用。具体为什么大家可以自行阅读Runtime的源码，或者查阅相关文章。</p>
<h3 id="用dispatch_once保证只运行一次">用dispatch_once保证只运行一次</h3><p>因为Method Swizzling的影响是全局的，而且一旦多次调用，会出错，所以这个时候用dispatch_once就再合适不过了~</p>
<h3 id="实例">实例</h3><p>下面就是利用Method Swizzling做兼容的一个例子。<br>有时候，不同版本之间，同一个类、View控件的默认属性可能都会变化，如UILabel的背景色在iOS6上，默认是白色，而iOS6以后是透明的！如果在每个用到UILabel的地方，都手动设置一次背景色，代价太大。这个时候就需要Runtime的“黑魔法”上场。</p>
<p>就以设置UILabel的默认背景色透明为例，就是在UILabel初始化时，如initWithFrame之前，先设置好透明背景色，简单的示例如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Category</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UILabel</span> (<span class="title">TTGCompatibility</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// 先判断系统版本，尽量减少Runtime的作用范围</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">UIDevice</span> currentDevice]<span class="variable">.systemVersion</span><span class="variable">.floatValue</span> &lt; <span class="number">7.0</span>f) &#123;</span><br><span class="line">            <span class="comment">// Method Swizzling</span></span><br><span class="line">            <span class="comment">// initWithFrame</span></span><br><span class="line">            Method oriMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(initWithFrame:));</span><br><span class="line">            Method newMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(compatible_initWithFrame:));</span><br><span class="line">            method_exchangeImplementations(oriMethod, newMethod);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// initWithCoder...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initWithFrame</span></span><br><span class="line">- (<span class="keyword">id</span>)compatible_initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</span><br><span class="line">    <span class="keyword">id</span> newSelf = [<span class="keyword">self</span> compatible_initWithFrame:frame];</span><br><span class="line">    <span class="comment">// 设置透明背景色</span></span><br><span class="line">    ((<span class="built_in">UILabel</span> *)newSelf)<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">    <span class="keyword">return</span> newSelf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initWithCoder...</span></span><br></pre></td></tr></table></figure>
<h2 id="运行时添加“Dummy”方法，减少代码改动">运行时添加“Dummy”方法，减少代码改动</h2><p>Dummy，意思是“假的、假动作、假人”，在这里指的是为旧版本不存在的方法提供一个“假的”替代方法，防止因新API找不到而导致的Crash。</p>
<p>以UITableViewCell的<strong>“setSeparatorInset:”</strong>方法为例，在iOS6中，压根就不存在separatorInset，但是现有的代码里面大量的调用了这个方法，怎么办？难道一个一个的去加上判断条件？代价太大。 </p>
<p>这个时候就可以用Runtime的手段，在运行时添加一个Dummy方法，去“<strong>代替接收</strong>”setSeparatorInset消息，防止在iOS6上的Crash。</p>
<p>代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UITableViewCell</span> (<span class="title">TTGCompatibility</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line"><span class="comment">// 编译时判断SDK</span></span><br><span class="line"><span class="preprocessor">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt; __IPHONE_7_0</span></span><br><span class="line">    <span class="comment">// 运行时判断系统版本</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">UIDevice</span> currentDevice]<span class="variable">.systemVersion</span><span class="variable">.floatValue</span> &lt; <span class="number">7.0</span>f) &#123;</span><br><span class="line">        Method newMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(compatible_setSeparatorInset:));</span><br><span class="line">        <span class="comment">// 增加Dummy方法</span></span><br><span class="line">        class_addMethod(</span><br><span class="line">                <span class="keyword">self</span>,</span><br><span class="line">                <span class="keyword">@selector</span>(setSeparatorInset:),</span><br><span class="line">                method_getImplementation(newMethod),</span><br><span class="line">                method_getTypeEncoding(newMethod));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setSeparatorInset: 的Dummy方法</span></span><br><span class="line">- (<span class="keyword">void</span>)compatible_setSeparatorInset:(<span class="built_in">UIEdgeInsets</span>) inset &#123;</span><br><span class="line">    <span class="comment">// 空方法都可以，只是为了接收setSeparatorInset:消息。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2><p>在适配旧版本时，除了基本的宏定义、[UIDevice currentDevice].systemVersion判断，适当的用Runtime，可以大大减少对现有代码的“干涉”，多种方法相结合才是最好的。</p>
<p>嗯，还在用iOS6的用户，升个级呗=。=</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/cross_development/Introduction/Introduction.html#//apple_ref/doc/uid/10000163-BCICHGIE" target="_blank" rel="external">SDK Compatibility Guide</a></li>
<li><a href="http://git.devzeng.com/blog/ios-multiple-version-compatible.html" target="_blank" rel="external">iOS开发之多系统版本兼容</a></li>
<li><a href="http://stackoverflow.com/questions/3057325/weak-linking-check-if-a-class-exists-and-use-that-class" target="_blank" rel="external">Weak Linking - check if a class exists and use that class</a></li>
<li><a href="http://stackoverflow.com/questions/19789958/xcode-preprocessor-macro-to-check-if-base-sdk-ios-7-0" target="_blank" rel="external">Xcode preprocessor macro to check if Base SDK &gt;= iOS 7.0</a></li>
<li><a href="http://xuzhongzhou.net/post/ios-sdk-compatibility-guide.html" target="_blank" rel="external">iOS SDK 兼容性指南</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="更新">更新</h2><h3 id="2015-11-16">2015-11-16</h3><p>感谢微博好友<strong>@zyyy_000</strong>的评论，补充了为什么要在<code>+ (void)load</code>方法里面做<strong>Method Swizzling</strong>。</p>
<h2 id="前言">前言</h2><p>最近，在做项目时，因为某种原因，突然要“适配”iOS6（也是醉了。。。），保证极少数的iOS6用户可以“用上”新的版本。哪怕界面上有瑕疵，只要功能正常就行。于是就只好花几天时间对iOS6进行紧急适配（心中一万头驼羊奔跑而过。。。）  </p>
<p>本文总结了一些常规的，和“非常规”的iOS项目向老版本兼容的办法，结合了<strong>宏定义</strong>、<strong>Category</strong>和<strong>Runtime</strong>，大家看着消遣一下就好哈~</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用Runtime的手段填充任意NSObject对象的nil属性]]></title>
    <link href="http://tutuge.me/2015/07/08/fill-nil-property-of-object/"/>
    <id>http://tutuge.me/2015/07/08/fill-nil-property-of-object/</id>
    <published>2015-07-08T15:23:23.000Z</published>
    <updated>2015-07-11T10:23:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>好久没有写东西了，忙啊。<br>前段时间参加了一下我们华科联创的HackDay（本人在读研=。=，目前在阿里实习），作品是一款<strong>实时在线对战游戏 - 波波攒</strong>，（介绍请看<a href="http://www.zhihu.com/question/24402279" target="_blank" rel="external">知乎</a>）<br>从iOS游戏客户端（用的<strong>SpriteKit</strong>）到后台（<strong>PHP CI + Node + SocketIO + MySQL</strong>）全是自己一个人倒腾出来的，做了一把真正的全栈工程师，爽啊~<br>后面会完善整个游戏，增加角色、优化啥的，过上一段时间会上线的哈~</p>
<p><strong>回到正文</strong>，本文主要介绍了怎么用Runtime的手段遍历任意NSObject对象的所有property，检查其值是否是nil，是的话根据其类型为其填充一个默认值。<br>Runtime毕竟是个“危险”的技术，本文的代码只是个初步的尝试。</p>
<a id="more"></a>
<h2 id="初衷">初衷</h2><p>在做项目的过程中，总是会写一大堆if、else语句去检查对象的Property是否是nil，如从服务器返回的JSON中缺少属性，导致Entity的某些值为空；或者创建的对象没有对所有属性做初始化等等。写多了觉得好烦啊=。=<br>所以想到本文的方法，嗯，程序员总是懒的。</p>
<h2 id="解决步骤">解决步骤</h2><ol>
<li>遍历一个对象的所有属性（默认不包括父类属性）。</li>
<li>判断属性是否是nil。</li>
<li>为nil的属性，获取它的类型。</li>
<li>根据类型设置初始值（如NSString可以设为空字符串；NSNumber可以设为@0）</li>
</ol>
<h2 id="Runtime">Runtime</h2><p>OC是一门“动态”、“基于消息”的语言，而Runtime就是利用OC的动态特性，在运行时对程序做出“调整”的技术。有关Runtime的官方文档、网上的资料很多，大家自学哈~</p>
<p>本文主要用了如下几个Runtime的函数：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取类的所有<span class="keyword">Property</span><span class="title"></span><br><span class="line"></span><span class="number">1</span>. objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)</span><br><span class="line">// 获取一个<span class="keyword">Property</span><span class="title"></span>的变量名</span><br><span class="line"><span class="number">2</span>. const char *property_getName(objc_property_t <span class="keyword">property</span><span class="title"></span>)</span><br><span class="line">// 获取一个<span class="keyword">Property</span><span class="title"></span>的详细类型表达字符串</span><br><span class="line"><span class="number">3</span>. const char *property_getAttributes(objc_property_t <span class="keyword">property</span><span class="title"></span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="示例">示例</h2><p>不好一块一块拆开说，直接上代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 解析Property的Attributed字符串，参考Stackoverflow</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getPropertyType</span><span class="params">(objc_property_t property)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *attributes = property_getAttributes(property);</span><br><span class="line">    </span><br><span class="line">    NSLog(@<span class="string">"%s"</span>, attributes);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1</span> + <span class="built_in">strlen</span>(attributes)];</span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, attributes);</span><br><span class="line">    <span class="keyword">char</span> *state = buffer, *attribute;</span><br><span class="line">    <span class="keyword">while</span> ((attribute = strsep(&amp;state, <span class="string">","</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 非对象类型</span></span><br><span class="line">        <span class="keyword">if</span> (attribute[<span class="number">0</span>] == <span class="string">'T'</span> &amp;&amp; attribute[<span class="number">1</span>] != <span class="string">'@'</span>) &#123;</span><br><span class="line">            <span class="comment">// 利用NSData复制一份字符串</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">const</span> <span class="keyword">char</span> *) [[NSData dataWithBytes:(attribute + <span class="number">1</span>) length:<span class="built_in">strlen</span>(attribute) - <span class="number">1</span>] bytes];</span><br><span class="line">        <span class="comment">// 纯id类型</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (attribute[<span class="number">0</span>] == <span class="string">'T'</span> &amp;&amp; attribute[<span class="number">1</span>] == <span class="string">'@'</span> &amp;&amp; <span class="built_in">strlen</span>(attribute) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"id"</span>;</span><br><span class="line">        <span class="comment">// 对象类型</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (attribute[<span class="number">0</span>] == <span class="string">'T'</span> &amp;&amp; attribute[<span class="number">1</span>] == <span class="string">'@'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">const</span> <span class="keyword">char</span> *) [[NSData dataWithBytes:(attribute + <span class="number">3</span>) length:<span class="built_in">strlen</span>(attribute) - <span class="number">4</span>] bytes];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 给对象的属性设置默认值</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkEntity</span><span class="params">(NSObject *object)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不同类型的字符串表示，目前只是简单检查字符串、数字、数组</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *CLASS_NAME_NSSTRING;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *CLASS_NAME_NSNUMBER;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *CLASS_NAME_NSARRAY;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化类型常量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// "NSString"</span></span><br><span class="line">        CLASS_NAME_NSSTRING =  NSStringFromClass([NSString <span class="keyword">class</span>]).UTF8String;</span><br><span class="line">        <span class="comment">// "NSNumber</span></span><br><span class="line">        CLASS_NAME_NSNUMBER = NSStringFromClass([NSNumber <span class="keyword">class</span>]).UTF8String;</span><br><span class="line">        <span class="comment">// "NSArray"</span></span><br><span class="line">        CLASS_NAME_NSARRAY = NSStringFromClass([NSArray <span class="keyword">class</span>]).UTF8String;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    @<span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount, i;</span><br><span class="line">        <span class="comment">// 包含所有Property的数组</span></span><br><span class="line">        <span class="keyword">objc_property_t</span> *properties = class_copyPropertyList([object <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历每个Property</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">            <span class="comment">// 取出对应Property</span></span><br><span class="line">            <span class="keyword">objc_property_t</span> property = properties[i];</span><br><span class="line">            <span class="comment">// 获取Property对应的变量名</span></span><br><span class="line">            NSString *propertyName = [NSString stringWithUTF8String:property_getName(property)];</span><br><span class="line">            <span class="comment">// 获取Property的类型名</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *propertyTypeName = getPropertyType(property);</span><br><span class="line">            <span class="comment">// 获取Property的值</span></span><br><span class="line">            id propertyValue = [object valueForKey:propertyName];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 值为空，才设置默认值</span></span><br><span class="line">            <span class="keyword">if</span> (!propertyValue) &#123;</span><br><span class="line">                <span class="comment">// NSString</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strncmp</span>(CLASS_NAME_NSSTRING, propertyTypeName, <span class="built_in">strlen</span>(CLASS_NAME_NSSTRING)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    [object setValue:@<span class="string">""</span> forKey:propertyName];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// NSNumber</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strncmp</span>(CLASS_NAME_NSNUMBER, propertyTypeName, <span class="built_in">strlen</span>(CLASS_NAME_NSNUMBER)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    [object setValue:@<span class="number">0</span> forKey:propertyName];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// NSArray</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strncmp</span>(CLASS_NAME_NSARRAY, propertyTypeName, <span class="built_in">strlen</span>(CLASS_NAME_NSARRAY)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    [object setValue:@[] forKey:propertyName];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 别忘了释放数组</span></span><br><span class="line">        <span class="built_in">free</span>(properties);</span><br><span class="line">    &#125; @<span class="keyword">catch</span> (NSException *exception) &#123;</span><br><span class="line">        NSLog(@<span class="string">"Check Entity Exception: %@"</span>, [exception description]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="重点_-_解析property_getAttributes函数的结果">重点 - 解析property_getAttributes函数的结果</h2><p>在整个处理过程中，property_getAttributes函数是关键，因为我们要首先确定Property的类型，才能根据类型赋初值，但是property_getAttributes函数返回的字符串比较“晦涩难懂”：</p>
<p>如下定义的Property：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSNumber</span> *number;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSArray</span> *array;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> i;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> f;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">char</span> *cStr;</span><br></pre></td></tr></table></figure></p>
<p>依次通过property_getAttributes获取的结果是：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T@<span class="string">"NSString"</span>,<span class="keyword">C</span>,<span class="keyword">N</span>,V_name</span><br><span class="line">T@<span class="string">"NSNumber"</span>,&amp;,<span class="keyword">N</span>,V_number</span><br><span class="line">T@<span class="string">"NSArray"</span>,&amp;,<span class="keyword">N</span>,V_array</span><br><span class="line">Tq,<span class="keyword">N</span>,V_i</span><br><span class="line">Td,<span class="keyword">N</span>,V_f</span><br><span class="line">T*,<span class="keyword">N</span>,V_cStr</span><br></pre></td></tr></table></figure></p>
<p>参考<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101" target="_blank" rel="external"> Declared Properties of Objective-C Runtime Programming Guide</a><br>我们大概可以知道，T表示Type，后面跟着@表示Cocoa对象类型，后面的表示Property的属性，如Copy、strong等，然后就是变量名。<br>所以getPropertyType函数的工作就是纯粹的解析字符串，获取T@后面的类型名。</p>
<h2 id="效果">效果</h2><p>例如我们有如下对象：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">UserEntity </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (copy, nonatomic) NSString *name;</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) NSNumber *number;</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) NSArray *array;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p>设置默认值：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UserEntity *userEntity = [UserEntity new];</span><br><span class="line"><span class="comment">// 检查属性，设置默认值。</span></span><br><span class="line">checkEntity(userEntity);</span><br><span class="line"><span class="comment">// 使用...</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"name: %@"</span>, userEntity<span class="variable">.name</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"number: %@"</span>, userEntity<span class="variable">.number</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"array: %@"</span>, userEntity<span class="variable">.array</span>);</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2015</span>-<span class="number">07</span>-<span class="number">11</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">25.918</span> Common[<span class="number">6939</span>:<span class="number">270543</span>] name: </span><br><span class="line"><span class="number">2015</span>-<span class="number">07</span>-<span class="number">11</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">25.918</span> Common[<span class="number">6939</span>:<span class="number">270543</span>] number: <span class="number">0</span></span><br><span class="line"><span class="number">2015</span>-<span class="number">07</span>-<span class="number">11</span> <span class="number">18</span>:<span class="number">17</span>:<span class="number">25.918</span> Common[<span class="number">6939</span>:<span class="number">270543</span>] <span class="built_in">array</span>: (</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>这样，一个对象的所有Property都有了初值。</p>
<h2 id="总结">总结</h2><p>上面的例子只是个粗略的版本，只是检查了字符串、数字、数组，其实完全可以扩展出很多功能，如针对不同的类型，根据对象的类型，设置不同的默认初值等，靠读者你了~</p>
<p>Runtime是个好东西，但是别乱用啊=。=</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html" target="_blank" rel="external">Objective-C Runtime Reference</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101" target="_blank" rel="external">Objective-C Runtime Programming Guide - Declared Properties</a></li>
<li><a href="http://stackoverflow.com/questions/754824/get-an-object-properties-list-in-objective-c" target="_blank" rel="external">Get an object properties list in Objective-C</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>好久没有写东西了，忙啊。<br>前段时间参加了一下我们华科联创的HackDay（本人在读研=。=，目前在阿里实习），作品是一款<strong>实时在线对战游戏 - 波波攒</strong>，（介绍请看<a href="http://www.zhihu.com/question/24402279">知乎</a>）<br>从iOS游戏客户端（用的<strong>SpriteKit</strong>）到后台（<strong>PHP CI + Node + SocketIO + MySQL</strong>）全是自己一个人倒腾出来的，做了一把真正的全栈工程师，爽啊~<br>后面会完善整个游戏，增加角色、优化啥的，过上一段时间会上线的哈~</p>
<p><strong>回到正文</strong>，本文主要介绍了怎么用Runtime的手段遍历任意NSObject对象的所有property，检查其值是否是nil，是的话根据其类型为其填充一个默认值。<br>Runtime毕竟是个“危险”的技术，本文的代码只是个初步的尝试。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[有趣的Autolayout示例-Masonry实现]]></title>
    <link href="http://tutuge.me/2015/05/23/autolayout-example-with-masonry/"/>
    <id>http://tutuge.me/2015/05/23/autolayout-example-with-masonry/</id>
    <published>2015-05-23T11:59:22.000Z</published>
    <updated>2015-11-27T04:27:45.000Z</updated>
    <content type="html"><![CDATA[<h2 id="更新">更新</h2><p>2015-11-27: 感谢“谢小雷”指出打字错误~<br>2015-9-1: 感谢“王振宇C艹”指出打字错误，已经修改了哈~<br>2015-9-10: 第二篇: <a href="http://tutuge.me/2015/08/08/autolayout-example-with-masonry2/">有趣的Autolayout示例2-Masonry实现</a></p>
<h2 id="前言">前言</h2><p>好久没有写Blog了，这段时间有点忙啊=。=<br>本文举了3个比较有“特点”的Autolayout例子，源于微博上好友的提问，感觉比较有意思，也比较有代表性，就写了出来，分享给大家~<br>至于为什么用Masonry，那是因为它好用啊！（被问到过有关Masonry的问题，就索性用它来实现吧=。=）。</p>
<h3 id="效果图">效果图</h3><p><img src="http://zorrochen.qiniudn.com/blog_autolayout_example_with_masonry_1.gif" alt="效果图"></p>
<h3 id="Github地址">Github地址</h3><p><a href="https://github.com/zekunyan/AutolayoutExampleWithMasonry" target="_blank" rel="external">https://github.com/zekunyan/AutolayoutExampleWithMasonry</a></p>
<a id="more"></a>
<h3 id="关于例子工程结构">关于例子工程结构</h3><p>实现的时候采用的是用StoryBoard拖拽约束+Masonry手写代码相结合的方式实现。最关键的地方是用Masonry，为了更好地突出重点。其它的无关紧要的空间约束，直接就拖拽了。</p>
<h2 id="关于Autolayout">关于Autolayout</h2><p>刚开始学习Autolayout的时候，什么“Leading Edges”、“Horizontal Centers”，好多啊，感觉一下子适应不来，有时候面对一个界面布局上的需求，可能都无从下手。</p>
<p>总的来说，我觉得Autolayout的关键就是“<strong>Constraint（约束）</strong>”。其实就是以下两点：</p>
<ol>
<li>从显式设置frame的属性，到利用约束控制View的大小、位置。</li>
<li>思考如何布局时，重点从单个的View，到整体所有View之间的相互关系。</li>
</ol>
<p>既然没有了具体设置View的frame属性，也就是说，系统会在运行时，通过我们设定的“约束”，计算出每个View的frame，再去绘制屏幕内容。</p>
<p>也就是说，我们设置的Constraint，要能体现出View的<strong>位置（x、y坐标）</strong>、<strong>大小（宽高）</strong>。无论是用IB拖拽约束，还是手写代码，只要从这个角度去思考，很多问题就都能解决。</p>
<p>有关Autolayout的知识，网上有很多，在这里就不详细列出了，但是有个公式倒是可以贴出来：</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewA-<span class="keyword">attribute</span> = viewB-<span class="keyword">attribute</span> * multiplier + <span class="keyword">constant</span></span><br></pre></td></tr></table></figure>
<h2 id="关于Masonry">关于Masonry</h2><p>好用！</p>
<h2 id="Case_1:_并排两个label，宽度由内容决定。父级View宽度不够时，优先显示左边label的内容">Case 1: 并排两个label，宽度由内容决定。父级View宽度不够时，优先显示左边label的内容</h2><p>遇到这种跟内容压缩、优先级有关的布局，就不得不提Autolayout中的两个重要的属性“<strong>Content Compression Resistance</strong>”和“<strong>Content Hugging</strong>”。</p>
<h3 id="Content_Compression_Resistance_=_不许挤我！">Content Compression Resistance = 不许挤我！</h3><p>对，这个属性说白了就是“不许挤我”=。=<br>这个属性的优先级（Priority）越高，越不“容易”被压缩。也就是说，当整体的空间装不下所有的View的时候，Content Compression Resistance优先级越高的，显示的内容越完整。</p>
<h3 id="Content_Hugging_=_抱紧！">Content Hugging = 抱紧！</h3><p>这个属性的优先级越高，整个View就要越“抱紧”View里面的内容。也就是View的大小不会随着父级View的扩大而扩大。</p>
<h3 id="分析">分析</h3><p>根据要求，可以将约束分为两个部分：</p>
<ol>
<li>整体空间足够时，两个label的宽度由内容决定，也就是说，label的“Content Hugging”优先级很高，而且没有固定的Width属性。</li>
<li>整体空间不够时，左边的label更不容易被压缩，也就是“Content Compression Resistance”优先级更高。</li>
</ol>
<p>重点：</p>
<ol>
<li>label不设置具体的宽度（width）属性，宽度由内容决定。</li>
<li>显示的优先级由“Content Compression Resistance”属性的高低决定。</li>
</ol>
<h3 id="约束示例图">约束示例图</h3><p><img src="http://zorrochen.qiniudn.com/blog_autolayout_example_with_masonry_2.png" alt="约束示例图"></p>
<h3 id="关键代码">关键代码</h3><p>关键的代码如下：（label1是左边的label，label2是右边的）</p>
<h4 id="设置位置">设置位置</h4><pre><code><span class="comment">// label1: 位于左上角</span>
[_label1 mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) {
    <span class="built_in">make</span>.top.equalTo(_contentView1.mas_top).with.offset(<span class="number">5</span>);
    <span class="built_in">make</span>.left.equalTo(_contentView1.mas_left).with.offset(<span class="number">2</span>);

    <span class="comment">// 40高度</span>
    <span class="built_in">make</span>.height.equalTo(@<span class="number">40</span>);
}];

<span class="comment">// label2: 位于右上角</span>
[_label2 mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) {
    <span class="comment">//左边贴着label1，间隔2</span>
    <span class="built_in">make</span>.left.equalTo(_label1.mas_right).with.offset(<span class="number">2</span>);

    <span class="comment">//上边贴着父view，间隔5</span>
    <span class="built_in">make</span>.top.equalTo(_contentView1.mas_top).with.offset(<span class="number">5</span>);

    <span class="comment">//右边的间隔保持大于等于2，注意是lessThanOrEqual</span>
    <span class="comment">//这里的“lessThanOrEqualTo”放在从左往右的X轴上考虑会更好理解。</span>
    <span class="comment">//即：label2的右边界的X坐标值“小于等于”containView的右边界的X坐标值。</span>
    <span class="built_in">make</span>.right.lessThanOrEqualTo(_contentView1.mas_right).with.offset(-<span class="number">2</span>);

    <span class="comment">//只设置高度40</span>
    <span class="built_in">make</span>.height.equalTo(@<span class="number">40</span>);
}];
</code></pre><h4 id="设置内容约束">设置内容约束</h4><pre><code><span class="comment">//设置label1的content hugging 为1000</span>
<span class="attr_selector">[_label1 setContentHuggingPriority:UILayoutPriorityRequired
                           forAxis:UILayoutConstraintAxisHorizontal]</span>;

<span class="comment">//设置label1的content compression 为1000</span>
<span class="attr_selector">[_label1 setContentCompressionResistancePriority:UILayoutPriorityRequired
                                         forAxis:UILayoutConstraintAxisHorizontal]</span>;

<span class="comment">//设置右边的label2的content hugging 为1000</span>
<span class="attr_selector">[_label2 setContentHuggingPriority:UILayoutPriorityRequired
                           forAxis:UILayoutConstraintAxisHorizontal]</span>;

<span class="comment">//设置右边的label2的content compression 为250</span>
<span class="attr_selector">[_label2 setContentCompressionResistancePriority:UILayoutPriorityDefaultLow
                                         forAxis:UILayoutConstraintAxisHorizontal]</span>;
</code></pre><h3 id="小节">小节</h3><p>灵活运用“Content Compression Resistance”和“Content Hugging”属性。</p>
<h2 id="Case_2:_四个ImageView整体居中，可以任意显示、隐藏">Case 2: 四个ImageView整体居中，可以任意显示、隐藏</h2><p>先看看示例的截图：<br><img src="http://zorrochen.qiniudn.com/blog_autolayout_example_with_masonry_3.png" alt="效果图"></p>
<p>下面的四个Switch控件分别控制上面对应位置的图片是否显示。</p>
<h3 id="分析-1">分析</h3><ol>
<li>首先就是整体居中，为了实现这个，最简单的办法就是将四个图片“装进”一个<strong>容器View</strong>里面，然后让这个容器View在整个页面中居中即可。这样就不用控制每个图片的居中效果了。</li>
<li>然后就是显示与隐藏。在这里我直接控制图片ImageView的宽度，宽度为0的时候不就“隐藏”了吗。</li>
</ol>
<h3 id="约束示例图-1">约束示例图</h3><p><img src="http://zorrochen.qiniudn.com/blog_autolayout_example_with_masonry_4.png" alt="约束示例图"></p>
<p><strong>解释</strong></p>
<p>之所以这么设置，主要目的有以下几点：</p>
<ol>
<li>尽量减少无效的约束，保证约束不多也不少。</li>
<li>内部的每个imageView约束其实都只有四个：left、centerY、width和height，这样有个好处，就是可以写个函数，专门为View一次性添加这几个约束，大大减少代码量。</li>
<li>最右边的imageView还要单独设置跟容器View的右边约束，是为了不用设置容器View的width，保证容器View是刚好包含内部的View的，这样整体才是居中的。</li>
</ol>
<h3 id="关键代码-1">关键代码</h3><p>先看看设置每个imageView约束的函数：</p>
<pre><code>/<span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span>  设置view的宽高、左边约束，垂直中心约束
<span class="keyword">*</span>
<span class="keyword">*</span>  <span class="comment">@param view    要设置的view</span>
<span class="keyword">*</span>  <span class="comment">@param size    CGSize</span>
<span class="keyword">*</span>  <span class="comment">@param left    左边对齐的约束</span>
<span class="keyword">*</span>  <span class="comment">@param centerY 垂直中心对齐的约束</span>
<span class="keyword">*</span>
<span class="keyword">*</span>  <span class="comment">@return 返回宽约束，用于显示、隐藏单个view</span>
<span class="keyword">*</span>/
- (MASConstraint <span class="keyword">*</span>)setView:(UIView <span class="keyword">*</span>)view size:(CGSize)size left:(MASViewAttribute <span class="keyword">*</span>)left centerY:(MASViewAttribute <span class="keyword">*</span>)centerY {

    __block MASConstraint <span class="keyword">*</span>widthConstraint;

    [view mas_makeConstraints:^(MASConstraintMaker <span class="keyword">*</span>make) {
        //宽高固定
        widthConstraint = make.width.equalTo(<span class="comment">@(size.width));</span>
        make.height.equalTo(<span class="comment">@(size.height));</span>
        //左边约束
        make.left.equalTo(left);
        //垂直中心对齐
        make.centerY.equalTo(centerY);
    }];

    return widthConstraint;
}
</code></pre><p>接着就是设置容器View的代码：</p>
<pre><code><span class="comment">//containerView 就是 容器View</span>

[_containerView mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) {
    <span class="comment">//只设置高度，宽度由子View决定</span>
    <span class="built_in">make</span>.height.equalTo(@(IMAGE_SIZE));
    <span class="comment">//水平居中</span>
    <span class="built_in">make</span>.centerX.equalTo(self.view.mas_centerX);
    <span class="comment">//距离父View顶部200点</span>
    <span class="built_in">make</span>.top.equalTo(self.view.mas_top).offset(<span class="number">200</span>);
}];
</code></pre><p>最后是内部imageView的约束：</p>
<pre><code><span class="comment">//分别设置每个imageView的宽高、左边、垂直中心约束，注意约束的对象</span>
<span class="comment">//每个View的左边约束和左边的View的右边相等=。=，有点绕口...</span>

UIImageView *imageView1 = _imageViews[<span class="number">0</span>];
MASConstraint *width = [self <span class="string">setView:</span>imageView1 <span class="string">size:</span>imageViewSize <span class="string">left:</span>_containerView.mas_left <span class="string">centerY:</span>_containerView.mas_centerY];
[_widthConstraints <span class="string">addObject:</span>width];

UIImageView *imageView2 = _imageViews[<span class="number">1</span>];
width = [self <span class="string">setView:</span>imageView2 <span class="string">size:</span>imageViewSize <span class="string">left:</span>imageView1.mas_right <span class="string">centerY:</span>_containerView.mas_centerY];
[_widthConstraints <span class="string">addObject:</span>width];

UIImageView *imageView3 = _imageViews[<span class="number">2</span>];
width = [self <span class="string">setView:</span>imageView3 <span class="string">size:</span>imageViewSize <span class="string">left:</span>imageView2.mas_right <span class="string">centerY:</span>_containerView.mas_centerY];
[_widthConstraints <span class="string">addObject:</span>width];

UIImageView *imageView4 = _imageViews[<span class="number">3</span>];
width = [self <span class="string">setView:</span>imageView4 <span class="string">size:</span>imageViewSize <span class="string">left:</span>imageView3.mas_right <span class="string">centerY:</span>_containerView.mas_centerY];
[_widthConstraints <span class="string">addObject:</span>width];

<span class="comment">//最后设置最右边的imageView的右边与父view的最有对齐</span>
[imageView4 <span class="string">mas_makeConstraints:</span>^(MASConstraintMaker *make) {
    make.right.equalTo(_containerView.mas_right);
}];
</code></pre><p>控制ImageView显示、隐藏的时候，直接让其宽度等于0就行：</p>
<pre><code>- (<span class="keyword">IBAction</span>)showOrHideImage:(<span class="built_in">UISwitch</span> *)sender {
    <span class="built_in">NSUInteger</span> index = (<span class="built_in">NSUInteger</span>) sender<span class="variable">.tag</span>;
    MASConstraint *width = _widthConstraints[index];

    <span class="keyword">if</span> (sender<span class="variable">.on</span>) {
        width<span class="variable">.equalTo</span>(@(IMAGE_SIZE));
    } <span class="keyword">else</span> {
        width<span class="variable">.equalTo</span>(@<span class="number">0</span>);
    }
}
</code></pre><h3 id="小节-1">小节</h3><p>有时候用个“容器View”管理内部的View，往往会起到事半功倍的效果。而且在组织约束的时候，尽量的将约束统一起来，这样可以用一个函数去设置，减少代码量。</p>
<h2 id="Case_3:_子View的宽度始终是父级View的一半（或者任意百分比）">Case 3: 子View的宽度始终是父级View的一半（或者任意百分比）</h2><p>其实这个很简单=。= 再看看这个公式：</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewA-<span class="keyword">attribute</span> = viewB-<span class="keyword">attribute</span> * multiplier + <span class="keyword">constant</span></span><br></pre></td></tr></table></figure>
<p>这个是Autolayout里面一个约束的不同属性的基本组合关系，替换成宽度的话，就是下面这样：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子<span class="keyword">View</span>的宽度 = 父级<span class="keyword">View</span>宽度 * 系数 + 常数；</span><br></pre></td></tr></table></figure>
<p>在Masonry里面，其实有个函数“<strong>multipliedBy</strong>”，就是用来设置multipler属性的（跟原本的NSLayoutConstraint的对应）。</p>
<h3 id="关键代码-2">关键代码</h3><p>如下：</p>
<pre><code><span class="collection">[subView mas_makeConstraints:^<span class="list">(<span class="keyword">MASConstraintMaker</span> *make)</span> <span class="collection">{
    //上下左贴边
    make.left.equalTo<span class="list">(<span class="keyword">_containerView.mas_left</span>)</span><span class="comment">;</span>
    make.top.equalTo<span class="list">(<span class="keyword">_containerView.mas_top</span>)</span><span class="comment">;</span>
    make.bottom.equalTo<span class="list">(<span class="keyword">_containerView.mas_bottom</span>)</span><span class="comment">;</span>

    //宽度为父view的宽度的一半
    make.width.equalTo<span class="list">(<span class="keyword">_containerView.mas_width</span>)</span>.multipliedBy<span class="list">(<span class="number">0.5</span>)</span><span class="comment">;</span>
}</span>]</span><span class="comment">;</span>
</code></pre><p>接着，只要控制父级View的宽度，子View的宽度就会随着变化了。</p>
<h3 id="小节-2">小节</h3><p>multipliedBy在Masonry的Github主页里面没有=。=<br>所以要养成读头文件的习惯~</p>
<h2 id="总结">总结</h2><p>有关Autolayout的东西还有好多没有写，什么动画啊、动态修改约束之类的，本文也算是个引子吧，任重而道远~  </p>
<p>能看到这的朋友，也算是很有耐心了，哈哈~~</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://github.com/SnapKit/Masonry" target="_blank" rel="external">SnapKit/Masonry</a></li>
<li><a href="http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/" target="_blank" rel="external">Masonry介绍与使用实践(快速上手Autolayout)</a></li>
<li><a href="http://www.vienta.me/2014/12/07/AutoLayout-忘掉Frame-拥抱Constraint（I）/" target="_blank" rel="external">AutoLayout:忘掉Frame,拥抱Constraint</a></li>
<li><a href="https://www.zybuluo.com/MicroCai/note/73867#autolayout-基础" target="_blank" rel="external">Autolayout 基础</a></li>
<li><a href="http://codingobjc.com/blog/2015/01/28/autolayoutzhong-de-content-compression-resistancehe-content-huggingdao-di-shi-shi-yao-yi-si/" target="_blank" rel="external">对Auto Layout中的Content Compression Resistance和Content Hugging的总结</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/Introduction/Introduction.html" target="_blank" rel="external">Auto Layout Guide</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="更新">更新</h2><p>2015-11-27: 感谢“谢小雷”指出打字错误~<br>2015-9-1: 感谢“王振宇C艹”指出打字错误，已经修改了哈~<br>2015-9-10: 第二篇: <a href="http://tutuge.me/2015/08/08/autolayout-example-with-masonry2/">有趣的Autolayout示例2-Masonry实现</a></p>
<h2 id="前言">前言</h2><p>好久没有写Blog了，这段时间有点忙啊=。=<br>本文举了3个比较有“特点”的Autolayout例子，源于微博上好友的提问，感觉比较有意思，也比较有代表性，就写了出来，分享给大家~<br>至于为什么用Masonry，那是因为它好用啊！（被问到过有关Masonry的问题，就索性用它来实现吧=。=）。</p>
<h3 id="效果图">效果图</h3><p><img src="http://zorrochen.qiniudn.com/blog_autolayout_example_with_masonry_1.gif" alt="效果图"></p>
<h3 id="Github地址">Github地址</h3><p><a href="https://github.com/zekunyan/AutolayoutExampleWithMasonry">https://github.com/zekunyan/AutolayoutExampleWithMasonry</a></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UITextView编辑时插入自定义表情-续-自定义表情图片的大小]]></title>
    <link href="http://tutuge.me/2015/04/21/resizable-nstextattachment/"/>
    <id>http://tutuge.me/2015/04/21/resizable-nstextattachment/</id>
    <published>2015-04-21T12:26:17.000Z</published>
    <updated>2015-11-27T06:20:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="更新">更新</h2><ul>
<li>2015-11-27：增加了利用NSTextAttachment的bounds属性修改大小的方法。</li>
</ul>
<h2 id="前言">前言</h2><p>本文是基于<a href="http://tutuge.me/2015/03/07/UITextView编辑时插入自定义表情-简单的图文混编/">UITextView编辑时插入自定义表情-简单的图文混编</a>写的，主要实现了在UITextView插入表情图片时，自定义表情大小的功能。</p>
<h4 id="Github">Github</h4><p>本文代码工程地址：<a href="https://github.com/zekunyan/UITextViewDIYEmojiExample" target="_blank" rel="external">https://github.com/zekunyan/UITextViewDIYEmojiExample</a></p>
<h4 id="Gif示例图">Gif示例图</h4><p><img src="http://zorrochen.qiniudn.com/blog_resizable_nstextattachment_1.gif" alt="Gif示例图"></p>
<a id="more"></a>
<h2 id="关键点">关键点</h2><p>首先要明确我们要什么，很简单，就是<strong>指定NSTextAttachment在被绘制时的大小</strong>。  </p>
<p>所以，按照这个思路，就可以去找找NSTextAttachment类的相关方法，看能不能通过继承或其他的方式改变大小。</p>
<h3 id="方法1_-_NSTextAttachmentContainer">方法1 - NSTextAttachmentContainer</h3><p>NSTextAttachment实现了“<strong>NSTextAttachmentContainer</strong>”这个Protocol，而这个Protocol里面有如下方法：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(<span class="variable">CGRect</span>)</span>attachmentBoundsForTextContainer:<span class="params">(<span class="variable">NSTextContainer</span> *)</span>textContainer</span><br><span class="line">                      proposedLineFragment:<span class="params">(<span class="variable">CGRect</span>)</span>lineFrag</span><br><span class="line">                             glyphPosition:<span class="params">(<span class="variable">CGPoint</span>)</span>position</span><br><span class="line">                            characterIndex:<span class="params">(<span class="variable">NSUInteger</span>)</span>charIndex</span></span><br></pre></td></tr></table></figure>
<p>再看看其解释：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Returns <span class="operator">the</span> layout bounds <span class="operator">of</span> <span class="operator">the</span> <span class="keyword">text</span> attachment <span class="built_in">to</span> <span class="operator">the</span> layout manager. (required)</span><br></pre></td></tr></table></figure></p>
<p>也就是说，在绘制NSTextAttachment的内容的时候，内容的“Bounds”是通过这个方法获得的。所以，可以重写这个方法，来达到我们的目的。</p>
<h3 id="方法2_-_直接修改bounds">方法2 - 直接修改bounds</h3><p>NSTextAttachment还有一个属性<code>@property(nonatomic) CGRect bounds</code>，其解释如下：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Defines <span class="keyword">the</span> layout bounds <span class="keyword">of</span> <span class="keyword">the</span> receiver's graphical representation <span class="keyword">in</span> <span class="keyword">the</span> <span class="type">text</span> coordinate system.</span><br></pre></td></tr></table></figure></p>
<p>所以，修改这个也可以达到目的。</p>
<h2 id="实现方法1_-_继续扩展NSTextAttachment类">实现方法1 - 继续扩展NSTextAttachment类</h2><h3 id="保存自定义Size">保存自定义Size</h3><p>根据之前的定义，我们在自定义的类“EmojiTextAttachment”中再加一个保存大小的属性，如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EmojiTextAttachment类定义</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">EmojiTextAttachment </span>: NSTextAttachment</span><br><span class="line"><span class="comment">//表情的字符串表示，见前文</span></span><br><span class="line"><span class="variable">@property</span>(strong, nonatomic) NSString *emojiTag;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增：保存当前表情图片的大小</span></span><br><span class="line"><span class="variable">@property</span>(assign, nonatomic) CGSize emojiSize;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>有了“<strong>emojiSize</strong>”这个属性，我们就可以在自由的指定每个NSTextAttachment的大小。</p>
<h3 id="重写">重写</h3><p>接下来就是重写方法，不多说，见代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EmojiTextAttachment实现</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EmojiTextAttachment</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重点！重写NSTextAttachmentContainer Protocol的方法</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)attachmentBoundsForTextContainer:(<span class="built_in">NSTextContainer</span> *)textContainer proposedLineFragment:(<span class="built_in">CGRect</span>)lineFrag glyphPosition:(<span class="built_in">CGPoint</span>)position characterIndex:(<span class="built_in">NSUInteger</span>)charIndex &#123;</span><br><span class="line">	<span class="comment">// 返回我们指定的size</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, _emojiSize<span class="variable">.width</span>, _emojiSize<span class="variable">.height</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="实现方法2">实现方法2</h2><p>直接在创建表情NSTextAttachment的时候设置<code>bounds</code>属性即可。</p>
<h2 id="使用">使用</h2><p>增加了emojiSize属性后，我们就可以在创建表情，甚至创建后，自由的调整每个NSTextAttachment的大小。</p>
<h2 id="总结">总结</h2><p>一共只增加了十几行代码，但是效果还是不错哒~</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/NSTextAttachment_Class_TextKit/index.html#//apple_ref/occ/instp/NSTextAttachment/fileType" target="_blank" rel="external">NSTextAttachment</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/NSTextAttachmentContainer_Protocol/index.html#//apple_ref/occ/intfm/NSTextAttachmentContainer/attachmentBoundsForTextContainer:proposedLineFragment:glyphPosition:characterIndex:" target="_blank" rel="external">NSTextAttachmentContainer</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="更新">更新</h2><ul>
<li>2015-11-27：增加了利用NSTextAttachment的bounds属性修改大小的方法。</li>
</ul>
<h2 id="前言">前言</h2><p>本文是基于<a href="http://tutuge.me/2015/03/07/UITextView编辑时插入自定义表情-简单的图文混编/">UITextView编辑时插入自定义表情-简单的图文混编</a>写的，主要实现了在UITextView插入表情图片时，自定义表情大小的功能。</p>
<h4 id="Github">Github</h4><p>本文代码工程地址：<a href="https://github.com/zekunyan/UITextViewDIYEmojiExample">https://github.com/zekunyan/UITextViewDIYEmojiExample</a></p>
<h4 id="Gif示例图">Gif示例图</h4><p><img src="http://zorrochen.qiniudn.com/blog_resizable_nstextattachment_1.gif" alt="Gif示例图"></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RPC框架Thrift例子-PHP调用C++后端程序]]></title>
    <link href="http://tutuge.me/2015/04/19/thrift-example-cpp-and-php/"/>
    <id>http://tutuge.me/2015/04/19/thrift-example-cpp-and-php/</id>
    <published>2015-04-19T09:04:56.000Z</published>
    <updated>2015-09-24T10:57:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>前段时间用了一下Facebook的开源RPC框架Thrift，做PHP客户端调用C++后端程序，真心觉得Thrift不错！</p>
<p>本文项目地址：<a href="https://github.com/zekunyan/ThriftDemo_PHP_CPP" target="_blank" rel="external">https://github.com/zekunyan/ThriftDemo_PHP_CPP</a></p>
<p>先看看本文的例子示意图：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_thrift_example_cpp_and_php_1.jpg" alt="通信示意图"></p>
<p><strong>流程</strong></p>
<ol>
<li>PHP客户端发起请求，请求参数是“Request”类型，里面有studentID参数。</li>
<li>CPP服务端收到请求返回数据，返回类型为“Response”，里面包含了student的信息，此处只是简单的示例。</li>
</ol>
<a id="more"></a>
<h2 id="定义">定义</h2><h3 id="什么是RPC">什么是RPC</h3><p>远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。 – 维基百科 - <a href="http://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8" target="_blank" rel="external">远程过程调用</a></p>
<p>通俗点讲，就是跨计算机、跨网络调用。</p>
<h3 id="什么是Thrift">什么是Thrift</h3><p>Apache Thrift 是Facebook实现的一种高效的、支持多种编程语言的远程服务调用(RPC)的框架。它采用接口描述语言定义并创建服务，支持可扩展的跨语言服务开发，所包含的代码生成引擎可以在多种语言中，如 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, Smalltalk 等创建高效的、无缝的服务，其传输数据采用二进制格式，相对 XML 和 JSON 体积更小，对于高并发、大数据量和多语言的环境更有优势。 – <a href="https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/" target="_blank" rel="external">Apache Thrift - 可伸缩的跨语言服务开发框架</a></p>
<h2 id="开发流程">开发流程</h2><ol>
<li>配置环境。C++的如CMake、make、g++；PHP的如php、php-fpm、Apache（Nginx）。</li>
<li>根据需求，编写thrift接口定义文件（IDL定义文件）。</li>
<li>使用thrift程序，为不同的语言生成代码。</li>
<li>根据需求，修改生成的代码（主要是Server端），编写实际的业务逻辑。</li>
<li>编译、部署。</li>
</ol>
<h2 id="Thrift的接口定义文件">Thrift的接口定义文件</h2><p>在利用Thrift开发的过程中，重点就是编写接口定义文件。<br>一般来说，接口定义文件决定了RPC过程中的通信数据结构、通信接口定义等。</p>
<p>总的来说，thrift的接口定义语法类似于C语言，包含了struct、enum、map、list等基础数据结构，同时支持大部分基本数据类型，如32位整型“i32”等。</p>
<p>详细的接口定义请参考：</p>
<ul>
<li><a href="http://thrift.apache.org/docs/idl" target="_blank" rel="external">Thrift interface description language</a></li>
<li><a href="https://git-wip-us.apache.org/repos/asf?p=thrift.git;a=blob_plain;f=tutorial/tutorial.thrift" target="_blank" rel="external">example.thrift</a></li>
</ul>
<p>看看本例子中的定义文件“TTG.thrift”：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cpp TTG</span><br><span class="line"><span class="keyword">namespace</span> php TTG</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> ResponseState &#123;</span><br><span class="line">    StateOk = <span class="number">0</span>,</span><br><span class="line">    StateError = <span class="number">1</span>,</span><br><span class="line">    StateEmpty = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Request &#123;</span><br><span class="line">    <span class="number">1</span>: i32 studentID = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Response &#123;</span><br><span class="line">    <span class="number">1</span>: i32 studentID = <span class="number">0</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="built_in">string</span> name,</span><br><span class="line">    <span class="number">3</span>: <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; infos,</span><br><span class="line">    <span class="number">4</span>: ResponseState state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service TTGService &#123;</span><br><span class="line">    <span class="function">Response <span class="title">getStudentInfo</span><span class="params">(<span class="number">1</span>: Request request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>先定义命名空间，尽量减少命名冲突。</li>
<li>Request类型：PHP客户端请求的数据类型。</li>
<li>Response类型：CPP服务端返回的数据类型。</li>
<li>ResponseState枚举：定义返回的状态。</li>
<li>TTGService：服务接口定义。</li>
</ol>
<h2 id="生成对应语言的代码！">生成对应语言的代码！</h2><p>是的，生成代码！这是我觉得Thrift框架最“神奇”的地方。我们只需要执行几条命令，就可以根据接口定义文件“生成”对应语言的代码。然后我们只需要将对应的业务逻辑加入到生成的代码中即可。</p>
<p>如生成CPP服务端的代码：</p>
<pre><code>thrift <span class="comment">--gen cpp TTG.thrift</span>
</code></pre><p>然后就会生成如下代码。    </p>
<pre><code>TTGService<span class="class">.cpp</span>
TTGService<span class="class">.h</span>
TTGService_server<span class="class">.skeleton</span><span class="class">.cpp</span>
TTG_constants<span class="class">.cpp</span>
TTG_constants<span class="class">.h</span>
TTG_types<span class="class">.cpp</span>
TTG_types.h
</code></pre><h2 id="根据需要修改生成的代码">根据需要修改生成的代码</h2><p>生成CPP、PHP端的代码以后，我们就可以根据需要修改、添加业务代码。</p>
<h3 id="CPP服务端">CPP服务端</h3><p>在生成CPP的代码时，会生成一个“TTGService_server.skeleton.cpp”文件，这个就是我们的CPP服务端的代码“架子”。其中重点如下：</p>
<pre><code><span class="comment">//实现调用的接口</span>
<span class="keyword">class</span> TTGServiceHandler : <span class="keyword">virtual</span> <span class="keyword">public</span> TTGServiceIf {
 <span class="keyword">public</span>:
  TTGServiceHandler() {
    <span class="comment">// Your initialization goes here</span>
  }

  <span class="comment">//接口实现部分，实现getStudentInfo这个接口的具体细节，如根据request创建、返回对应的response</span>
  <span class="function"><span class="keyword">void</span> <span class="title">getStudentInfo</span><span class="params">(Response&amp; _return, <span class="keyword">const</span> Request&amp; request)</span> </span>{
    <span class="comment">// Your implementation goes here</span>
    <span class="built_in">printf</span>(<span class="string">"getStudentInfo\n"</span>);
  }

};
<span class="comment">//...</span>
</code></pre><p>我们将其改成：</p>
<pre><code>void getStudentInfo(Response &amp;_<span class="keyword">return</span>, <span class="keyword">const</span> Request &amp;request) {
    <span class="comment">// 输出请求参数</span>
    cout&lt;&lt;<span class="string">"Request: "</span>&lt;&lt;request.studentID&lt;&lt;endl;

    <span class="comment">// 创建返回数据</span>
    Response *response = new Response();

    <span class="comment">//填充数据</span>
    response-&gt;studentID = request.studentID;
    response-&gt;name = <span class="string">"tutuge"</span>;
    response-&gt;infos.push_back(<span class="string">"Info 1"</span>);
    response-&gt;infos.push_back(<span class="string">"Info 2"</span>);
    response-&gt;state = ResponseState::StateOk;

    <span class="comment">//返回</span>
    _<span class="keyword">return</span> = *response;
}
</code></pre><p>至此，CPP服务端的编写就完成了，接下来我们只需要编译、链接，执行最终生成的可执行文件即可。</p>
<h3 id="PHP客户端">PHP客户端</h3><p>PHP客户端的编写比较简单，直接参考代码吧：<a href="https://github.com/zekunyan/ThriftDemo_PHP_CPP/blob/master/PHP/client.php" target="_blank" rel="external">https://github.com/zekunyan/ThriftDemo_PHP_CPP/blob/master/PHP/client.php</a></p>
<h2 id="编译、链接，运行">编译、链接，运行</h2><p>用CMake，或者直接编写makefile均可，保证Thrift装好就行了。</p>
<p>直接运行最后生成的可执行文件TTG.run即可。</p>
<p>从浏览器，或者直接运行client.php，即可看到如下输出：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object(TTG\Response)[<span class="number">9</span>]  <span class="keyword">public</span> <span class="string">'studentID'</span> =&gt; <span class="keyword">int</span> <span class="number">100</span>  <span class="keyword">public</span> <span class="string">'name'</span> =&gt; string <span class="string">'tutuge'</span> (length=<span class="number">6</span>)  <span class="keyword">public</span> <span class="string">'infos'</span> =&gt;     <span class="keyword">array</span> (size=<span class="number">2</span>)      <span class="number">0</span> =&gt; string <span class="string">'Info 1'</span> (length=<span class="number">6</span>)      <span class="number">1</span> =&gt; string <span class="string">'Info 2'</span> (length=<span class="number">6</span>)  <span class="keyword">public</span> <span class="string">'state'</span> =&gt; <span class="keyword">int</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2><p>Thrift是个好东西！就是文档好少=。=</p>
<h2 id="参考">参考</h2><ul>
<li><a href="http://thrift.apache.org/" target="_blank" rel="external">Apache Thrift</a></li>
<li><a href="http://thrift.apache.org/tutorial/php" target="_blank" rel="external">Thrift PHP Tutorial</a></li>
<li><a href="http://thrift.apache.org/tutorial/cpp" target="_blank" rel="external">Thrift C++ Tutorial</a></li>
<li><a href="http://en.wikipedia.org/wiki/Apache_Thrift" target="_blank" rel="external">Apache Thrift</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift/" target="_blank" rel="external">Apache Thrift - 可伸缩的跨语言服务开发框架</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>前段时间用了一下Facebook的开源RPC框架Thrift，做PHP客户端调用C++后端程序，真心觉得Thrift不错！</p>
<p>本文项目地址：<a href="https://github.com/zekunyan/ThriftDemo_PHP_CPP">https://github.com/zekunyan/ThriftDemo_PHP_CPP</a></p>
<p>先看看本文的例子示意图：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_thrift_example_cpp_and_php_1.jpg" alt="通信示意图"></p>
<p><strong>流程</strong></p>
<ol>
<li>PHP客户端发起请求，请求参数是“Request”类型，里面有studentID参数。</li>
<li>CPP服务端收到请求返回数据，返回类型为“Response”，里面包含了student的信息，此处只是简单的示例。</li>
</ol>]]>
    
    </summary>
    
      <category term="C++" scheme="http://tutuge.me/tags/C/"/>
    
      <category term="PHP" scheme="http://tutuge.me/tags/PHP/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GCD使用经验与技巧浅谈]]></title>
    <link href="http://tutuge.me/2015/04/03/something-about-gcd/"/>
    <id>http://tutuge.me/2015/04/03/something-about-gcd/</id>
    <published>2015-04-03T13:59:56.000Z</published>
    <updated>2015-05-06T15:38:18.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>GCD(Grand Central Dispatch)可以说是Mac、iOS开发中的一大“利器”，本文就总结一些有关使用GCD的经验与技巧。</p>
<h2 id="dispatch_once_t必须是全局或static变量">dispatch_once_t必须是全局或static变量</h2><p>这一条算是“老生常谈”了，但我认为还是有必要强调一次，毕竟非全局或非static的dispatch_once_t变量在使用时会导致非常不好排查的bug，正确的如下：</p>
<pre><code><span class="comment">//静态变量，保证只有一份实例，才能确保只执行一次</span>
<span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;
<span class="built_in">dispatch_once</span>(&amp;onceToken, ^{
   <span class="comment">//单例代码 </span>
});
</code></pre><p>其实就是保证<strong>dispatch_once_t</strong>只有一份实例。</p>
<a id="more"></a>
<h2 id="dispatch_queue_create的第二个参数">dispatch_queue_create的第二个参数</h2><p><strong>dispatch_queue_create</strong>，创建队列用的，它的参数只有两个，原型如下：</p>
<pre><code><span class="keyword">dispatch_queue_t</span> dispatch_queue_create ( <span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="keyword">dispatch_queue_attr_t</span> attr );
</code></pre><p>在网上的大部分教程里（甚至Apple自己的文档里），都是这么创建串行队列的：</p>
<pre><code><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.example.MyQueue"</span>, <span class="literal">NULL</span>);
</code></pre><p>看，第二个参数传的是“<strong>NULL</strong>”。  但是dispatch_queue_attr_t类型是有已经定义好的常量的，所以我认为，为了更加的清晰、严谨，最好如下创建队列：</p>
<pre><code><span class="comment">//串行队列</span>
<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.example.MyQueue"</span>, DISPATCH_QUEUE_SERIAL);

<span class="comment">//并行队列</span>
<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.example.MyQueue"</span>, DISPATCH_QUEUE_CONCURRENT);
</code></pre><p>常量就是为了使代码更加“易懂”，更加清晰，既然有，为啥不用呢~</p>
<h2 id="dispatch_after是延迟提交，不是延迟运行">dispatch_after是<strong>延迟提交</strong>，不是<strong>延迟运行</strong></h2><p>先看看官方文档的说明：</p>
<pre><code>Enqueue <span class="operator">a</span> block <span class="keyword">for</span> execution <span class="keyword">at</span> <span class="operator">the</span> specified <span class="built_in">time</span>.
</code></pre><p><strong>Enqueue</strong>，就是入队，指的就是将一个Block在特定的延时以后，加入到指定的队列中，<strong>不是在特定的时间后立即运行！</strong>。</p>
<p>看看如下代码示例：</p>
<pre><code><span class="comment">//创建串行队列</span>
<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"me.tutuge.test.gcd"</span>, DISPATCH_QUEUE_SERIAL);

<span class="comment">//立即打印一条信息        </span>
NSLog(@<span class="string">"Begin add block..."</span>);        

<span class="comment">//提交一个block</span>
dispatch_async(<span class="built_in">queue</span>, ^{
    <span class="comment">//Sleep 10秒</span>
    [NSThread sleepForTimeInterval:<span class="number">10</span>];
    NSLog(@<span class="string">"First block done..."</span>);
});        

<span class="comment">//5 秒以后提交block</span>
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>)(<span class="number">5</span> * NSEC_PER_SEC)), <span class="built_in">queue</span>, ^{
    NSLog(@<span class="string">"After..."</span>);
});
</code></pre><p>结果如下：</p>
<pre><code><span class="number">2015</span>-<span class="number">03</span>-<span class="number">31</span> <span class="number">20</span>:<span class="number">57</span>:<span class="number">27.122</span> GCDTest[<span class="number">45633</span>:<span class="number">1812016</span>] Begin add block...
<span class="number">2015</span>-<span class="number">03</span>-<span class="number">31</span> <span class="number">20</span>:<span class="number">57</span>:<span class="number">37.127</span> GCDTest[<span class="number">45633</span>:<span class="number">1812041</span>] First block done...
<span class="number">2015</span>-<span class="number">03</span>-<span class="number">31</span> <span class="number">20</span>:<span class="number">57</span>:<span class="number">37.127</span> GCDTest[<span class="number">45633</span>:<span class="number">1812041</span>] After...
</code></pre><p>从结果也验证了，dispatch_after只是延时提交block，并不是延时后立即执行。所以想用dispatch_after精确控制运行状态的朋友可要注意了~</p>
<h2 id="正确创建dispatch_time_t">正确创建dispatch_time_t</h2><p>用dispatch_after的时候就会用到dispatch_time_t变量，但是如何创建合适的时间呢？答案就是用<strong>dispatch_time</strong>函数，其原型如下：</p>
<pre><code><span class="keyword">dispatch_time_t</span> dispatch_time ( <span class="keyword">dispatch_time_t</span> when, <span class="keyword">int64_t</span> delta );
</code></pre><p>第一个参数一般是<strong>DISPATCH_TIME_NOW</strong>，表示从现在开始。<br>那么第二个参数就是真正的延时的具体时间。</p>
<p>这里要特别注意的是，<strong>delta</strong>参数是“<strong>纳秒！</strong>”，就是说，延时1秒的话，delta应该是“1000000000”=。=，太长了，所以理所当然系统提供了常量，如下：</p>
<pre><code><span class="hexcolor">#def</span>ine NSEC_PER_SEC <span class="number">1000000000</span>ull
<span class="hexcolor">#def</span>ine USEC_PER_SEC <span class="number">1000000</span>ull
<span class="hexcolor">#def</span>ine NSEC_PER_USEC <span class="number">1000</span>ull
</code></pre><p>关键词解释：</p>
<ul>
<li>NSEC：纳秒。</li>
<li>USEC：微妙。</li>
<li>SEC：秒</li>
<li>PER：每</li>
</ul>
<p>所以：</p>
<ol>
<li>NSEC_PER_SEC，每秒有多少纳秒。</li>
<li>USEC_PER_SEC，每秒有多少毫秒。（注意是指在纳秒的基础上）</li>
<li>NSEC_PER_USEC，每毫秒有多少纳秒。</li>
</ol>
<p>所以，延时<strong>1秒</strong>可以写成如下几种：</p>
<pre><code>dispatch_time<span class="list">(<span class="keyword">DISPATCH_TIME_NOW</span>, <span class="number">1</span> <span class="variable">* NSEC_PER_SEC);
dispatch_time(DISPATCH_TIME_NOW, 1000 *</span> USEC_PER_SEC)</span><span class="comment">;</span>
dispatch_time<span class="list">(<span class="keyword">DISPATCH_TIME_NOW</span>, USEC_PER_SEC <span class="variable">* NSEC_PER_USEC);</span></span>
</code></pre><p>最后一个“<strong>USEC_PER_SEC * NSEC_PER_USEC</strong>”，翻译过来就是“<strong>每秒的毫秒数乘以每毫秒的纳秒数</strong>”，也就是“<strong>每秒的纳秒数</strong>”，所以，延时500毫秒之类的，也就不难了吧~</p>
<h2 id="dispatch_suspend_!=_立即停止队列的运行">dispatch_suspend != 立即停止队列的运行</h2><p><strong>dispatch_suspend</strong>，<strong>dispatch_resume</strong>提供了“挂起、恢复”队列的功能，简单来说，就是可以暂停、恢复队列上的任务。但是这里的“<strong>挂起</strong>”，并不能保证可以<strong>立即</strong>停止队列上正在运行的block，看如下例子：</p>
<pre><code><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"me.tutuge.test.gcd"</span>, DISPATCH_QUEUE_SERIAL);

<span class="comment">//提交第一个block，延时5秒打印。</span>
<span class="built_in">dispatch_async</span>(queue, ^{
    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];
    <span class="built_in">NSLog</span>(<span class="string">@"After 5 seconds..."</span>);
});

<span class="comment">//提交第二个block，也是延时5秒打印</span>
<span class="built_in">dispatch_async</span>(queue, ^{
    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];
    <span class="built_in">NSLog</span>(<span class="string">@"After 5 seconds again..."</span>);
});

<span class="comment">//延时一秒</span>
<span class="built_in">NSLog</span>(<span class="string">@"sleep 1 second..."</span>);
[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];

<span class="comment">//挂起队列                        </span>
<span class="built_in">NSLog</span>(<span class="string">@"suspend..."</span>);
dispatch_suspend(queue);

<span class="comment">//延时10秒                </span>
<span class="built_in">NSLog</span>(<span class="string">@"sleep 10 second..."</span>);
[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">10</span>];

<span class="comment">//恢复队列            </span>
<span class="built_in">NSLog</span>(<span class="string">@"resume..."</span>);
dispatch_resume(queue);
</code></pre><p>运行结果如下：</p>
<pre><code><span class="number">2015</span>-<span class="number">04</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">32</span>:<span class="number">09.903</span> GCDTest[<span class="number">47201</span>:<span class="number">1883834</span>] sleep <span class="number">1</span> second...
<span class="number">2015</span>-<span class="number">04</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">32</span>:<span class="number">10.910</span> GCDTest[<span class="number">47201</span>:<span class="number">1883834</span>] suspend...
<span class="number">2015</span>-<span class="number">04</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">32</span>:<span class="number">10.910</span> GCDTest[<span class="number">47201</span>:<span class="number">1883834</span>] sleep <span class="number">10</span> second...
<span class="number">2015</span>-<span class="number">04</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">32</span>:<span class="number">14.908</span> GCDTest[<span class="number">47201</span>:<span class="number">1883856</span>] After <span class="number">5</span> seconds...
<span class="number">2015</span>-<span class="number">04</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">32</span>:<span class="number">20.911</span> GCDTest[<span class="number">47201</span>:<span class="number">1883834</span>] resume...
<span class="number">2015</span>-<span class="number">04</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">32</span>:<span class="number">25.912</span> GCDTest[<span class="number">47201</span>:<span class="number">1883856</span>] After <span class="number">5</span> seconds again...    
</code></pre><p>可知，在dispatch_suspend挂起队列后，第一个block<strong>还是在运行</strong>，并且正常输出。<br>结合文档，我们可以得知，dispatch_suspend并不会立即暂停正在运行的block，而是在当前block执行完成后，暂停后续的block执行。</p>
<p>所以下次想暂停正在队列上运行的block时，还是不要用dispatch_suspend了吧~</p>
<h2 id="“同步”的dispatch_apply">“同步”的dispatch_apply</h2><p>dispatch_apply的作用是在一个队列（串行或并行）上“运行”多次block，其实就是简化了用循环去向队列依次添加block任务。但是我个人觉得这个函数就是个“坑”，先看看如下代码运行结果：</p>
<pre><code><span class="comment">//创建异步串行队列</span>
<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"me.tutuge.test.gcd"</span>, DISPATCH_QUEUE_SERIAL);

<span class="comment">//运行block3次</span>
dispatch_apply(<span class="number">3</span>, <span class="built_in">queue</span>, ^(<span class="keyword">size_t</span> i) {
    NSLog(@<span class="string">"apply loop: %zu"</span>, i);
});

<span class="comment">//打印信息</span>
NSLog(@<span class="string">"After apply"</span>);
</code></pre><p>运行的结果是：</p>
<pre><code><span class="number">2015</span>-<span class="number">04</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">55</span>:<span class="number">40.854</span> GCDTest[<span class="number">47402</span>:<span class="number">1893289</span>] apply loop: <span class="number">0</span>
<span class="number">2015</span>-<span class="number">04</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">55</span>:<span class="number">40.856</span> GCDTest[<span class="number">47402</span>:<span class="number">1893289</span>] apply loop: <span class="number">1</span>
<span class="number">2015</span>-<span class="number">04</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">55</span>:<span class="number">40.856</span> GCDTest[<span class="number">47402</span>:<span class="number">1893289</span>] apply loop: <span class="number">2</span>
<span class="number">2015</span>-<span class="number">04</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">55</span>:<span class="number">40.856</span> GCDTest[<span class="number">47402</span>:<span class="number">1893289</span>] After apply
</code></pre><p>看，明明是提交到异步的队列去运行，但是“After apply”居然在apply后打印，也就是说，dispatch_apply将外面的线程（main线程）<strong>“阻塞”</strong>了！</p>
<p>查看官方文档，dispatch_apply确实会“等待”其所有的循环运行完毕才往下执行=。=，看来要小心使用了。</p>
<h2 id="避免死锁！">避免死锁！</h2><h4 id="dispatch_sync导致的死锁">dispatch_sync导致的死锁</h4><p>涉及到多线程的时候，不可避免的就会有“死锁”这个问题，在使用GCD时，往往一不小心，就可能造成死锁，看看下面的“<strong>死锁</strong>”例子：</p>
<pre><code><span class="comment">//在main线程使用“同步”方法提交Block，必定会死锁。</span>
<span class="function">dispatch_sync</span>(<span class="function">dispatch_get_main_queue</span>(), ^{
    <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"I am block..."</span>);</span>
});
</code></pre><p>你可能会说，这么低级的错误，我怎么会犯，那么，看看下面的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)update<span class="built_in">UI1</span> &#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Update ui 1"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//死锁！</span></span><br><span class="line">        [<span class="keyword">self</span> update<span class="built_in">UI2</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)update<span class="built_in">UI2</span> &#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Update ui 2"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在你不注意的时候，嵌套调用可能就会造成死锁！所以为了“世界和平”=。=，我们还是少用<strong>dispatch_sync</strong>吧。</p>
<h4 id="dispatch_apply导致的死锁！">dispatch_apply导致的死锁！</h4><p>啥，dispatch_apply导致的死锁？。。。是的，前一节讲到，dispatch_apply会<strong>等</strong>循环执行完成，这不就差不多是<strong>阻塞</strong>了吗。看如下例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"me.tutuge.test.gcd"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">       </span><br><span class="line">dispatch_apply(<span class="number">3</span>, <span class="built_in">queue</span>, ^(<span class="keyword">size_t</span> i) &#123;</span><br><span class="line">	NSLog(@<span class="string">"apply loop: %zu"</span>, i);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//再来一个dispatch_apply！死锁！      </span></span><br><span class="line">	dispatch_apply(<span class="number">3</span>, <span class="built_in">queue</span>, ^(<span class="keyword">size_t</span> j) &#123;</span><br><span class="line">		NSLog(@<span class="string">"apply loop inside %zu"</span>, j);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这端代码只会输出“apply loop: 1”。。。就没有然后了=。=</p>
<p>所以，一定要避免dispatch_apply的<strong>嵌套调用</strong>。</p>
<h2 id="灵活使用dispatch_group">灵活使用dispatch_group</h2><p>很多时候我们需要等待一系列任务（block）执行完成，然后再做一些收尾的工作。如果是有序的任务，可以分步骤完成的，直接使用串行队列就行。但是如果是一系列<strong>并行</strong>执行的任务呢？这个时候，就需要dispatch_group帮忙了~总的来说，dispatch_group的使用分如下几步：</p>
<ol>
<li>创建dispatch_group_t</li>
<li>添加任务（block）</li>
<li>添加结束任务（如清理操作、通知UI等）</li>
</ol>
<p>下面着重讲讲在后面两步。</p>
<h4 id="添加任务">添加任务</h4><p>添加任务可以分为以下两种情况：</p>
<ol>
<li>自己创建队列：使用<strong>dispatch_group_async</strong>。</li>
<li>无法直接使用队列变量（如使用AFNetworking添加异步任务）：使用<strong>dispatch_group_enter</strong>，<strong>dispatch_group_leave</strong>。</li>
</ol>
<p>自己创建队列时，当然就用dispatch_group_async函数，简单有效，简单例子如下：</p>
<pre><code><span class="comment">//省去创建group、queue代码。。。</span>

dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^{
    <span class="comment">//Do you work...</span>
});
</code></pre><p>当你无法直接使用队列变量时，就无法使用dispatch_group_async了，下面以使用AFNetworking时的情况：</p>
<pre><code><span class="type">AFHTTPRequestOperationManager</span> *manager = [<span class="type">AFHTTPRequestOperationManager</span> manager];

//<span class="type">Enter</span> group
dispatch_group_enter(group);
[manager <span class="type">GET</span>:@<span class="string">"http://www.baidu.com"</span> parameters:<span class="keyword">nil</span> success:^(<span class="type">AFHTTPRequestOperation</span> *operation, id responseObject) {
    //<span class="type">Deal</span> <span class="keyword">with</span> <span class="literal">result</span>...

    //<span class="type">Leave</span> group
    dispatch_group_leave(group);
}    failure:^(<span class="type">AFHTTPRequestOperation</span> *operation, <span class="type">NSError</span> *error) {
    //<span class="type">Deal</span> <span class="keyword">with</span> error...

    //<span class="type">Leave</span> group
    dispatch_group_leave(group);
}];

//<span class="type">More</span> request...
</code></pre><p>使用<strong>dispatch_group_enter</strong>，<strong>dispatch_group_leave</strong>就可以方便的将一系列网络请求“<strong>打包</strong>”起来~</p>
<h4 id="添加结束任务">添加结束任务</h4><p>添加结束任务也可以分为两种情况，如下：</p>
<ol>
<li>在当前线程<strong>阻塞的同步等待</strong>：dispatch_group_wait。</li>
<li>添加一个异步执行的任务作为结束任务：dispatch_group_notify</li>
</ol>
<p>这两个比较简单，就不再贴代码了=。=</p>
<h2 id="使用dispatch_barrier_async,dispatch_barrier_sync的注意事项">使用dispatch_barrier_async,dispatch_barrier_sync的注意事项</h2><p>dispatch_barrier_async的作用就是向某个队列插入一个block，当目前正在执行的block运行完成后，阻塞这个block后面添加的block，只运行这个block直到完成，然后再继续后续的任务，有点“唯我独尊”的感觉=。=</p>
<p>值得注意的是：</p>
<ol>
<li>dispatch<em>barrier\</em>(a)sync只在自己创建的并发队列上有效，在全局(Global)并发队列、串行队列上，效果跟<strong>dispatch_(a)sync</strong>效果一样。</li>
<li>既然在串行队列上跟<strong>dispatch_(a)sync</strong>效果一样，那就要小心别死锁！</li>
</ol>
<h2 id="dispatch_set_context与dispatch_set_finalizer_f的配合使用">dispatch_set_context与dispatch_set_finalizer_f的配合使用</h2><p>dispatch_set_context可以为队列添加<strong>上下文数据</strong>，但是因为GCD是C语言接口形式的，所以其context参数类型是“<strong>void *</strong>”。也就是说，我们创建context时有如下几种选择：</p>
<ol>
<li>用C语言的malloc创建context数据。</li>
<li>用C++的new创建类对象。</li>
<li>用Objective-C的对象，但是要用__bridge等关键字转为Core Foundation对象。</li>
</ol>
<p>以上所有创建context的方法都有一个必须的要求，就是都要<strong>释放内存！</strong>，无论是用<strong>free、delete还是CF的CFRelease</strong>，我们都要确保在队列不用的时候，释放context的内存，否则就会造成内存泄露。</p>
<p>所以，使用dispatch_set_context的时候，最好结合dispatch_set_finalizer_f使用，为队列设置“析构函数”，在这个函数里面释放内存，大致如下：</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">cleanStaff</span><span class="params">(<span class="keyword">void</span> *context)</span> </span>{
    <span class="comment">//释放context的内存！</span>

    <span class="comment">//CFRelease(context);</span>
    <span class="comment">//free(context);</span>
    <span class="comment">//delete context;</span>
}

...

<span class="comment">//在队列创建后，设置其“析构函数”</span>
dispatch_set_finalizer_f(<span class="built_in">queue</span>, cleanStaff);
</code></pre><p>详细用法，请看我之前写的Blog<a href="http://tutuge.me/2015/03/29/bind-data-to-gcd-queue/">为GCD队列绑定NSObject类型上下文数据-利用__bridge_retained(transfer)转移内存管理权</a></p>
<h2 id="总结">总结</h2><p>其实本文更像是总结了GCD中的“坑”=。=</p>
<p>至于经验，总结一条，就是使用任何技术，都要研究透彻，否则后患无穷啊~</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/prerelease/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html" target="_blank" rel="external">Grand Central Dispatch (GCD) Reference</a></li>
<li><a href="https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091" target="_blank" rel="external">Concurrency Programming Guide</a></li>
<li><a href="http://commandshift.co.uk/blog/2014/03/19/using-dispatch-groups-to-wait-for-multiple-web-services" target="_blank" rel="external">Using Dispatch Groups to Wait for Multiple Web Services</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>GCD(Grand Central Dispatch)可以说是Mac、iOS开发中的一大“利器”，本文就总结一些有关使用GCD的经验与技巧。</p>
<h2 id="dispatch_once_t必须是全局或static变量">dispatch_once_t必须是全局或static变量</h2><p>这一条算是“老生常谈”了，但我认为还是有必要强调一次，毕竟非全局或非static的dispatch_once_t变量在使用时会导致非常不好排查的bug，正确的如下：</p>
<pre><code><span class="comment">//静态变量，保证只有一份实例，才能确保只执行一次</span>
<span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;
<span class="built_in">dispatch_once</span>(&amp;onceToken, ^{
   <span class="comment">//单例代码 </span>
});
</code></pre><p>其实就是保证<strong>dispatch_once_t</strong>只有一份实例。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为GCD队列绑定NSObject类型上下文数据-利用__bridge_retained(transfer)转移内存管理权]]></title>
    <link href="http://tutuge.me/2015/03/29/bind-data-to-gcd-queue/"/>
    <id>http://tutuge.me/2015/03/29/bind-data-to-gcd-queue/</id>
    <published>2015-03-29T11:27:40.000Z</published>
    <updated>2015-05-28T09:11:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="2015-5-28更新">2015-5-28更新</h2><p>下面评论的好友“@Jim”给了种新的思路，就是在清除context的函数里面，用“<strong>_bridge_transfer</strong>”转换context，把context的内存管理权限重新交给ARC，这样，就不用显式调用“<strong>CFRelease</strong>”了。如下：</p>
<pre><code><span class="literal">void</span> cleanStaff(<span class="literal">void</span> *context) {
    <span class="comment">//这里用_bridge_transfer转换，将内存管理权限交还给ARC</span>
    <span class="built_in">Data</span> *<span class="built_in">data</span> = (_bridge_transfer <span class="built_in">Data</span> *)(context);
    NSLog(@<span class="string">"In clean, context number: %d"</span>, <span class="built_in">data</span><span class="built_in">.</span>number);

    <span class="comment">//不用显式释放context的内存！</span>
}
</code></pre><h2 id="前言">前言</h2><p>看过GCD（Grand Central Dispatch）的Apple<a href="https://developer.apple.com/library/prerelease/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html" target="_blank" rel="external">官方文档</a>的朋友一定见过“<strong>dispatch_set_context</strong>”和“<strong>dispatch_get_context</strong>”这两个函数，那么这两个函数该怎么用呢？  </p>
<p>我们都知道，GCD的接口参数都是“C语言类型“的，那么，我们如何将NSObject类型（Foundation框架）的数据，传入GCD的接口呢？（即：Core Foundation和Foundation对象的转换）</p>
<h2 id="本文关键字">本文关键字</h2><ul>
<li>GCD：dispatch_set_context，dispatch_get_context</li>
<li>__bridge，__bridge_retained，__bridge_transfer</li>
<li>Core Foundation, NSObject</li>
</ul>
<a id="more"></a>
<h2 id="dispatch_set(get)_context">dispatch_set(get)_context</h2><p>先看看这两个函数的原型：</p>
<pre><code><span class="comment">//设置context</span>
<span class="keyword">void</span> dispatch<span class="number">_</span>set<span class="number">_</span>context ( dispatch<span class="number">_</span><span class="keyword">object</span><span class="number">_</span>t <span class="keyword">object</span>, <span class="keyword">void</span> *context );
<span class="comment">//获取context</span>
<span class="keyword">void</span> * dispatch<span class="number">_</span>get<span class="number">_</span>context ( dispatch<span class="number">_</span><span class="keyword">object</span><span class="number">_</span>t <span class="keyword">object</span> );
</code></pre><p>这里的object一般指的就是通过dispatch_queue_create创建的队列。 </p>
<p>所以，这两个函数分别完成了将context“绑定”到特定GCD队列和从GCD队列获取对应context的任务。</p>
<h3 id="什么是context">什么是context</h3><p>在上述函数原型中，context是一个“<strong>void类型指针</strong>”，学过C语言的朋友应该都知道，void型指针可以指向任意类型，就是说，context在这里可以是任意类型的指针。</p>
<p>从这里可以得知，我们可以为队列“<strong>set</strong>”任意类型的数据，并在合适的时候取出来用。</p>
<h2 id="用malloc创建context并绑定到队列上">用malloc创建context并绑定到队列上</h2><p>参考<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW13" target="_blank" rel="external">Apple官方的例子</a>，我们先用传统的<strong>malloc</strong>创建context，看看如下简短例子：</p>
<pre><code><span class="comment">//定义context，即一个结构体</span>
typedef struct _Data {
    int number;
} <span class="built_in">Data</span>;

<span class="comment">//定义队列的finalizer函数，用于释放context内存</span>
<span class="literal">void</span> cleanStaff(<span class="literal">void</span> *context) {
    NSLog(@<span class="string">"In clean, context number: %d"</span>, ((<span class="built_in">Data</span> *)context)<span class="subst">-&gt;</span>number);
    <span class="comment">//释放，如果是new出来的对象，就要用delete</span>
    free(context);
}

- (<span class="literal">void</span>)testBody {
    <span class="comment">//创建队列</span>
    dispatch_queue_t <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"me.tutuge.test.gcd"</span>, DISPATCH_QUEUE_SERIAL);

    <span class="comment">//创建Data类型context数据并初始化</span>
    <span class="built_in">Data</span> *myData = malloc(sizeof(<span class="built_in">Data</span>));
    myData<span class="subst">-&gt;</span>number = <span class="number">10</span>;

    <span class="comment">//绑定context</span>
    dispatch_set_context(<span class="built_in">queue</span>, myData);

    <span class="comment">//设置finalizer函数，用于在队列执行完成后释放对应context内存</span>
    dispatch_set_finalizer_f(<span class="built_in">queue</span>, cleanStaff);

    dispatch_async(<span class="built_in">queue</span>, ^{
        <span class="comment">//获取队列的context数据</span>
        <span class="built_in">Data</span> *<span class="built_in">data</span> = dispatch_get_context(<span class="built_in">queue</span>);
        <span class="comment">//打印</span>
        NSLog(@<span class="string">"1: context number: %d"</span>, <span class="built_in">data</span><span class="subst">-&gt;</span>number);
        <span class="comment">//修改context保存的数据</span>
        <span class="built_in">data</span><span class="subst">-&gt;</span>number = <span class="number">20</span>;
    });
}
</code></pre><p>上面的代码运行后如下：</p>
<pre><code><span class="number">2015</span>-<span class="number">03</span>-<span class="number">29</span> <span class="number">20</span>:<span class="number">28</span>:<span class="number">16.854</span> GCDTest[<span class="number">37787</span>:<span class="number">1443423</span>] <span class="number">1</span>: context number: <span class="number">10</span>
<span class="number">2015</span>-<span class="number">03</span>-<span class="number">29</span> <span class="number">20</span>:<span class="number">28</span>:<span class="number">16.855</span> GCDTest[<span class="number">37787</span>:<span class="number">1443423</span>] In clean, context number: <span class="number">20</span>
</code></pre><p>看，通过为队列设置context，我们就能为队列绑定自定义的数据，然后在合适的时候取出来用。</p>
<h2 id="NSObject类型的context">NSObject类型的context</h2><p>在Mac、iOS的开发过程中，我们大部分用的都是Foundation框架下的类，就是如NSString、NSDictionary这些NSObject类型的类。<br>但是上面的<strong>dispatch_set(get)_context</strong>接受的context参数是C语言类型的，即Core Foundation类型的，我们如何转换呢？</p>
<p><strong>由于ARC不能管理Core Foundation Object的生命周期</strong>，所以我们必须先转换context的“类型”，以便转换内存管理权。</p>
<h3 id="__bridge">__bridge</h3><p>Apple已经为我们提供了用于转换的关键字，如下：</p>
<ul>
<li>__bridge: 只做了类型转换，不修改内存管理权；</li>
<li>__bridge_retained（即CFBridgingRetain）转换类型，同时将内存管理权从ARC中移除，后面需要使用CFRelease来释放对象；</li>
<li>__bridge_transfer（即CFBridgingRelease）将Core Foundation的对象转换为Objective-C的对象，同时将内存管理权交给ARC。</li>
</ul>
<h3 id="重新定义context">重新定义context</h3><p>为了方便下面的说明，我们先定义context类。</p>
<pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">Data</span> : <span class="title">NSObject</span></span>
<span class="keyword">@property</span>(<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">int</span> number;
<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">Data</span></span>

<span class="comment">//继承dealloc方法，便于观察对象何时被释放</span>
- (<span class="keyword">void</span>)dealloc {
    <span class="built_in">NSLog</span>(<span class="string">@"Data dealloc..."</span>);
}

<span class="keyword">@end</span>
</code></pre><p>看，我们继承了<strong>dealloc</strong>方法，这样就能知道Data类型对象什么时候被释放。</p>
<h3 id="需要注意的点">需要注意的点</h3><p><strong>__bridge</strong>的转换是没有转移内存管理权的，这点要特别注意。  </p>
<p>如果在传context对象时，用的是<strong>__bridge</strong>转换，那么context对象的内存管理权还在ARC手里，一旦当前作用域执行完，context就会被释放，而如果队列的任务用了context对象，就会造成“<strong>EXC_BAD_ACCESS</strong>”崩溃！</p>
<h3 id="正确的用法">正确的用法</h3><p>重写上面的例子，如下：</p>
<pre><code><span class="comment">//定义队列的finalizer函数，用于释放context内存</span>
<span class="function"><span class="keyword">void</span> <span class="title">cleanStaff</span><span class="params">(<span class="keyword">void</span> *context)</span> </span>{
    <span class="comment">//这里用__bridge转换，不改变内存管理权</span>
    Data *data = (__bridge Data *)(context);
    NSLog(@<span class="string">"In clean, context number: %d"</span>, data.number);

    <span class="comment">//释放context的内存！</span>
    CFRelease(context);
}

- (<span class="keyword">void</span>)testBody {
    <span class="comment">//创建队列</span>
    <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"me.tutuge.test.gcd"</span>, DISPATCH_QUEUE_SERIAL);

    <span class="comment">//创建Data类型context数据并初始化</span>
    Data *myData = [Data <span class="keyword">new</span>];
    myData.number = <span class="number">10</span>;

    <span class="comment">//绑定context</span>
    <span class="comment">//这里用__bridge_retained转换，将context的内存管理权从ARC移除，交由我们自己手动释放！</span>
    dispatch_set_context(<span class="built_in">queue</span>, (__bridge_retained <span class="keyword">void</span> *)(myData));

    <span class="comment">//设置finalizer函数，用于在队列执行完成后释放对应context内存</span>
    dispatch_set_finalizer_f(<span class="built_in">queue</span>, cleanStaff);

    dispatch_async(<span class="built_in">queue</span>, ^{
        <span class="comment">//获取队列的context数据</span>
        <span class="comment">//这里用__bridge转换，不改变内存管理权</span>
        Data *data = (__bridge Data *)(dispatch_get_context(<span class="built_in">queue</span>));
        <span class="comment">//打印</span>
        NSLog(@<span class="string">"1: context number: %d"</span>, data.number);
        <span class="comment">//修改context保存的数据</span>
        data.number = <span class="number">20</span>;
    });
}
</code></pre><h4 id="解释">解释</h4><ul>
<li>在dispatch_set_context的时候用<strong>__bridge_retained</strong>转换，将context的内存管理权从ARC移除，交给我们自己管理。</li>
<li>在队列任务中，用dispatch_get_context获取context的时候，用<strong>__bridge</strong>转换，维持context的内存管理权不变，防止出了作用域context被释放。</li>
<li>最后用<strong>CFRelease</strong>释放context内存。</li>
</ul>
<h3 id="运行结果">运行结果</h3><pre><code><span class="number">2015</span>-<span class="number">03</span>-<span class="number">29</span> <span class="number">21</span>:<span class="number">12</span>:<span class="number">41.631</span> GCDTest[<span class="number">38131</span>:<span class="number">1465900</span>] <span class="number">1</span>: context number: <span class="number">10</span>
<span class="number">2015</span>-<span class="number">03</span>-<span class="number">29</span> <span class="number">21</span>:<span class="number">12</span>:<span class="number">41.632</span> GCDTest[<span class="number">38131</span>:<span class="number">1465900</span>] In clean, context number: <span class="number">20</span>
<span class="number">2015</span>-<span class="number">03</span>-<span class="number">29</span> <span class="number">21</span>:<span class="number">12</span>:<span class="number">41.632</span> GCDTest[<span class="number">38131</span>:<span class="number">1465900</span>] Data dealloc...
</code></pre><p>由结果可知，我们的context对象在最后显式调用<strong>CFRelease</strong>才被释放。</p>
<h2 id="总结">总结</h2><p>总的来说，就是合理运用__bridge_retained(transfer)关键字转换对象的内存管理权，让我们自己控制对象的生命周期。</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/prerelease/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html" target="_blank" rel="external">Grand Central Dispatch (GCD) Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW13" target="_blank" rel="external">Concurrency Programming Guide</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html" target="_blank" rel="external">Toll-Free Bridged Types</a></li>
<li><a href="http://blog.csdn.net/diyagoanyhacker/article/details/7573801" target="_blank" rel="external">Core Foundation 框架</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="2015-5-28更新">2015-5-28更新</h2><p>下面评论的好友“@Jim”给了种新的思路，就是在清除context的函数里面，用“<strong>_bridge_transfer</strong>”转换context，把context的内存管理权限重新交给ARC，这样，就不用显式调用“<strong>CFRelease</strong>”了。如下：</p>
<pre><code><span class="literal">void</span> cleanStaff(<span class="literal">void</span> *context) {
    <span class="comment">//这里用_bridge_transfer转换，将内存管理权限交还给ARC</span>
    <span class="built_in">Data</span> *<span class="built_in">data</span> = (_bridge_transfer <span class="built_in">Data</span> *)(context);
    NSLog(@<span class="string">"In clean, context number: %d"</span>, <span class="built_in">data</span><span class="built_in">.</span>number);

    <span class="comment">//不用显式释放context的内存！</span>
}
</code></pre><h2 id="前言">前言</h2><p>看过GCD（Grand Central Dispatch）的Apple<a href="https://developer.apple.com/library/prerelease/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html">官方文档</a>的朋友一定见过“<strong>dispatch_set_context</strong>”和“<strong>dispatch_get_context</strong>”这两个函数，那么这两个函数该怎么用呢？  </p>
<p>我们都知道，GCD的接口参数都是“C语言类型“的，那么，我们如何将NSObject类型（Foundation框架）的数据，传入GCD的接口呢？（即：Core Foundation和Foundation对象的转换）</p>
<h2 id="本文关键字">本文关键字</h2><ul>
<li>GCD：dispatch_set_context，dispatch_get_context</li>
<li>__bridge，__bridge_retained，__bridge_transfer</li>
<li>Core Foundation, NSObject</li>
</ul>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Enum-枚举的正确使用-Effective-Objective-C-读书笔记-Item-5]]></title>
    <link href="http://tutuge.me/2015/03/21/effective-objective-c-5-enum/"/>
    <id>http://tutuge.me/2015/03/21/effective-objective-c-5-enum/</id>
    <published>2015-03-21T12:52:57.000Z</published>
    <updated>2015-09-24T11:00:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>Enum，也就是枚举，从C语言开始就有了，C++、Java、Objective-C、Swift这些语言，当然都有对应的枚举类型，功能可能有多有少，但是最核心的还是一个—规范的定义代码中的状态、选项等“常量”。</p>
<h2 id="Item_5_-_Use_Enumerations_for_States,_Options,_and_Status_Codes">Item 5 - Use Enumerations for States, Options, and Status Codes</h2><p>本节的内容就是如何正确的使用枚举。</p>
<h2 id="状态与选项的区别（states_and_options）">状态与选项的区别（states and options）</h2><p>在用<strong>enum</strong>之前，我个人觉得，区分一下状态和选项的概念还是很必要的。</p>
<p><strong>状态</strong>，同时只能有一种，如“<strong>OK</strong>”，“<strong>Error</strong>”，不可能同时是OK和Error。<br><strong>选项</strong>，同时可以有一种或一种以上，如App可以<strong>同时</strong>支持横屏和竖屏，横屏竖屏在这个时候就是“屏幕方向”的两种不同的选项。</p>
<p>接下来，我们看看如何用枚举定义状态和选项。</p>
<a id="more"></a>
<h2 id="enum与状态（states）">enum与状态（states）</h2><h4 id="不好的做法">不好的做法</h4><p>经常看到这样的写法：</p>
<pre><code><span class="preprocessor">#<span class="keyword">define</span> STATE_OK <span class="number">0</span></span>
<span class="preprocessor">#<span class="keyword">define</span> STATE_ERROR <span class="number">1</span></span>
<span class="preprocessor">#<span class="keyword">define</span> STATE_UNKNOW <span class="number">2</span></span>

<span class="comment">//直接用int型变量接收</span>
<span class="keyword">int</span> STATE = STATE_UNKNOW;
</code></pre><p>这样做有如下“不恰当”：</p>
<ul>
<li>宏定义没有类型约束，只是单纯的替换。</li>
<li>无法限制状态的所有情况，如，认为的将STATE赋值成3，程序可能就会出错，找不到匹配的状态，因为编译器不会对“<strong>STATE = 3;</strong>”提出警告。</li>
</ul>
<h4 id="正确的做法">正确的做法</h4><pre><code>typedef <span class="class"><span class="keyword">enum</span> <span class="title">_TTGState</span> {</span>
    <span class="constant">TTGStateOK</span>  = <span class="number">0</span>,
    <span class="constant">TTGStateError</span>,
    <span class="constant">TTGStateUnknow</span>
} <span class="constant">TTGState</span>;

<span class="regexp">//</span>指明枚举类型
<span class="constant">TTGState</span> state = <span class="constant">TTGStateOK</span>;
</code></pre><p>用的时候就如下：</p>
<pre><code>- (<span class="typename">void</span>)<span class="string">dealWithState:</span>(TTGState)state {
    <span class="keyword">switch</span> (state) {
        <span class="keyword">case</span> <span class="string">TTGStateOK:</span>
            <span class="comment">//...</span>
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="string">TTGStateError:</span>
            <span class="comment">//...</span>
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="string">TTGStateUnknow:</span>
            <span class="comment">//...</span>
            <span class="keyword">break</span>;
    }
}
</code></pre><h2 id="enum与选项_(options)">enum与选项 (options)</h2><p>选项，就是说一个“选项变量”的类型要能够同时表示一个或多个组合的选择，如下例子：</p>
<pre><code><span class="comment">//方向，可同时支持一个或多个方向</span>
<span class="keyword">typedef</span> <span class="keyword">enum</span> _TTGDirection {
    TTGDirectionNone = <span class="number">0</span>,
    TTGDirectionTop = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,
    TTGDirectionLeft = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,
    TTGDirectionRight = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,
    TTGDirectionBottom = <span class="number">1</span> &lt;&lt; <span class="number">3</span>
} TTGDirection;
</code></pre><p>看，这里的选项是用<strong>位运算</strong>的方式定义的，这样的好处就是，我们的选项变量可以如下表示：</p>
<pre><code><span class="comment">//用“或”运算同时赋值多个选项</span>
TTGDirection direction = TTGDirectionTop | TTGDirectionLeft | TTGDirectionBottom;

<span class="comment">//用“与”运算取出对应位</span>
<span class="keyword">if</span> (direction &amp; TTGDirectionTop) {
    <span class="built_in">NSLog</span>(<span class="string">@"top"</span>);
}
<span class="keyword">if</span> (direction &amp; TTGDirectionLeft) {
    <span class="built_in">NSLog</span>(<span class="string">@"left"</span>);
}
<span class="keyword">if</span> (direction &amp; TTGDirectionRight) {
    <span class="built_in">NSLog</span>(<span class="string">@"right"</span>);
}
<span class="keyword">if</span> (direction &amp; TTGDirectionBottom) {
    <span class="built_in">NSLog</span>(<span class="string">@"bottom"</span>);
}
</code></pre><p><strong>direction</strong>变量的实际内存如下：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_effective_objective_c_5_enum_2.jpg" alt="内存示意图"></p>
<p>这样，用位运算，就可以同时支持多个值。</p>
<h2 id="enum在Objective-C中的“升级版”">enum在Objective-C中的“升级版”</h2><p>一般来说，我们不能指定枚举变量的实际类型是什么，就是说，我们不知道枚举最后是int型，还是其他的什么类型。但是从C++ 11开始，我们可以为枚举指定其实际的存储类型，如下语法：</p>
<pre><code><span class="class"><span class="keyword">enum</span> <span class="title">TTGState</span> : <span class="title">NSInteger</span> {/*...*/};</span>
</code></pre><p>但是，我们在定义枚举的时候如何保证兼容性呢？Foundation框架已经为我们提供了更加“统一、便捷”的枚举定义方法，我们重新定义上面的例子：</p>
<pre><code><span class="comment">//NS_ENUM，定义状态等普通枚举</span>
<span class="function"><span class="keyword">typedef</span> <span class="title">NS_ENUM</span><span class="params">(NSUInteger, TTGState)</span> </span>{
    TTGStateOK = <span class="number">0</span>,
    TTGStateError,
    TTGStateUnknow
};

<span class="comment">//NS_OPTIONS，定义选项</span>
<span class="function"><span class="keyword">typedef</span> <span class="title">NS_OPTIONS</span><span class="params">(NSUInteger, TTGDirection)</span> </span>{
    TTGDirectionNone = <span class="number">0</span>,
    TTGDirectionTop = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,
    TTGDirectionLeft = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,
    TTGDirectionRight = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,
    TTGDirectionBottom = <span class="number">1</span> &lt;&lt; <span class="number">3</span>
};
</code></pre><p>所以，在开发Mac、iOS程序中，最好所有的枚举都用“<strong>NS_ENUM</strong>”和“<strong>NS_OPTIONS</strong>”定义，保证统一。</p>
<h2 id="总结">总结</h2><p>充分的用好枚举，可以增强代码的可读性，减少各种“错误”，让代码更加的规范。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>Enum，也就是枚举，从C语言开始就有了，C++、Java、Objective-C、Swift这些语言，当然都有对应的枚举类型，功能可能有多有少，但是最核心的还是一个—规范的定义代码中的状态、选项等“常量”。</p>
<h2 id="Item_5_-_Use_Enumerations_for_States,_Options,_and_Status_Codes">Item 5 - Use Enumerations for States, Options, and Status Codes</h2><p>本节的内容就是如何正确的使用枚举。</p>
<h2 id="状态与选项的区别（states_and_options）">状态与选项的区别（states and options）</h2><p>在用<strong>enum</strong>之前，我个人觉得，区分一下状态和选项的概念还是很必要的。</p>
<p><strong>状态</strong>，同时只能有一种，如“<strong>OK</strong>”，“<strong>Error</strong>”，不可能同时是OK和Error。<br><strong>选项</strong>，同时可以有一种或一种以上，如App可以<strong>同时</strong>支持横屏和竖屏，横屏竖屏在这个时候就是“屏幕方向”的两种不同的选项。</p>
<p>接下来，我们看看如何用枚举定义状态和选项。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[@autoreleasepool-内存的分配与释放]]></title>
    <link href="http://tutuge.me/2015/03/17/what-is-autoreleasepool/"/>
    <id>http://tutuge.me/2015/03/17/what-is-autoreleasepool/</id>
    <published>2015-03-17T12:21:56.000Z</published>
    <updated>2015-09-24T10:58:23.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>开发过iOS、Mac的朋友应该对“<strong>@autoreleasepool</strong>”不陌生。只要在Xcode里创建一个工程，就能看到下面这样的代码：</p>
<pre><code><span class="comment">//iOS program</span>
<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) {
    <span class="keyword">@autoreleasepool</span> {
        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate class]));
    }
}

<span class="comment">//Command line program</span>
<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[]) {
    <span class="keyword">@autoreleasepool</span> {
        <span class="comment">//...</span>
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>看，每个<strong>main</strong>函数的主体都被<strong>@autoreleasepool</strong>的Block块包在里面，也就是说，接下来所有的对象创建都在这个block里面。</p>
<p>那么，<strong>@autoreleasepool</strong>的作用到底是什么呢？我们开发中可以用它来做什么呢？  </p>
<p>可以在某些情况下，大幅度降低程序的内存占用，如下图:</p>
<p><img src="https://camo.githubusercontent.com/2c1f07459d33c72de07d8a9305703b2ba40abfc4/687474703a2f2f7a6f72726f6368656e2e71696e6975646e2e636f6d2f626c6f675f776861745f69735f6175746f72656c65617365706f6f6c5f312e706e673f696d61676556696577322f302f682f343030" alt="autoreleasepool测试内存占用图"></p>
<ul>
<li>测试的内容：500000次循环，每次循环创建一个NSNumber实例和两个NSString实例。</li>
<li>图：红线表示没有用<strong>@autoreleasepool</strong>时的内存占用。</li>
<li>图：绿线表示用了<strong>@autoreleasepool</strong>优化后的内存占用！</li>
</ul>
<p>效果是不是很明显！</p>
<p>代码Github地址：<a href="https://github.com/zekunyan/AutoReleasePoolTestExample" target="_blank" rel="external">AutoReleasePoolTestExample</a> Xcode 6, iOS 8, iPhone 5模拟器.</p>
<a id="more"></a>
<h2 id="MRC_与_ARC">MRC 与 ARC</h2><p>MRC（Mannul Reference Counting）和ARC(Automatic Reference Counting)，分别对应着手动引用计数和自动引用计数。  </p>
<p>对！是计数，不是“<strong>GC、垃圾回收</strong>”什么的，就是说，在Objective-C的开发中，ARC不代表像Java那样有GC做垃圾回收，所以本质上还是要“手动”管理内存的。也就是说，我们在ARC环境下写的代码，不用自己手动插入“<strong>retain、release这些消息</strong>”，ARC会在编译时为我们在合适的位置插入，释放不必要的内存。</p>
<p>而<strong>@autoreleasepool</strong>就跟对象的<strong>release</strong>密切相关。</p>
<h2 id="@autoreleasepool_干了啥">@autoreleasepool 干了啥</h2><p>在MRC时代，如果我们想先retain一个对象，但是并不知道在什么时候可以release它，我们可以像下面这么做：</p>
<pre><code><span class="name">NSAutoreleasePool</span> *<span class="atom">pool</span> = [[<span class="name">NSAutoreleasePool</span> <span class="atom">alloc</span>] <span class="atom">init</span>];

<span class="name">NSString</span>* <span class="atom">str</span> = [[[<span class="name">NSString</span> <span class="atom">alloc</span>] <span class="atom">initWithString</span>:@<span class="string">"tutuge"</span>] <span class="atom">autorelease</span>];
//<span class="atom">use</span> <span class="atom">str</span>...

[<span class="atom">pool</span> <span class="atom">release</span>];
//<span class="atom">str</span> <span class="atom">is</span> <span class="atom">released</span>
</code></pre><p>就是说，我们可以在创建对象的时候给对象发送“<strong>autorelease</strong>”消息，然后当<strong>NSAutoreleasePool</strong>结束的时候，“标记过”autorelease的对象都会被“<strong>release</strong>”掉，也就是会被释放掉。</p>
<p>但是在ARC时代，我们不用手动发送<strong>autorelease</strong>消息，ARC会自动帮我们加。而这个时候，<strong>@autoreleasepool</strong>做的事情，跟<strong>NSAutoreleasePool</strong>就一模一样了。</p>
<h2 id="什么时候用@autoreleasepool">什么时候用@autoreleasepool</h2><p>根据<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html" target="_blank" rel="external">Apple的文档</a>，使用场景如下：</p>
<ul>
<li>写基于命令行的的程序时，就是没有UI框架，如AppKit等Cocoa框架时。</li>
<li>写循环，循环里面包含了大量临时创建的对象。（本文的例子）</li>
<li>创建了新的线程。（非Cocoa程序创建线程时才需要）</li>
<li>长时间在后台运行的任务。</li>
</ul>
<h2 id="利用@autoreleasepool优化循环">利用@autoreleasepool优化循环</h2><p>利用@autoreleasepool优化循环的内存占用，我觉得最有用的一点，下面就说说这个点。<br>如下面的循环，次数非常多，而且循环体里面的对象都是临时创建使用的，就可以用<strong>@autoreleasepool</strong>包起来，让每次循环结束时，可以及时的释放临时对象的内存。</p>
<pre><code><span class="comment">//来自Apple文档，见参考</span>
<span class="built_in">NSArray</span> *urls = &lt;<span class="preprocessor"># An array of file URLs #&gt;;</span>
<span class="keyword">for</span> (<span class="built_in">NSURL</span> *url <span class="keyword">in</span> urls) {

    <span class="keyword">@autoreleasepool</span> {
        <span class="built_in">NSError</span> *error;
        <span class="built_in">NSString</span> *fileContents = [<span class="built_in">NSString</span> stringWithContentsOfURL:url
                                         encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];
        <span class="comment">/* Process the string, creating and autoreleasing more objects. */</span>
    }
}
</code></pre><p>这么做的效果是极其显著地，就如本文最开始的图一样，可以自己把示例工程下回来运行下试试~</p>
<h2 id="总结">总结</h2><p><strong>@autoreleasepool</strong>看起来很不“起眼”，平常开发很容易就忽略它了，但是仔细一看，确如此有用~</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html" target="_blank" rel="external">Using Autorelease Pool Blocks</a></li>
<li><a href="http://stackoverflow.com/questions/14677049/what-is-autoreleasepool-objective-c" target="_blank" rel="external">What is autoreleasepool? - Objective-C</a></li>
<li><a href="http://stackoverflow.com/questions/9086913/objective-c-why-is-autorelease-autoreleasepool-still-needed-with-arc" target="_blank" rel="external">Objective-C: Why is autorelease (@autoreleasepool) still needed with ARC?</a></li>
<li><a href="http://blog.zilongshanren.com/blog/2013/12/20/what-is-autorelease-pool/" target="_blank" rel="external">What-is-autorelease-pool?</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html" target="_blank" rel="external">NSAutoreleasePool</a></li>
</ul>
<h3 id="示例中的第三方库">示例中的第三方库</h3><p><a href="https://github.com/kevinzhow/PNChart" target="_blank" rel="external">PNChart</a></p>
<h3 id="运行中用代码获取App运行消耗内存">运行中用代码获取App运行消耗内存</h3><p><a href="http://stackoverflow.com/questions/787160/programmatically-retrieve-memory-usage-on-iphone" target="_blank" rel="external">Programmatically retrieve memory usage on iPhone</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>开发过iOS、Mac的朋友应该对“<strong>@autoreleasepool</strong>”不陌生。只要在Xcode里创建一个工程，就能看到下面这样的代码：</p>
<pre><code><span class="comment">//iOS program</span>
<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) {
    <span class="keyword">@autoreleasepool</span> {
        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate class]));
    }
}

<span class="comment">//Command line program</span>
<span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[]) {
    <span class="keyword">@autoreleasepool</span> {
        <span class="comment">//...</span>
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>看，每个<strong>main</strong>函数的主体都被<strong>@autoreleasepool</strong>的Block块包在里面，也就是说，接下来所有的对象创建都在这个block里面。</p>
<p>那么，<strong>@autoreleasepool</strong>的作用到底是什么呢？我们开发中可以用它来做什么呢？  </p>
<p>可以在某些情况下，大幅度降低程序的内存占用，如下图:</p>
<p><img src="https://camo.githubusercontent.com/2c1f07459d33c72de07d8a9305703b2ba40abfc4/687474703a2f2f7a6f72726f6368656e2e71696e6975646e2e636f6d2f626c6f675f776861745f69735f6175746f72656c65617365706f6f6c5f312e706e673f696d61676556696577322f302f682f343030" alt="autoreleasepool测试内存占用图"></p>
<ul>
<li>测试的内容：500000次循环，每次循环创建一个NSNumber实例和两个NSString实例。</li>
<li>图：红线表示没有用<strong>@autoreleasepool</strong>时的内存占用。</li>
<li>图：绿线表示用了<strong>@autoreleasepool</strong>优化后的内存占用！</li>
</ul>
<p>效果是不是很明显！</p>
<p>代码Github地址：<a href="https://github.com/zekunyan/AutoReleasePoolTestExample">AutoReleasePoolTestExample</a> Xcode 6, iOS 8, iPhone 5模拟器.</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[有关宏定义的经验与技巧-简化代码-增强Log]]></title>
    <link href="http://tutuge.me/2015/03/15/%E6%9C%89%E5%85%B3%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E7%BB%8F%E9%AA%8C%E4%B8%8E%E6%8A%80%E5%B7%A7-%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81-%E5%A2%9E%E5%BC%BALog/"/>
    <id>http://tutuge.me/2015/03/15/有关宏定义的经验与技巧-简化代码-增强Log/</id>
    <published>2015-03-15T07:34:28.000Z</published>
    <updated>2015-04-06T03:13:27.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>宏定义、#define啥的，我们经常遇到。<br>一般来说，最常用的可能就是定义一些常量、简单的“函数”，如下：</p>
<pre><code><span class="comment">//定义常量PI</span>
<span class="preprocessor">#<span class="keyword">define</span> PI <span class="number">3.1415926</span></span>

<span class="comment">//定义“函数”MIN</span>
<span class="preprocessor">#<span class="keyword">define</span> MIN(A,B) ((A) &lt; (B) ? (A) : (B))</span>
</code></pre><p>但是，这样定义常量、函数，有一定的风险。（见：<a href="http://tutuge.me/2015/03/11/Effective-Objective-C-读书笔记-Item-4-如何正确定义常量/">Effective-Objective-C-读书笔记-Item-4-如何正确定义常量</a>, <a href="http://onevcat.com/2014/01/black-magic-in-macro/" target="_blank" rel="external">宏定义的黑魔法 - 宏菜鸟起飞手册</a>）</p>
<p>本文就列出几条我个人在iOS开发当中常用的经验与技巧。</p>
<a id="more"></a>
<h2 id="简化代码">简化代码</h2><p>在开发当中，我们可能会大量的写一些重复的，甚至具有“危险”的代码，用宏定义#define，往往可以简化代码，看看下面几个例子。</p>
<h3 id="GCD与#define">GCD与#define</h3><p><strong>dispatch_once</strong><br>项目中往往少不了各种单例类，我们一般会如下定义：</p>
<pre><code>+ (instancetype)sharedService {
    <span class="keyword">static</span> XXX *sharedService = <span class="literal">nil</span>;

    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;
    <span class="built_in">dispatch_once</span>, ^{
        sharedService = [XXX new];
    });

    <span class="keyword">return</span> sharedService;
}
</code></pre><p>这时候，就要注意几点：</p>
<ul>
<li>dispatch_once_t必须是<strong>static</strong>的，否则会各种报错=。=。</li>
<li><strong>dispatch_once</strong>的第一个参数必须取onceToken的地址，就是要“<strong>&amp;onceToken</strong>。”</li>
</ul>
<p>看，写个小小的单例都要这么注意，错了一点都很危险啊，而且总要重复写这几行。所以这个时候需要让宏定义帮忙：</p>
<pre><code><span class="comment">//定义宏定义</span>
<span class="preprocessor">#<span class="keyword">define</span> DISPATCH_ONCE_BLOCK(onceBlock) static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, onceBlock);</span>

+ (instancetype)sharedService {
    <span class="keyword">static</span> XXX *sharedService = nil;

    <span class="comment">//直接一行搞定</span>
    DISPATCH_ONCE_BLOCK(^{
        sharedService = [XXX <span class="keyword">new</span>];        
    })

    <span class="keyword">return</span> sharedService;
}
</code></pre><p>看，是不是变得更加简洁、“安全了”~</p>
<p><strong>dispatch_async</strong><br>除了dispatch_once，另一个常用的就是dispatch_async。不多说，直接看例子：</p>
<pre><code><span class="comment">//在Main线程上运行</span>
<span class="id">#define</span> <span class="tag">DISPATCH_ON_MAIN_THREAD</span>(mainQueueBlock) <span class="tag">dispatch_async</span>(<span class="function">dispatch_get_main_queue</span>(), <span class="tag">mainQueueBlock</span>);

<span class="comment">//在Global Queue上运行</span>
<span class="id">#define</span> <span class="tag">DISPATCH_ON_GLOBAL_QUEUE_HIGH</span>(globalQueueBlocl) <span class="tag">dispatch_async</span>(<span class="function">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), <span class="tag">globalQueueBlocl</span>);
<span class="id">#define</span> <span class="tag">DISPATCH_ON_GLOBAL_QUEUE_DEFAULT</span>(globalQueueBlocl) <span class="tag">dispatch_async</span>(<span class="function">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), <span class="tag">globalQueueBlocl</span>);
<span class="id">#define</span> <span class="tag">DISPATCH_ON_GLOBAL_QUEUE_LOW</span>(globalQueueBlocl) <span class="tag">dispatch_async</span>(<span class="function">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>), <span class="tag">globalQueueBlocl</span>);
<span class="id">#define</span> <span class="tag">DISPATCH_ON_GLOBAL_QUEUE_BACKGROUND</span>(globalQueueBlocl) <span class="tag">dispatch_async</span>(<span class="function">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>), <span class="tag">globalQueueBlocl</span>);

<span class="comment">//主线程上</span>
<span class="tag">DISPATCH_ON_MAIN_THREAD</span>(^{
    <span class="comment">//更新UI</span>
})

<span class="comment">//Global Queue </span>
<span class="tag">DISPATCH_ON_GLOBAL_QUEUE_DEFAULT</span>(^{
    <span class="comment">//异步耗时任务</span>
})
</code></pre><p>再也不用写一大堆”dispatch_async(dispatch_get_global_queue”了~看起来是不是很清爽~</p>
<h3 id="能一行搞定，干嘛还要写多行">能一行搞定，干嘛还要写多行</h3><p>很多时候，我们写的函数、方法都会在起始的地方加一些公共的判断，条件满足了才可以继续往下运行，如“用户是否登录”、“某个模块是否加载完成”等等，所以，我们可能会写如下样子的代码：</p>
<pre><code>- (<span class="keyword">void</span>)doSomething {
    <span class="keyword">if</span> (![[XXXAccountService sharedService] isLogin]) {
        <span class="keyword">return</span>;
    }
    <span class="comment">//do staff...</span>
}

- (<span class="keyword">void</span>)doSomething2 {
    <span class="keyword">if</span> (![[XXXAccountService sharedService] isLogin]) {
        <span class="keyword">return</span>;
    }
    <span class="comment">//do staff...</span>
}
</code></pre><p>每次都要这么写，是不是感觉很浪费时间？而且重复的好多=。=<br>所以，我们要用#define，把3行变成一行:</p>
<pre><code><span class="comment">//定义</span>
<span class="preprocessor">#<span class="keyword">define</span> CHECK_LOGIN_IN <span class="keyword">if</span> (![[XXXAccountService sharedService] isLogin]) {return;}</span>

- (<span class="keyword">void</span>)doSomething {
    CHECK_LOGIN_IN
    <span class="comment">//do staff...</span>
}

- (<span class="keyword">void</span>)doSomething2 {
    CHECK_LOGIN_IN
    <span class="comment">//do staff...</span>
}
</code></pre><p>其实#define的原理就是不管三七二十一，直接做替换，所以我们完全可以利用这个特点，发挥自己的想象，简化代码~</p>
<h2 id="宏定义与Log">宏定义与Log</h2><p>打Log，是个永恒的话题。  </p>
<h3 id="NSLog增强版">NSLog增强版</h3><p>我们会经常用到<strong>NSLog</strong>打Log，但是，这个函数能提供的信息非常少，所以，下面就是一个增强版, 最好定义在项目的pch文件中：</p>
<pre><code><span class="comment">#define NSLog(format, ...) \</span>
    <span class="keyword">do</span> { <span class="string">\</span>
        NSLog(@<span class="string">"&lt;%@ : %d : %s&gt;-: %@"</span>, <span class="string">\</span>
        [[NSString <span class="attribute">stringWithUTF8String</span>:__FILE__] lastPathComponent], <span class="string">\</span>
        __LINE__, <span class="string">\</span>
        __FUNCTION__, <span class="string">\</span>
        [NSString <span class="attribute">stringWithFormat</span>:format, <span class="comment">##__VA_ARGS__]); \</span>
    } <span class="keyword">while</span>(<span class="number">0</span>)
</code></pre><p>使用：    </p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>{
    <span class="annotation">@autoreleasepool</span> {
        NSLog(@<span class="string">"Blog: %@"</span>, @<span class="string">"http://tutuge.me"</span>);
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>输出：</p>
<pre><code>&lt;main.<span class="string">m :</span> <span class="number">22</span> : main&gt;-: <span class="string">Blog:</span> <span class="string">http:</span><span class="comment">//tutuge.me</span>
</code></pre><p>看，这下Log就带上了文件名、行号、函数名，一下子就清楚多了~<br>至于为什么要用这个奇怪的“do{…}while(0)”，其实就是为了防止在不同的使用场景中导致语法错误，详细请见：<a href="http://onevcat.com/2014/01/black-magic-in-macro/" target="_blank" rel="external">宏定义的黑魔法 - 宏菜鸟起飞手册</a></p>
<h3 id="为Log增加全局开关">为Log增加全局开关</h3><p>开发中，我们往往会在许多地方加上Log，但是在发布的时候，又不想显示这些Log，这个时候难道要一个一个的删除打Log的地方？<br>所以，为了增加开关，我们需要将上面的增强型NSLog改造一下：</p>
<pre><code><span class="comment">//判断是否要Log</span>
<span class="preprocessor">#<span class="keyword">ifdef</span> NEED_DEBUG    </span>
<span class="preprocessor">#<span class="keyword">define</span> NSLog(format, ...) \
    <span class="comment">//Log定义...</span></span>
<span class="preprocessor">#<span class="keyword">else</span></span>
    <span class="preprocessor">#<span class="keyword">define</span> NSLog(format, ...) do{ } while(<span class="number">0</span>)</span>
<span class="preprocessor">#<span class="keyword">endif</span></span>
</code></pre><p>所以，当我们需要Log的时候，在上面定义的之前加上下面这一行：</p>
<pre><code><span class="hexcolor">#def</span>ine NEED_DEBUG
</code></pre><p>就可以打开Log了。不加的话，就不会有Log~简单的条件编译~</p>
<h3 id="为Log增加等级">为Log增加等级</h3><p>开发过Android的应该都知道，Android里面可以很方便的用Log.i、Log.d输出不同“等级”的Log，调试更加方便，NSLog却不行。所以，还是要借助宏定义：</p>
<pre><code><span class="comment">//Debug等级Log, 在此之前定义自己的NSLog</span>
<span class="preprocessor">#<span class="keyword">ifdef</span> LOG_LEVEL_DEBUG</span>
    <span class="preprocessor">#<span class="keyword">define</span> DLog(format, ...) NSLog(@<span class="string">"&lt;DEBUG&gt;: %@"</span>, [NSString stringWithFormat:format, ##__VA_ARGS__])</span>
<span class="preprocessor">#<span class="keyword">else</span></span>
    <span class="preprocessor">#<span class="keyword">define</span> DLog(format, ...) do{ } while(<span class="number">0</span>)</span>
<span class="preprocessor">#<span class="keyword">endif</span></span>

<span class="comment">//Info等级Log</span>
<span class="preprocessor">#<span class="keyword">ifdef</span> LOG_LEVEL_INFO</span>
    <span class="preprocessor">#<span class="keyword">define</span> ILog(format, ...) NSLog(@<span class="string">"&lt;Info&gt;: %@"</span>, [NSString stringWithFormat:format, ##__VA_ARGS__])</span>
<span class="preprocessor">#<span class="keyword">else</span></span>
    <span class="preprocessor">#<span class="keyword">define</span> ILog(format, ...) do{ } while(<span class="number">0</span>)</span>
<span class="preprocessor">#<span class="keyword">endif</span></span>

<span class="comment">//Error等级Log</span>
<span class="preprocessor">#<span class="keyword">ifdef</span> LOG_LEVEL_ERROR</span>
    <span class="preprocessor">#<span class="keyword">define</span> ELog(format, ...) NSLog(@<span class="string">"&lt;Error&gt;: %@"</span>, [NSString stringWithFormat:format, ##__VA_ARGS__])</span>
<span class="preprocessor">#<span class="keyword">else</span></span>
    <span class="preprocessor">#<span class="keyword">define</span> ELog(format, ...) do{ } while(<span class="number">0</span>)</span>
<span class="preprocessor">#<span class="keyword">endif</span></span>
</code></pre><p>当我们在打Log的时候，就可以根据需要，用不同等级的Log，而且可以方便的定制需要输出哪几种，并且之前的“增强版”NSLog也可以使用。</p>
<p>完整的请看<a href="https://gist.github.com/zekunyan/2f2356136b9b40348584" target="_blank" rel="external">Gist</a>.</p>
<h2 id="其它">其它</h2><p>还有一些简单好用的宏定义，在这就只举几个典型的例子了~</p>
<h3 id="打印自定义类型信息">打印自定义类型信息</h3><p>假如有如下结构体定义(自定义类的话，直接重写description方法即可):</p>
<pre><code><span class="comment">//复数结构体</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> Complex {
    <span class="keyword">float</span> r; <span class="comment">//实部</span>
    <span class="keyword">float</span> i; <span class="comment">//虚部</span>
} Complex;

<span class="comment">//定义打印Complex类型的宏</span>
<span class="comment">//输出：(1+2i), (1-2i)</span>
<span class="preprocessor">#<span class="keyword">define</span> NSLogComplex(complex) NSLog(@<span class="string">"Complex: (%g%s%gi)"</span>, complex.r, (complex.i &gt; <span class="number">0</span> ? <span class="string">"+"</span> : <span class="string">""</span>), complex.i)</span>
</code></pre><h3 id="常用函数简化、单例获取">常用函数简化、单例获取</h3><pre><code><span class="comment">//获取View的属性</span>
<span class="hexcolor">#def</span>ine <span class="function"><span class="title">GetViewWidth</span><span class="params">(view)</span></span>  view<span class="class">.frame</span><span class="class">.size</span><span class="class">.width</span>
<span class="hexcolor">#def</span>ine <span class="function"><span class="title">GetViewHeight</span><span class="params">(view)</span></span> view<span class="class">.frame</span><span class="class">.size</span><span class="class">.height</span>
<span class="hexcolor">#def</span>ine <span class="function"><span class="title">GetViewX</span><span class="params">(view)</span></span>      view<span class="class">.frame</span><span class="class">.origin</span><span class="class">.x</span>
<span class="hexcolor">#def</span>ine <span class="function"><span class="title">GetViewY</span><span class="params">(view)</span></span>      view<span class="class">.frame</span><span class="class">.origin</span><span class="class">.y</span>

<span class="comment">//屏幕常量</span>
<span class="hexcolor">#def</span>ine GetScreenWidth      [[UIScreen mainScreen] bounds]<span class="class">.size</span><span class="class">.width</span>
<span class="hexcolor">#def</span>ine GetScreenHeight     [[UIScreen mainScreen] bounds]<span class="class">.size</span><span class="class">.height</span>

<span class="comment">//获取图片资源</span>
<span class="hexcolor">#def</span>ine <span class="function"><span class="title">GetImage</span><span class="params">(imageName)</span></span> [UIImage imageNamed:[NSString stringWithFormat:@<span class="string">"%@"</span>,imageName]]

<span class="comment">//等等~只要你想得到~</span>
</code></pre><h2 id="总结">总结</h2><p>宏定义的各种Tip还远远不止这些，合理使用它，可以有效改善代码的阅读质量~</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://gcc.gnu.org/onlinedocs/cpp/index.html" target="_blank" rel="external">The C Preprocessor</a></li>
<li><a href="http://onevcat.com/2014/01/black-magic-in-macro/" target="_blank" rel="external">宏定义的黑魔法 - 宏菜鸟起飞手册</a></li>
</ul>
<p>I</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>宏定义、#define啥的，我们经常遇到。<br>一般来说，最常用的可能就是定义一些常量、简单的“函数”，如下：</p>
<pre><code><span class="comment">//定义常量PI</span>
<span class="preprocessor">#<span class="keyword">define</span> PI <span class="number">3.1415926</span></span>

<span class="comment">//定义“函数”MIN</span>
<span class="preprocessor">#<span class="keyword">define</span> MIN(A,B) ((A) &lt; (B) ? (A) : (B))</span>
</code></pre><p>但是，这样定义常量、函数，有一定的风险。（见：<a href="http://tutuge.me/2015/03/11/Effective-Objective-C-读书笔记-Item-4-如何正确定义常量/">Effective-Objective-C-读书笔记-Item-4-如何正确定义常量</a>, <a href="http://onevcat.com/2014/01/black-magic-in-macro/">宏定义的黑魔法 - 宏菜鸟起飞手册</a>）</p>
<p>本文就列出几条我个人在iOS开发当中常用的经验与技巧。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="技巧" scheme="http://tutuge.me/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Effective-Objective-C-读书笔记-Item-4-如何正确定义常量]]></title>
    <link href="http://tutuge.me/2015/03/11/Effective-Objective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Item-4-%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F/"/>
    <id>http://tutuge.me/2015/03/11/Effective-Objective-C-读书笔记-Item-4-如何正确定义常量/</id>
    <published>2015-03-10T16:07:23.000Z</published>
    <updated>2015-04-06T03:14:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>写博客果然比光看书要花时间=。=，书都快看完了，才写到第4节。但是总结一遍，的确印象深刻啊~~  </p>
<p>这次的主题是“<strong>常量</strong>”，非常常用，又非常重要的东西~良好的代码规范、设计，少不了各种<strong>常量</strong>。</p>
<h2 id="Item_4_-_Prefer_Typed_Constants_to_Preprocessor_#define">Item 4 - Prefer Typed Constants to Preprocessor #define</h2><p>本节着重对比了常量的定义形式，类型常量和#define的区别、各自的特点。最后得出，我们应该用带有类型的常量，而不是#define。</p>
<a id="more"></a>
<h2 id="一个简单的示例">一个简单的示例</h2><p>应用中，少不了各种动画，也就少不了设定动画的时间长度，一般来说，我们会设定短、中、长几种时间常量，用于不同的场合，了解C语言的童鞋估计对“<strong>#define</strong>”宏定义不陌生，于是，可能就会如下这么定义：</p>
<pre><code><span class="hexcolor">#def</span>ine ANIMATION_DURATION_SHORT <span class="number">0.3</span>
<span class="hexcolor">#def</span>ine ANIMATION_DURATION_MIDDLE <span class="number">0.6</span>
<span class="hexcolor">#def</span>ine ANIMATION_DURATION_LONG <span class="number">1.0</span>
</code></pre><p>于是，所有用到动画时长的地方，直接用这几个宏定义就行了。  </p>
<p>乍一看，似乎没什么问题。</p>
<h3 id="类型+不可变">类型+不可变</h3><p>先来看看宏定义干了什么。<br>总的来说，#define就是“替换”，在编译时，将一切宏定义替换成定义后面的内容。（参考<a href="http://baike.baidu.com/view/2076445.htm" target="_blank" rel="external">百度百科</a>）  </p>
<p>关键在于：</p>
<ul>
<li>宏定义不会检查替换的“<strong>类型</strong>”，只要遇到，就做替换。</li>
<li>宏定义不保证“<strong>不可变</strong>”，因为可以<strong>重复定义</strong>，不能保证值不变。(这个我觉得是最容易让人忽略的地方)</li>
</ul>
<p>所以，用宏定义定义常量，很“危险”。</p>
<h2 id="正确的做法">正确的做法</h2><p>恰当的常量，应该具备合适的常量名字、正确的类型，还有const、extern等关键字的修饰，当然，还要根据常量适用的“<strong>范围</strong>”，做出恰当的处理。一下举例说明。</p>
<h3 id="只在函数中用的常量">只在函数中用的常量</h3><p>只在函数中用的常量：</p>
<pre><code>- (<span class="keyword">void</span>)runAnimation {
    <span class="comment">//动画时间长度常量</span>
    <span class="keyword">static</span> <span class="keyword">const</span> NSTimeInterval kAnimationDurationLong = <span class="number">1.0f</span>;

    <span class="comment">//...</span>
}
</code></pre><p>static、const定义了它是静态不可变的；<strong>NSTimeInterval</strong>则“精确”指定了常量的类型。</p>
<h3 id="只在一个“-m”文件中使用的常量">只在一个“<strong>.m</strong>”文件中使用的常量</h3><p>在类的实现文件“xxx.m”文件中定义常量，也是很常见的。<br>你可能会觉得，既然是一个类使用的，那就放在类的头文件里面定义不就好了。<br><strong>但是这么想是错的=。=</strong><br><strong>因为所有要用到这个类的文件，都会无形当中包含了这些常量声明，将不必要的数据暴露在外面，这样是违反设计原则的，并且，如果常量名字取得不恰当，还有可能造成冲突。</strong></p>
<p>所以，应该如下:</p>
<pre><code><span class="comment">//<span class="label">XXX.m</span></span>

<span class="comment">//必须要static</span>
<span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> kAnimationDurationLong = <span class="number">1.0</span>f;

<span class="class"><span class="keyword">@implementation</span> <span class="title">XXX</span></span>
<span class="comment">//...</span>
<span class="keyword">@end</span> 
</code></pre><p>需要注意的点：</p>
<ul>
<li>一定要放在.m文件中。</li>
<li>必须是<strong>static</strong>，表示此常量作用域只在此.m文件中。如果不加static的话，常量就会在全局作用域中声明，可能会导致跟其他的常量冲突。</li>
<li>const，当然。</li>
<li>NSTimeInterval，确定的类型。</li>
<li>kAnimationDurationLong，“<strong>k</strong>”开头的命名，也算是Apple的规范了吧，内部常量统一以“<strong>k</strong>”开头。</li>
</ul>
<h3 id="全局常量">全局常量</h3><p>一般来说，最常见的全局常量就是发广播Notification时用的Notification的名字，往往都是一些字符串，下面就以这个为例子：</p>
<p>假设我们的类叫“<strong>TTGClass</strong>”，我们的类会向外发送Notification，所以需要定义一个Notification的名字常量供外界注册，如下：</p>
<pre><code><span class="comment">//TTGClass.h</span>
<span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> TTGClassWorkBeginNotification;

<span class="comment">//TTGClass.m</span>
<span class="built_in">NSString</span> * <span class="keyword">const</span> TTGClassWorkBeginNotification = <span class="string">@"TTGClassWorkBeginNotification"</span>;
</code></pre><p>关键：</p>
<ul>
<li>头文件中只是做声明，不做定义。所以用extern表示常量在别处定义的，尽量隐藏细节。</li>
<li>同<strong>类名</strong>做常量名字的开头，<strong>这个非常关键，因为Objective-C里面没有像Java那样的“包”机制，所以必须靠命名来划分不同的类，常量当然也要遵循这个规则。</strong></li>
<li>NSString，确定的类型；const，表明常量；Notification后缀，表明用途。这些都是需要注意的。</li>
</ul>
<h2 id="总结">总结</h2><p>良好的代码，总是少不了定义各种常量，以避免“魔鬼数字、魔鬼字符串”。所以我们应该尽量避免少用#define定义常量，而是用带有类型的、const的常量，并且尽可能的缩小常量的作用域。  </p>
<p>暴露的细节越少，出错的机会也就越小（忘了从哪里看到的=。=）</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>写博客果然比光看书要花时间=。=，书都快看完了，才写到第4节。但是总结一遍，的确印象深刻啊~~  </p>
<p>这次的主题是“<strong>常量</strong>”，非常常用，又非常重要的东西~良好的代码规范、设计，少不了各种<strong>常量</strong>。</p>
<h2 id="Item_4_-_Prefer_Typed_Constants_to_Preprocessor_#define">Item 4 - Prefer Typed Constants to Preprocessor #define</h2><p>本节着重对比了常量的定义形式，类型常量和#define的区别、各自的特点。最后得出，我们应该用带有类型的常量，而不是#define。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="笔记" scheme="http://tutuge.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="翻译" scheme="http://tutuge.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UITextView编辑时插入自定义表情-简单的图文混编]]></title>
    <link href="http://tutuge.me/2015/03/07/UITextView%E7%BC%96%E8%BE%91%E6%97%B6%E6%8F%92%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E6%83%85-%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BE%E6%96%87%E6%B7%B7%E7%BC%96/"/>
    <id>http://tutuge.me/2015/03/07/UITextView编辑时插入自定义表情-简单的图文混编/</id>
    <published>2015-03-07T03:04:38.000Z</published>
    <updated>2015-09-24T10:59:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在iOS开发中，经常需要用UITextView作为编辑文本的输入控件。<br>但是如何在编辑时插入自定义表情呢？就是像发微博时那样？  </p>
<p>本文简单的用<strong>NSTextAttachment</strong>、<strong>NSAttributedString</strong>的特性，实现了</p>
<ul>
<li>在UITextView中编辑文字时插入自定义表情图片</li>
<li>同时可以返回带有表情“<strong>替换符</strong>”的纯文本字符串。</li>
</ul>
<h2 id="示例">示例</h2><p>本文代码工程地址：<a href="https://github.com/zekunyan/UITextViewDIYEmojiExample" target="_blank" rel="external">https://github.com/zekunyan/UITextViewDIYEmojiExample</a></p>
<p>效果图：</p>
<p><img src="http://zorrochen.qiniudn.com/inputEmoji_Sample.gif" alt="效果图"></p>
<a id="more"></a>
<h2 id="背景知识">背景知识</h2><ul>
<li>NSAttributedString及其子类，用于显示富文本。</li>
<li>NSTextAttachment，NSAttributedString的一种样式类，可以在文本中显示图片。</li>
<li>NSTextStorage，UITextView中的实际的文本封装。（见参考中的UITextView文档）</li>
</ul>
<h3 id="表情与其标志">表情与其标志</h3><p>首先需要明确的是，我们的自定义表情一定是有一一对应的“<strong>标志</strong>”的，如“<strong>[/emoji_haha]</strong>”。<br>就是说，为了方便处理，方便在数据库、网络传输中保存、传输带有表情图片的文本，我们必须要为每种表情取特定的“<strong>名字</strong>”，数据库中储存的、网络传输的文本就只包含这些标志名字就行，在显示的时候做对应的替换。</p>
<p>如：</p>
<p><strong>tutuge.me<img src="http://zorrochen.qiniudn.com/blog_uitextview_input_emoji_emoji_1.png" alt="表情"></strong></p>
<p>对应的纯文本就是：</p>
<p><strong>tutuge.me[/emoji_1]</strong></p>
<h2 id="插入并显示表情图片">插入并显示表情图片</h2><p>插入表情很简单，直接实例化<strong>NSTextAttachment</strong>类，将需要的表情的UIImage实例赋值给NSTextAttachment的image属性，然后用“<strong>[NSAttributedString attributedStringWithAttachment:]</strong>”方法实例化一个NSAttributedString的对象，插入到UITextView的textStorage对应的位置即可。</p>
<p>如下：</p>
<pre><code>NSTextAttachment *emojiTextAttachment = [NSTextAttachment <span class="keyword">new</span>];

<span class="comment">//设置表情图片</span>
emojiTextAttachment.image = emojiImage;

<span class="comment">//插入表情</span>
[textView.textStorage <span class="string">insertAttributedString:</span>[NSAttributedString <span class="string">attributedStringWithAttachment:</span>emojiTextAttachment]
<span class="label">                                      atIndex:</span>textView.selectedRange.location];
</code></pre><p>这样，就能在UITextView当前光标位置插入表情图片了。</p>
<h2 id="获取带有表情标志的文本字符串">获取带有表情标志的文本字符串</h2><h3 id="难点">难点</h3><p>NSTextAttachment被插入到NSAttributedString中的时候，<strong>就被当成了一个字符处理！！！</strong>。<br>就是说，只从UITextView的text中，是找不回文本里面不同的表情所对应的标志的！  </p>
<h3 id="解决点">解决点</h3><ol>
<li>我们要能遍历出当前文本中所有的表情，也就是NSTextAttachment类。</li>
<li>我们要能知道遍历出的表情，对应的标志是什么。</li>
</ol>
<h3 id="遍历所有的NSTextAttachment类属性">遍历所有的NSTextAttachment类属性</h3><p>遍历，嗯，先看看Apple有没有提供相应的方法，能遍历NSAttributedString（及其子类）的属性的。查阅文档：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAttributedString_Class/index.html#//apple_ref/occ/instm/NSAttributedString" target="_blank" rel="external">NSAttributedString Class Reference</a>，可以找到这么一个方法：“<strong>- enumerateAttribute:inRange:options:usingBlock:</strong>”，其原型如下：</p>
<pre><code>- (<span class="keyword">void</span>)enumerateAttribute:(<span class="built_in">NSString</span> *)attrName
                   inRange:(<span class="built_in">NSRange</span>)enumerationRange
                   options:(<span class="built_in">NSAttributedStringEnumerationOptions</span>)opts
                usingBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> value,
                                     <span class="built_in">NSRange</span> range,
                                     <span class="built_in">BOOL</span> *stop))block
</code></pre><p>用处：</p>
<pre><code>Executes <span class="operator">the</span> Block <span class="keyword">for</span> <span class="operator">the</span> specified attribute run <span class="operator">in</span> <span class="operator">the</span> specified range.
</code></pre><p>看，就是这个方法~就能遍历出NSTextAttachment对象了~</p>
<h3 id="创建NSTextAttachment的子类">创建NSTextAttachment的子类</h3><p>如何绑定NSTextAttachment所表示的表情和与其对应的标志？创建子类嘛~直接在子类中增加属性，保存标志不就行了。<br>如下：</p>
<pre><code><span class="variable">@interface</span> <span class="attribute">EmojiTextAttachment </span>: NSTextAttachment
<span class="variable">@property</span>(strong, nonatomic) NSString *emojiTag;
<span class="variable">@end</span>
</code></pre><p>所以，这个时候，插入表情的代码应该就是下面这样：</p>
<pre><code>EmojiTextAttachment *emojiTextAttachment = [EmojiTextAttachment <span class="keyword">new</span>];

<span class="comment">//保存表情标志</span>
emojiTextAttachment.emojiTag = emojiTag;

<span class="comment">//设置表情图片</span>
emojiTextAttachment.image = emojiImage;

<span class="comment">//插入表情</span>
[textView.textStorage <span class="string">insertAttributedString:</span>[NSAttributedString <span class="string">attributedStringWithAttachment:</span>emojiTextAttachment]
<span class="label">                                      atIndex:</span>textView.selectedRange.location];
</code></pre><h3 id="创建NSAttributedString的Category">创建NSAttributedString的Category</h3><p>最后，就是将这个遍历表情、拼接最终文本字符串的方法设置成NSAttributedString的自定义Category方法，以方便直接调用。<br>当然，这里面有些细节的处理，如替换表情标志时的字符串偏移量计算等，看代码吧。  </p>
<p>如下：</p>
<pre><code><span class="comment">//NSAttributedString+EmojiExtension.h</span>

<span class="class"><span class="keyword">@interface</span> <span class="title">NSAttributedString</span> (<span class="title">EmojiExtension</span>)</span>
- (<span class="built_in">NSString</span> *)getPlainString;
<span class="keyword">@end</span>


<span class="comment">//NSAttributedString+EmojiExtension.m</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">NSAttributedString</span> (<span class="title">EmojiExtension</span>)</span>

- (<span class="built_in">NSString</span> *)getPlainString {

    <span class="comment">//最终纯文本</span>
    <span class="built_in">NSMutableString</span> *plainString = [<span class="built_in">NSMutableString</span> stringWithString:<span class="keyword">self</span><span class="variable">.string</span>];

    <span class="comment">//替换下标的偏移量</span>
    __block <span class="built_in">NSUInteger</span> base = <span class="number">0</span>;

    <span class="comment">//遍历</span>
    [<span class="keyword">self</span> enumerateAttribute:<span class="built_in">NSAttachmentAttributeName</span> inRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="keyword">self</span><span class="variable">.length</span>)
                     options:<span class="number">0</span>
                  usingBlock:^(<span class="keyword">id</span> value, <span class="built_in">NSRange</span> range, <span class="built_in">BOOL</span> *stop) {

                      <span class="comment">//检查类型是否是自定义NSTextAttachment类</span>
                      <span class="keyword">if</span> (value &amp;&amp; [value isKindOfClass:[EmojiTextAttachment class]]) {
                          <span class="comment">//替换</span>
                          [plainString replaceCharactersInRange:<span class="built_in">NSMakeRange</span>(range<span class="variable">.location</span> + base, range<span class="variable">.length</span>)
                                                     withString:((EmojiTextAttachment *) value)<span class="variable">.emojiTag</span>];

                       <span class="comment">//增加偏移量                          </span>
                          base += ((EmojiTextAttachment *) value)<span class="variable">.emojiTag</span><span class="variable">.length</span> - <span class="number">1</span>;
                      }
                  }];

    <span class="keyword">return</span> plainString;
}

<span class="keyword">@end</span>
</code></pre><h3 id="使用">使用</h3><p>直接调用getPlainString方法即可。</p>
<h2 id="总结">总结</h2><p>其实本文也是来源于最近的项目需求，在网上一直找不到比较好的解决方案，就自己摸索出来一个。至于复杂的图文混合编辑，当然还是Core Text来的强大（自己也在学习中）~</p>
<p>如果有更好地办法，一定要告诉我啊~~~</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITextView_Class/#//apple_ref/occ/instp/UITextView/textStorage" target="_blank" rel="external">UITextView Class Reference</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAttributedString_Class/index.html#//apple_ref/occ/instm/NSAttributedString/enumerateAttribute:inRange:options:usingBlock:" target="_blank" rel="external">NSAttributedString Class Reference</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>在iOS开发中，经常需要用UITextView作为编辑文本的输入控件。<br>但是如何在编辑时插入自定义表情呢？就是像发微博时那样？  </p>
<p>本文简单的用<strong>NSTextAttachment</strong>、<strong>NSAttributedString</strong>的特性，实现了</p>
<ul>
<li>在UITextView中编辑文字时插入自定义表情图片</li>
<li>同时可以返回带有表情“<strong>替换符</strong>”的纯文本字符串。</li>
</ul>
<h2 id="示例">示例</h2><p>本文代码工程地址：<a href="https://github.com/zekunyan/UITextViewDIYEmojiExample">https://github.com/zekunyan/UITextViewDIYEmojiExample</a></p>
<p>效果图：</p>
<p><img src="http://zorrochen.qiniudn.com/inputEmoji_Sample.gif" alt="效果图"></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于评论不见了=。=]]></title>
    <link href="http://tutuge.me/2015/03/06/%E5%85%B3%E4%BA%8E%E8%AF%84%E8%AE%BA%E4%B8%8D%E8%A7%81%E4%BA%86/"/>
    <id>http://tutuge.me/2015/03/06/关于评论不见了/</id>
    <published>2015-03-06T01:09:32.000Z</published>
    <updated>2015-03-06T01:18:56.000Z</updated>
    <content type="html"><![CDATA[<p>前天升级了一次Hexo，原来的主题说啥也用不了了=。=（前端知识不足，正在补~）导致只能换主题，多说的评论就这样不见了。。。原来有留言的各位筒子，没看到，不好意思啊=。=</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前天升级了一次Hexo，原来的主题说啥也用不了了=。=（前端知识不足，正在补~）导致只能换主题，多说的评论就这样不见了。。。原来有留言的各位筒子，没看到，不好意思啊=。=</p>
]]>
    </summary>
    
      <category term="杂烩" scheme="http://tutuge.me/tags/%E6%9D%82%E7%83%A9/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Entity和Model的不同-关于代码的数据层]]></title>
    <link href="http://tutuge.me/2015/03/01/Entity%E5%92%8CModel%E7%9A%84%E4%B8%8D%E5%90%8C-%E5%85%B3%E4%BA%8E%E4%BB%A3%E7%A0%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%B1%82/"/>
    <id>http://tutuge.me/2015/03/01/Entity和Model的不同-关于代码的数据层/</id>
    <published>2015-03-01T15:03:10.000Z</published>
    <updated>2015-04-06T03:14:37.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>经常都能在一些博客、文档中看到“<strong>Model</strong>”、“<strong>Entity</strong>”的字样。如<strong>MVC</strong>模式中的“<strong>M就是Model</strong>”，“<strong>MVVM对应的Model-View-ViewModel</strong>”，数据库抽象层里面的“<strong>Model</strong>“等。  </p>
<p>它们的区别到底是什么？  </p>
<p>其实没有真正官方的对Entity和Model的定义，在此我只是说说我自己的理解。</p>
<a id="more"></a>
<h2 id="什么是Entity">什么是<strong>Entity</strong></h2><p>先看看这个单词是什么意思：<br><a href="http://www.iciba.com/entity" target="_blank" rel="external">爱词霸</a>：n: 实体，实际存在物，本质。</p>
<p>在代码中，我们经常会遇到一些具有“<strong>现实</strong>”意义的“<strong>个体</strong>”，如一个用户，一首歌曲，一条评论等等，它们都是在逻辑上完整的一个整体，都具有相似的结构，但是却因为“<strong>属性</strong>”的不同而不同。</p>
<p>看看一个典型的Entity类：</p>
<pre><code><span class="comment">//Java </span>

<span class="comment">//Entity类定义</span>
<span class="keyword">class</span> UserEntity {
    <span class="keyword">public</span> String name;
    <span class="keyword">public</span> <span class="keyword">int</span> age;
    <span class="keyword">public</span> String address;
}

<span class="comment">//Entity对象</span>
UserEntity john = <span class="keyword">new</span> UserEntity();
john.name = <span class="string">"John"</span>;
john.age = <span class="number">20</span>;
john.address = <span class="string">"China Hubei Wuhan"</span>;

UserEntity tom = <span class="keyword">new</span> UserEntity();
tom.name = <span class="string">"Tom"</span>;
tom.age = <span class="number">30</span>;
tom.address = <span class="string">"USA Californian"</span>;
</code></pre><p>所以：</p>
<ul>
<li>Entity类，或者说<strong>实体类</strong>，代表了一种“个体”，类中的属性（就是各种变量）则是这个“个体”的具体体现。如UserEntity类，里面有name、age属性，就是说Entity类“<strong>描述</strong>”了某种个体。</li>
<li>Entity类的具体对象，代表了一个具体的实体，一般来说，在代码当中，一个具体的Entity类对象所代表的实体应当是唯一的。</li>
<li>往往Entity类的定义跟数据库中的表定义是一一对应的。</li>
<li>而Entity的具体对象往往对应数据库中的一行数据。</li>
<li>Entity是代码中操作数据的“<strong>最小单元</strong>”。</li>
</ul>
<h2 id="什么是Model">什么是Model</h2><h3 id="各种用法">各种用法</h3><p>其实很多时候，Model有如下几种用法：</p>
<ol>
<li>当成Entity用，完全不具备其他业务逻辑代码。</li>
<li>当成<strong>数据库接口层</strong>，就是将数据库的读写，增删改查都封装在了Model中，往往就会有如“<strong>getUserByID</strong>”这样的方法。</li>
<li>当成纯粹的业务处理类。</li>
</ol>
<p>所以仁者见仁，智者见智，其实都可以。</p>
<p>在此说说我的认识。</p>
<h3 id="我的认识">我的认识</h3><p>先看看Model单词的意思:<br><a href="http://www.iciba.com/model" target="_blank" rel="external">爱词霸</a>：n: 模型；模式；典型。</p>
<p>既然是模型，而不是“数据”，所以我觉得，<strong>Model应该是利用Entity实体，来组合、处理、整合更上层、更抽象数据的类</strong>。</p>
<p>还是基于上面的“<strong>UserEntity</strong>”，看看下面的代码：</p>
<pre><code><span class="keyword">class</span> <span class="title">UserListModel</span> {
    <span class="keyword">private</span> UserEntity[] users;

    <span class="comment">//构造函数，初始化用户列表等。</span>

    <span class="function">UserEntity <span class="title">getUserByName</span>(<span class="params">String name</span>) </span>{
        <span class="comment">//查找...</span>
    }

    <span class="keyword">void</span> transformUserAddressFormat {
        <span class="comment">//转化地址格式</span>
    }
}
</code></pre><p>就是说，Entity还是原本的概念，只不过Model是基于Entity的更高层的数据抽象与处理。</p>
<h2 id="总结">总结</h2><p>说实话，Entity、Model，它们的职责到底是什么，真的不好说明白，大家也就做个参考吧=。=</p>
<h2 id="参考">参考</h2><ul>
<li><a href="http://stackoverflow.com/questions/3029952/ddd-and-mvc-difference-between-model-and-entity" target="_blank" rel="external">DDD and MVC: Difference between ‘Model’ and ‘Entity’</a></li>
<li><a href="http://whatis.techtarget.com/definition/entity" target="_blank" rel="external">Whatis.com Entity</a></li>
<li><a href="http://blogsh.de/2011/09/08/models-vs-entities" target="_blank" rel="external">Models vs. Entities</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>经常都能在一些博客、文档中看到“<strong>Model</strong>”、“<strong>Entity</strong>”的字样。如<strong>MVC</strong>模式中的“<strong>M就是Model</strong>”，“<strong>MVVM对应的Model-View-ViewModel</strong>”，数据库抽象层里面的“<strong>Model</strong>“等。  </p>
<p>它们的区别到底是什么？  </p>
<p>其实没有真正官方的对Entity和Model的定义，在此我只是说说我自己的理解。</p>]]>
    
    </summary>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一次审核被拒的经历-关于iCloud到底应该备份什么数据]]></title>
    <link href="http://tutuge.me/2015/02/28/%E4%B8%80%E6%AC%A1%E5%AE%A1%E6%A0%B8%E8%A2%AB%E6%8B%92%E7%9A%84%E7%BB%8F%E5%8E%86-%E5%85%B3%E4%BA%8EiCloud%E5%88%B0%E5%BA%95%E5%BA%94%E8%AF%A5%E5%A4%87%E4%BB%BD%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE/"/>
    <id>http://tutuge.me/2015/02/28/一次审核被拒的经历-关于iCloud到底应该备份什么数据/</id>
    <published>2015-02-28T10:18:11.000Z</published>
    <updated>2015-04-06T03:13:15.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>项目最近一次审核被拒了=。=<br>仔细看了一下后，发现是没有遵守“<strong>iOS Data Storage Guidelines</strong>”。<br>在此总结一下。</p>
<h2 id="被拒原因">被拒原因</h2><p>先看看被拒的反馈信息：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apps must follow <span class="keyword">the</span> iOS Data Storage Guidelines <span class="keyword">or</span> they will be rejected</span><br><span class="line"></span><br><span class="line">On <span class="command">launch</span> <span class="keyword">and</span> content download, your app stores <span class="number">12.14</span> MB, which <span class="keyword">does</span> <span class="keyword">not</span> comply <span class="keyword">with</span> <span class="keyword">the</span> iOS Data Storage Guidelines.</span><br></pre></td></tr></table></figure>
<p>大致意思就是App下载东西以后，在iCloud里面查看此App需要备份的体积变大了。  </p>
<a id="more"></a>
<p>再根据 <a href="https://developer.apple.com/icloud/documentation/data-storage/index.html" target="_blank" rel="external"><strong>iOS Data Storage Guidelines</strong></a>的说明，得出几点重要信息：</p>
<ul>
<li>只有<strong>用户创建的，并且不能被App重现的文档、数据</strong>，才应该被保存在“<strong><application_home>/Documents</application_home></strong>”路径下。</li>
<li>可以重新产生、下载的数据可以放在“<strong><application_home>/Library/Caches</application_home></strong>”目录下，如用于缓存的数据库文件。</li>
<li>纯粹用于缓存的数据可以放在“<strong><application_home>/tmp</application_home></strong>”目录下。</li>
<li>可以通过对NSURL加参数，来保证特定的文件夹及其内容不被iCloud备份，也不会被清除，如Document文件夹。</li>
</ul>
<p>所以可以初步得出被拒的原因是因为App中下载的文件也被包含在iCloud备份当中了，而Apple审核人员觉得这些文件不应该被备份。</p>
<h3 id="真正应该备份的数据">真正应该备份的数据</h3><p>所以，真正需要备份的文件是<strong>用户创建的，不能通过程序重新产生的</strong>，如记事本应用中用户创建的文本数据，绘画应用中用户画的画等。</p>
<h2 id="解决当中遇到的坑">解决当中遇到的坑</h2><p>既然知道了原因，那就好办了。</p>
<p>根据<strong>iOS Data Storage Guidelines</strong>的简短说明，乍一看，<strong><application_home>/Library/Caches</application_home></strong>是存放可以重新产生、下载的数据。</p>
<p>但是有个“陷阱”在这。</p>
<h3 id="系统可能清空的目录">系统可能清空的目录</h3><p>根据官方文档“<a href="https://developer.apple.com/library/mac/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple_ref/doc/uid/TP40010672-CH2-SW1" target="_blank" rel="external"><strong>File System Programming Guide</strong></a>”可以整理出一下两个系统可能会清除的目录：（在储存空间不够时）</p>
<ol>
<li><strong> Library/Caches/ </strong></li>
<li><strong> tmp/ </strong></li>
</ol>
<p>所以，像App下载的歌曲等资源文件是不能放在上面两个目录中的。</p>
<h2 id="解决：">解决：</h2><p>所以，为了保险起见，最靠谱的还是放在<strong><application_home>/Documents</application_home></strong>中，并且通过设置，不让iCloud备份。</p>
<p>Apple已经提供了相应的函数，如下（iOS 5.1及以后的版本）：</p>
<pre><code>- (BOOL)addSkipBackupAttributeToItemAtURL:(NSURL *)URL
{
    <span class="built_in">assert</span>(<span class="string">[[NSFileManager defaultManager] fileExistsAtPath: [URL path]]</span>);

    NSError *<span class="built_in">error</span> = <span class="keyword">nil</span>;
    BOOL success = [URL setResourceValue: [NSNumber numberWithBool: YES]
                                  forKey: NSURLIsExcludedFromBackupKey <span class="built_in">error</span>: &amp;<span class="built_in">error</span>];
    <span class="keyword">if</span>(!success){
        NSLog(@<span class="string">"Error excluding %@ from backup %@"</span>, [URL lastPathComponent], <span class="built_in">error</span>);
    }
    <span class="keyword">return</span> success;
}
</code></pre><h3 id="特性">特性</h3><ul>
<li><strong><application_home>/Documents</application_home></strong>根目录也可以通过上面的函数设置成不备份。（如应用AVPlayer）</li>
<li>设置是递归的，所以其所有子目录和文件都不用再设置一次，都会自动不被备份。（测试有效，但是不确定=。=，参考：<a href="http://stackoverflow.com/questions/14376883/is-nsurlisexcludedfrombackupkey-recursive" target="_blank" rel="external">is-nsurlisexcludedfrombackupkey-recursive</a>）</li>
</ul>
<h2 id="总结">总结</h2><p>多看官方说明=。=</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/icloud/documentation/data-storage/index.html" target="_blank" rel="external">iOS Data Storage Guidelines</a></li>
<li><a href="https://developer.apple.com/library/ios/qa/qa1719/_index.html" target="_blank" rel="external">How do I prevent files from being backed up to iCloud and iTunes?</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple_ref/doc/uid/TP40010672-CH2-SW4" target="_blank" rel="external">File System Programming Guide</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>项目最近一次审核被拒了=。=<br>仔细看了一下后，发现是没有遵守“<strong>iOS Data Storage Guidelines</strong>”。<br>在此总结一下。</p>
<h2 id="被拒原因">被拒原因</h2><p>先看看被拒的反馈信息：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apps must follow <span class="keyword">the</span> iOS Data Storage Guidelines <span class="keyword">or</span> they will be rejected</span><br><span class="line"></span><br><span class="line">On <span class="command">launch</span> <span class="keyword">and</span> content download, your app stores <span class="number">12.14</span> MB, which <span class="keyword">does</span> <span class="keyword">not</span> comply <span class="keyword">with</span> <span class="keyword">the</span> iOS Data Storage Guidelines.</span><br></pre></td></tr></table></figure>
<p>大致意思就是App下载东西以后，在iCloud里面查看此App需要备份的体积变大了。  </p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="审核" scheme="http://tutuge.me/tags/%E5%AE%A1%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Block类型变量-缓存Http请求与回调]]></title>
    <link href="http://tutuge.me/2015/02/19/Block%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F-%E7%BC%93%E5%AD%98Http%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%9B%9E%E8%B0%83/"/>
    <id>http://tutuge.me/2015/02/19/Block类型变量-缓存Http请求与回调/</id>
    <published>2015-02-18T19:18:36.000Z</published>
    <updated>2015-04-06T03:13:45.000Z</updated>
    <content type="html"><![CDATA[<p>##前言<br>Objective-C中的Blocks实在是太好用了，有了它，我们就可以将“代码块”封装起来，当成变量使用、传递，所以，在Objective-C中，iOS中，许多的回调是用Block来完成的。</p>
<p>##问题<br>我自己在之前的项目中，就遇到过一个问题。因为项目的需要，手机端所有的跟服务器的通信都需要“加密”，在经过一番调研后，我们使用的是类似OAuth机制（至于什么是OAuth，各位Google一下就明白了，大部分的公共API都用到了这种机制）。</p>
<a id="more"></a>
<p>###缓存Http请求后的回调代码块<br>既然是OAuth机制，就是说我们每次向服务器发起的请求，除了跟业务相关的参数，还需要带上AccessToken、UserToken这类的授权参数，而AccessToken在本次请求中是否会过期，在结果返回前是不知道的，所以，为了更好地用户体验，不至于让用户在某个时刻的操作，因为授权过期了而“没有响应”，我们的每次Http请求都必须缓存起来。</p>
<p>这里的缓存可不是单单指缓存请求的参数、URL，更重要的是缓存Http请求成功或者失败时的“<strong>回调代码块</strong>”。</p>
<p>##实现</p>
<p>###AFNetworking的Get方法<br>在iOS的项目中，AFNetworking应该算是使用的最多的网络库了，它的Get请求的方法接口如下：</p>
<pre><code><span class="pp">- <span class="params">(<span class="variable">AFHTTPRequestOperation</span> *)</span>GET:<span class="params">(<span class="variable">NSString</span> *)</span>URLString
                     parameters:<span class="params">(id)</span>parameters
                        success:<span class="params">(void (^)</span><span class="params">(<span class="variable">AFHTTPRequestOperation</span> *operation, id response<span class="variable">Object</span>)</span>)success
                        failure:<span class="params">(void (^)</span><span class="params">(<span class="variable">AFHTTPRequestOperation</span> *operation, <span class="variable">NSError</span> *error)</span>)failure</span>
</code></pre><p>只有四个参数，分别是Url、参数、成功的回调Block，失败的回调Block，看，这里，回调的代码块就被封装到了Block里面，并当成参数传入。</p>
<p>###再次封装<br>介于AFNetworking只提供了最基本的Get、Post、Put这些方法，所以，我们往往根据业务的接口做了封装，如先定义了请求的类型枚举：</p>
<pre><code>//Http type, for<span class="instruction"> execute
</span>typedef<span class="function"> NS_ENUM(</span>NSUInteger, HTTP_REQUEST_TYPE<span class="function">)</span> {
    ICG_GET = 0,
    ICG_POST
};
</code></pre><p>然后定义了统一的请求入口与回调参数Block：</p>
<pre><code><span class="comment">//请求成功后的回调</span>
typedef <span class="typename">void</span> (^http_success)(id result);
<span class="comment">//请求失败后的回调</span>
typedef <span class="typename">void</span> (^http_fail)();

<span class="comment">//统一的请求入口</span>
+ (<span class="typename">void</span>)<span class="string">executeWithType:</span>(HTTP_REQUEST_TYPE)type <span class="string">api:</span>(NSString *)api
<span class="label">            parameters:</span>(NSDictionary *)parameters <span class="string">success:</span>                (http_success)success <span class="string">fail:</span>(http_fail)fail {    

    <span class="comment">//为每个请求增加AccessToken、UserToken等公共参数</span>
    <span class="comment">//...</span>

    <span class="comment">//缓存Http请求</span>
    <span class="comment">//...</span>

    <span class="comment">//根据type区分具体是哪一种Http请求。</span>
    <span class="keyword">switch</span> (type) {
        <span class="keyword">case</span> <span class="string">ICG_GET:</span>
            [HttpUtil <span class="string">get:</span>url <span class="string">parameters:</span>paras <span class="string">success:</span>success <span class="string">fail:</span>fail];
            <span class="keyword">break</span>;    
        <span class="keyword">case</span> <span class="string">ICG_POST:</span>
            [HttpUtil <span class="string">post:</span>url <span class="string">parameters:</span>paras <span class="string">success:</span>success <span class="string">fail:</span>fail];
            <span class="keyword">break</span>;    
<span class="label">        default:</span>
            <span class="keyword">break</span>;
    }
}
</code></pre><p>###再次封装的好处<br>为什么要再次做封装，将基本的Http请求统一入口？道理很简单，就是为了能方便的对每次请求增加额外的处理，并且对上层调用透明。如:</p>
<ul>
<li>统一为每个请求增加Log。</li>
<li>统一为每个请求增加如AccessToken这些额外的参数。</li>
<li>方便对Http请求做缓存！</li>
</ul>
<p>###缓存Http请求的数据结构<br>既然我们已经有了统一的请求入口，为了缓存，所需要做的就是将能代表一次请求的所有参数缓存起来就行了，如URL、请求参数等，如下数据结构：</p>
<pre><code><span class="variable">@interface</span> <span class="attribute">RequestHolder </span>: NSObject

<span class="comment">//URL地址</span>
<span class="variable">@property</span>(strong, nonatomic) NSString *url;
<span class="comment">//请求参数</span>
<span class="variable">@property</span>(strong, nonatomic) NSMutableDictionary *paras;
<span class="comment">//请求类型，如Get、Post</span>
<span class="variable">@property</span>(assign, nonatomic) HTTP_REQUEST_TYPE type;
<span class="comment">//请求成功回调</span>
<span class="variable">@property</span>(copy) http_success success;
<span class="comment">//请求失败回调</span>
<span class="variable">@property</span>(copy) http_fail fail;
<span class="variable">@end</span>
</code></pre><p>这几个参数，就可以完整的“代表、重现”一次具体的Http请求。</p>
<p>###如何缓存<br>只要App开启，Http请求就会不停地产生，会有源源不断的请求，难道我们把每次请求都缓存起来？</p>
<p>全部都缓存肯定是不行的，所以我们需要一个缓存策略。</p>
<p>一个App中，所有的Http请求的路径，也就是Url，不包括参数，应该是数量固定的，如“/user, /comment”，并且，一个请求往往对应的操作、功能也是唯一的，所以，完全可以以请求的<strong>Url</strong>为<strong>Key</strong>，以本次请求的“<strong>RequestHolder</strong>”为<strong>Value</strong>，用Objective-C中的NSDictionary来缓存Http请求。</p>
<p>所以，缓存请求的方法大致如下：</p>
<pre><code><span class="comment">//缓存Http请求</span>

- (<span class="keyword">void</span>)cacheHttpRequest:(HTTP_REQUEST_TYPE)<span class="class"><span class="keyword">type</span> <span class="title">url</span>:</span>(NSString *)url
                parameters:(NSMutableDictionary *)parameters success:(http_success)success fail:(http_fail)fail {

    <span class="comment">//创建缓存数据结构，保存本次请求的参数、回调</span>
    ICGRequestHolder *requestHolder = [ICGRequestHolder <span class="keyword">new</span>];
    requestHolder.url = url;
    requestHolder.paras = parameters;
    requestHolder.success = [success copy];
    requestHolder.fail = [fail copy];
    requestHolder.<span class="keyword">type</span> = <span class="class"><span class="keyword">type</span>;</span>

    <span class="comment">//保存本次请求</span>
    [_operationQueue addOperationWithBlock:^{
        _cachedRequests[url] = requestHolder;
    }];
}
</code></pre><p>这样，就能完整的缓存Http请求了。</p>
<p>###从缓存中恢复Http请求<br>恢复请求很简单，直接遍历所有缓存的请求，再次发起Http请求即可，就不再贴代码了。</p>
<p>###删除成功的Http请求<br>缓存的目的是在请求失败时，如AccessToken超时时，我们可以在重新获取AccessToken后重现上次失败的请求，所以，一旦请求成功时，我们还需要将成功的请求删除，当然，也是利用Url，如下：</p>
<pre><code>- (<span class="typename">void</span>)<span class="string">removeRequestForKey:</span>(NSString *)url {
    <span class="comment">//放入队列执行</span>
    [_operationQueue <span class="string">addOperationWithBlock:</span>^{
        <span class="comment">//删除Url对应的请求</span>
        [_cachedRequests <span class="string">removeObjectForKey:</span>url];
    }];
}
</code></pre><p>##总结<br>本文只是简单地利用Objective-C中的Block特性，实现了Http请求的缓存。目的不是介绍Block，是为了分享我自己在项目中运用Block的例子，如果读者有更好的方法，欢迎留言啊~~</p>
<p>##参考、推荐阅读</p>
<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html" target="_blank" rel="external">Working with Blocks</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>##前言<br>Objective-C中的Blocks实在是太好用了，有了它，我们就可以将“代码块”封装起来，当成变量使用、传递，所以，在Objective-C中，iOS中，许多的回调是用Block来完成的。</p>
<p>##问题<br>我自己在之前的项目中，就遇到过一个问题。因为项目的需要，手机端所有的跟服务器的通信都需要“加密”，在经过一番调研后，我们使用的是类似OAuth机制（至于什么是OAuth，各位Google一下就明白了，大部分的公共API都用到了这种机制）。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[提升UITableView性能-复杂页面的优化]]></title>
    <link href="http://tutuge.me/2015/02/19/%E6%8F%90%E5%8D%87UITableView%E6%80%A7%E8%83%BD-%E5%A4%8D%E6%9D%82%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://tutuge.me/2015/02/19/提升UITableView性能-复杂页面的优化/</id>
    <published>2015-02-18T17:28:41.000Z</published>
    <updated>2015-09-24T11:01:15.000Z</updated>
    <content type="html"><![CDATA[<p>##前言</p>
<p>随着App的用户界面的内容越来越丰富，再强的手机可能都无法同时渲染复杂的UI界面和保证流畅的体验。所以，我们这些程序猿=。=在写代码的时候就要注意，如何尽可能提高用户的操作流畅性。</p>
<p>之前的做的项目，<a href="https://itunes.apple.com/us/app/qing-ju-yin-le-quan-guo-zui/id913235479?l=zh&amp;ls=1&amp;mt=8" target="_blank" rel="external">青桔音乐iOS客户端</a>里面的首页就是一个类似微信朋友圈的“动态”页面，大致如下：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_ios_speed_up_uitableview_1_1.png?imageView2/0/h/300" alt="青桔动态页面"></p>
<p>如果是你，你会怎么实现这个页面呢？</p>
<p>这还用问，当然是用UITableView+自定义的UITableViewCell。</p>
<p>UITableView是可以滑动的，为了不让用户在滑动中感到有卡顿，该如何优化？下面，我就写一下我自己在做项目时的“经验”~</p>
<a id="more"></a>
<p>##优化</p>
<p>主要分为以下几点：</p>
<ul>
<li>只定义一种Cell。</li>
<li>提前计算并缓存每个Cell的高度。</li>
<li>提前创建真正显示的、需要加工的数据并缓存。</li>
<li>缓存View！</li>
<li>其它。</li>
</ul>
<h3 id="只定义一种Cell">只定义一种Cell</h3><p>乍一看，这个界面至少有3种样式的Cell，为什么只定义一种呢？</p>
<h4 id="分析结构">分析结构</h4><p>仔细分析一下，页面中每个Cell的内容都有头像、标题、正文、评论、其它（歌曲、图片、歌手）。所以，从整体上看，每个Cell的结构是一致的！</p>
<h4 id="重用=大致固定数量的Cell">重用=大致固定数量的Cell</h4><p>并且，凡是认真研究过UITableView的人应该都知道，Apple已经为我们提供了Cell的重用，如用“<strong>registerNib:forCellReuseIdentifier</strong>”方法注册自定义Cell的Nib，然后在“<strong>cellForRowAtIndexPath</strong>”的时候用“<strong>dequeueReusableCellWithIdentifier</strong>”获取可以重用的Cell，所以，无论UITableView要显示内容有多少，真正创建出的Cell可能只有5、6个。</p>
<p>所以，我们完全可以只创建一种Cell，虽然这样一个Cell的“体积”可能会很大，但是介于Cell的数量不会很多，所以完全可以接受。</p>
<h5 id="只定义一种Cell的好处"><strong>只定义一种Cell的好处</strong></h5><ul>
<li>减少代码量，减少Nib文件的数量，统一一个Nib文件定义Cell，容易修改、维护。</li>
<li>基于Cell的重用，真正运行时铺满屏幕所需的Cell数量大致是固定的，设为<strong>N</strong>个。所以如果如果只有一种Cell，那就是只有<strong>N</strong>个Cell的实例；但是如果有<strong>M</strong>种Cell，那么运行时最多可能会是“<strong>M x N = MN</strong>”个Cell的实例，虽然可能并不会占用太多内存，但是能少点不是更好吗。</li>
</ul>
<h4 id="善用hidden隐藏（显示）Subview">善用hidden隐藏（显示）Subview</h4><p>既然只定义一种Cell，那该如何显示不同类型的内容呢？<br>答案就是，把所有不同类型的view都定义好，放在cell里面，通过hidden显示、隐藏，来显示不同类型的内容。如下图定义Cell：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_ios_speed_up_uitableview_1_2.jpg?imageView2/0/h/400" alt="Cell示意图"></p>
<p>图中的Subview1、Subview2、Subview3就是不同类型Cell的不同之处，所以我们在“<strong>cellForRowAtIndexPath</strong>”函数中，设置Cell的样式、内容时，就可以通过显示、隐藏这三个子view来显示。</p>
<p>毕竟，在用户快速滑动中，只是单纯的显示、隐藏subview比实时创建要快得多。</p>
<h3 id="提前计算并缓存每个Cell的高度">提前计算并缓存每个Cell的高度</h3><p>开发过Android，用过Android的ListView以后，对UITableView需要提前计算Cell的高度很不适应。=。= </p>
<p>首先要确定的是，在iOS中，系统会先调用“<strong>tableView:heightForRowAtIndexPath:</strong>”获取每个Cell即将显示的高度，从而确定整个UITableView的布局。然后才调用“<strong>tableView:cellForRowAtIndexPath</strong>”获取每个Cell，我们也是在这里填充、设置Cell的。</p>
<p><strong>所以，既然高度总会被用到，那就早早的在获取数据时就计算好吧！</strong></p>
<h4 id="在Model（Entity）中计算并保存Cell的高度">在Model（Entity）中计算并保存Cell的高度</h4><p>其实，在Model（Entity）中保存UI的参数是很奇怪的=。=（最好放在ViewModel中，就是MVVM模式的），我们的Entity可能就是下面的样子：</p>
<pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">DataEntity</span> : <span class="title">NSObject</span></span>

<span class="comment">//原始数据</span>
<span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *content;
<span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *title;

<span class="comment">//Cell 高度</span>
<span class="keyword">@property</span>(<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> cellHeight;

<span class="comment">//计算高度</span>
- (<span class="keyword">void</span>)calculateCellHeight;

<span class="keyword">@end</span>
</code></pre><p>这样，就不用在“<strong>tableView:heightForRowAtIndexPath:</strong>”中每次都计算了。</p>
<h3 id="提前创建真正显示的、需要加工的数据并缓存">提前创建真正显示的、需要加工的数据并缓存</h3><p>Cell中显示的内容，很多时候可能并不是直接从服务器拿到的数据，而是经过“加工”的数据。如本文中的“动态”也，每个Cell的标题、正文都有可点击的连接Link、表情图片等富文本内容，而我们一般用NSAttributeString类来显示。</p>
<p>既然每次都会用到，倒不如在获取到数据的时候就创建、加工好这些内容，等到需要现实的时候，直接拿来用不就行了。</p>
<p>所以，我们的Entity类可能变成下面这个样子: </p>
<pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">DataEntity</span> : <span class="title">NSObject</span></span>

<span class="comment">//原始数据</span>
<span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *content;
<span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *title;

<span class="comment">//Cell 高度</span>
<span class="keyword">@property</span>(<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> cellHeight;

<span class="comment">//真正显示的内容</span>
<span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSAttributedString</span> *showTitle;
<span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSAttributedString</span> *showContent;

<span class="comment">//计算高度</span>
- (<span class="keyword">void</span>)calculateCellHeight;

<span class="comment">//创建、加工真正显示的内容</span>
- (<span class="keyword">void</span>)setupShowTitileAndContent;

<span class="keyword">@end</span>
</code></pre><p>这样，在“<strong>tableView:cellForRowAtIndexPath</strong>”中，我们直接拿showTitle、showContent来显示就好，不用再创建。</p>
<h3 id="缓存View!">缓存View!</h3><p>什么？缓存View？！</p>
<p>是的，当Cell中的部分View是非常独立的，并且不便于重用的，而且“体积”非常小，在内存可控的前提下，我们完全可以将这些view缓存起来！</p>
<p>方法当然也是将缓存的view放在Entity中~。</p>
<h3 id="其它">其它</h3><p>当然，还有其他的优化方法，简单说一说：</p>
<ul>
<li>尽量设置Cell的view为opaque，避免GPU对Cell下面的内容也进行绘制。</li>
<li>避免大量的图片缩放、颜色渐变等。</li>
<li>避免同步的从网络、文件获取数据（这个是必须的=。=）</li>
<li>用shadowPath创建阴影。</li>
<li>尽量减少subview的数量，如多用drawRect绘制元素，替代用view显示。</li>
<li>尽量显示“<strong>大小刚好合适</strong>”的图片资源。</li>
</ul>
<h2 id="总结">总结</h2><p>总的来说，就是：</p>
<p><strong>缓存一切可以缓存的！就是“用空间替换时间”！</strong></p>
<p><strong>在UITableView的Delegate、DataSource方法中，减少任何不必要的操作</strong></p>
<h2 id="参考，推荐阅读">参考，推荐阅读</h2><ul>
<li><a href="http://www.raywenderlich.com/31166/25-ios-app-performance-tips-tricks#tableviews" target="_blank" rel="external">25 iOS App Performance Tips &amp; Tricks</a></li>
<li><a href="http://stackoverflow.com/questions/1352479/tricks-for-improving-iphone-uitableview-scrolling-performance" target="_blank" rel="external">Tricks for improving iPhone UITableView scrolling performance?</a></li>
<li><a href="http://stackoverflow.com/questions/6172158/how-can-i-speed-up-a-uitableview" target="_blank" rel="external">How can I speed up a UITableView?</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>##前言</p>
<p>随着App的用户界面的内容越来越丰富，再强的手机可能都无法同时渲染复杂的UI界面和保证流畅的体验。所以，我们这些程序猿=。=在写代码的时候就要注意，如何尽可能提高用户的操作流畅性。</p>
<p>之前的做的项目，<a href="https://itunes.apple.com/us/app/qing-ju-yin-le-quan-guo-zui/id913235479?l=zh&amp;ls=1&amp;mt=8">青桔音乐iOS客户端</a>里面的首页就是一个类似微信朋友圈的“动态”页面，大致如下：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_ios_speed_up_uitableview_1_1.png?imageView2/0/h/300" alt="青桔动态页面"></p>
<p>如果是你，你会怎么实现这个页面呢？</p>
<p>这还用问，当然是用UITableView+自定义的UITableViewCell。</p>
<p>UITableView是可以滑动的，为了不让用户在滑动中感到有卡顿，该如何优化？下面，我就写一下我自己在做项目时的“经验”~</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NSString的Copy与内存分配]]></title>
    <link href="http://tutuge.me/2015/02/18/NSString%E7%9A%84Copy%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>http://tutuge.me/2015/02/18/NSString的Copy与内存分配/</id>
    <published>2015-02-18T09:00:47.000Z</published>
    <updated>2015-09-24T10:59:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>不管是用什么语言开发，字符串应该算是用的最多的了。在Objective-C中，字符串类是NSString，以及其子类NSMutableString等。所以，对于字符串类，编程语言、编译器等往往会做特殊处理。下面我就说说我自己在项目中发现的NSString的“奇怪”的地方。</p>
<a id="more"></a>
<h2 id="字符串常量，copy，mutableCopy">字符串常量，copy，mutableCopy</h2><h3 id="Example">Example</h3><p>先看看如下面的代码，猜猜会输出什么：</p>
<pre><code><span class="built_in">NSString</span> *str1 = <span class="string">@"abc"</span>;
<span class="built_in">NSString</span> *str2 = <span class="string">@"abc"</span>;
<span class="built_in">NSString</span> *str3 = [[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@"abc"</span>];
<span class="built_in">NSString</span> *str4 = [str1 <span class="keyword">copy</span>];
<span class="built_in">NSString</span> *str5 = [str1 mutableCopy];

<span class="comment">//输出内存中的地址</span>
<span class="built_in">NSLog</span>(<span class="string">@"str1: %p"</span>, str1);
<span class="built_in">NSLog</span>(<span class="string">@"str2: %p"</span>, str2);
<span class="built_in">NSLog</span>(<span class="string">@"str3: %p"</span>, str3);
<span class="built_in">NSLog</span>(<span class="string">@"str4: %p"</span>, str4);
<span class="built_in">NSLog</span>(<span class="string">@"str5: %p"</span>, str5);
</code></pre><p>直接给出结果：</p>
<pre><code><span class="comment">//地址值由运行时决定，不唯一</span>
str1: <span class="number">0x10cd12040</span>
str2: <span class="number">0x10cd12040</span>
str3: <span class="number">0x10cd12040</span>
str4: <span class="number">0x10cd12040</span>
str5: <span class="number">0x7f874b508350</span> <span class="comment">//mutable copy</span>
</code></pre><p>看，是不是很“神奇”。</p>
<h3 id="简单解释">简单解释</h3><p>NSString是“不可变（immutable）”的类型，这个是关键。<br>代码中的“@”开头的字符串，其实就是一个字符串常量，运行时会检测这个字符串是否已经存在，存在的话，就直接将这个字符串的地址赋给变量；不存在的话，则创建，再赋值。</p>
<p><strong>第一行</strong>: “abc”字符串不存在，创建，取得字符串地址“0x10cd12040”，赋给str1. </p>
<p><strong>第二行</strong>: “abc”字符串已经存在，直接将地址“0x10cd12040”赋给str2.  </p>
<p><strong>第三行</strong>: （记住，NSString是不可变的）alloc并不会分配新的内存，直接将字符串地址“0x10cd12040”赋给str3.  </p>
<p><strong>第四行</strong>: copy，既然是不可变的，也就没有必要分配新内存，直接将地址“0x10cd12040”赋给str4.  </p>
<p><strong>第五行</strong>: mutableCopy其实就是创建一个NSMutableString的实例，既然是“可变（mutable）”的类型了，当然要分配新的内存，所以，字符串的地址也变成新的“0x7f874b508350”。</p>
<p>可以这么说，编译器、runtime充分利用了NSString是“<strong>不可变（immutable）</strong>”类型这个特点，只要字符串内容一致，就不会分配新的内存储存，字符串在程序中使用量非常大，这么做无疑可以大大节省内存，提升性能。</p>
<h2 id="Property_和_NSString">Property 和 NSString</h2><p>先来看看一个UserEntity类：</p>
<pre><code><span class="comment">//UserEntity.h</span>

<span class="variable">@interface</span> <span class="attribute">UserEntity </span>: NSObject &lt;NSCopying&gt;
<span class="variable">@property</span>(strong, nonatomic) NSString *name;
<span class="variable">@end</span>
</code></pre><p>只有一个名为name的NSString类型Property。<br>相信大家对这个不陌生吧。一般我们的应用中会有很多Entity类型，每个Entity类里面肯定避免不了有许多NSString的字符串类型。这里的name的属性是：strong和nonatomic，strong表明name要“持有”一份name所指的字符串的引用，nonatomic表示property类型不用加锁。</p>
<p>接着咱们看看下面的代码：</p>
<pre><code>UserEntity *userEntity = [UserEntity <span class="keyword">new</span>];        

<span class="comment">//创建mutable类型的字符串</span>
NSMutableString *showName = [[NSMutableString alloc] <span class="string">initWithString:</span>@<span class="string">"tutuge"</span>];        

<span class="comment">//先保存“tutuge”字符串到userEntity的name</span>
userEntity.name = showName;        

<span class="comment">//修改showName</span>
[showName <span class="string">appendString:</span>@<span class="string">" blog"</span>];        

<span class="comment">//输出userEntity的name属性</span>
NSLog(@<span class="string">"Name: %@"</span>, userEntity.name);
</code></pre><p>猜猜会输出什么？</p>
<pre><code><span class="attribute">Name</span>: <span class="string">tutuge blog</span>
</code></pre><p>看，我们明明是保存的“tutuge”，怎么到后面输出的是“tutuge blog”？</p>
<h3 id="让NSString类型的Property为Copy型">让NSString类型的Property为Copy型</h3><p>因为name的Property属性是strong的，所以赋值后，它跟showName均指向同一个NSMutableString实例，如下：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_ios_nsstring_copy_1_1.jpg" alt="内存示意图"></p>
<p>所以改变了showName，当然name输出的值也就变了。<br>这个时候，name的property属性就不能是strong了，应该是copy，如下：</p>
<pre><code><span class="comment">//UserEntity.h</span>

<span class="variable">@interface</span> <span class="attribute">UserEntity </span>: NSObject &lt;NSCopying&gt;
<span class="variable">@property</span>(copy, nonatomic) NSString *name;
<span class="variable">@end</span>
</code></pre><p>这样的话，当“<strong>userEntity.name = showName;</strong>”这句运行后，内存布局如下：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_ios_nsstring_copy_1_2.jpg" alt="内存示意图"></p>
<p>这样，就避免了这个问题。</p>
<h2 id="总结">总结</h2><p>很所时候，代码并不是看上去那样“运行”的，多试试，多查阅资料，就能了解其中的奥秘了~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>不管是用什么语言开发，字符串应该算是用的最多的了。在Objective-C中，字符串类是NSString，以及其子类NSMutableString等。所以，对于字符串类，编程语言、编译器等往往会做特殊处理。下面我就说说我自己在项目中发现的NSString的“奇怪”的地方。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用NSProxy实现消息转发-模块化的网络接口层设计-原创]]></title>
    <link href="http://tutuge.me/2015/02/16/%E5%88%A9%E7%94%A8NSProxy%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82%E8%AE%BE%E8%AE%A1-%E5%8E%9F%E5%88%9B/"/>
    <id>http://tutuge.me/2015/02/16/利用NSProxy实现消息转发-模块化的网络接口层设计-原创/</id>
    <published>2015-02-16T10:52:08.000Z</published>
    <updated>2015-09-24T11:01:45.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>之前在做项目的时候，所有业务的网络接口方法，全部都写在了一个文件里面，一开始还好，毕竟每个方法的代码也只是十几行，增加、修改也比较容易。但是随着接口的增多，这个文件慢慢居然超过了1000行，里面几十个方法都写在一起，实在是不好维护。  </p>
<p>虽然保持这样也没有什么，多用用Cmd+F就能找到。但是，真是越看越不顺眼😳， 代码一定要有“美感”啊~😝</p>
<p>所以在查阅了大量文章后，终于想出了本文即将说明的办法，越发觉得Objective-C的“消息”机制是多么的赞~😚</p>
<h2 id="Github_示例">Github 示例</h2><p>贴上本文中的示例工程：<a href="https://github.com/zekunyan/HttpProxyExample" target="_blank" rel="external">https://github.com/zekunyan/HttpProxyExample</a></p>
<a id="more"></a>
<h2 id="问题">问题</h2><p>先抛出问题。  </p>
<p>一款互联网应用，免不了要跟服务器打交道，在iOS项目中，最有名的网络库应该就是<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a>了。所以，很多人就会利用AFnetworking提供的Get、Post等基本Http请求接口，封装自己的网络接口层代码，我自己在项目中也是这么做的。  </p>
<p>但是，AFNetworking只是提供了Get、Post、Json传输等基本的Http请求方法，所以一旦落实到具体的业务相关的请求上，我们要为每个请求（URL）都写一个单独的接口方法。</p>
<p><strong>那么，问题就来了</strong>  </p>
<p>业务相关的接口那么多，举个例子，什么“通过用户ID获取用户基本信息”、“获取用户的所有评论”等，每个请求都是一个方法，这么多方法该怎么组织呢？全部放在一起？那这个接口类岂不是会非常乱？不放在一起？那岂不是会有很多个网络请求类？(至于要不要统一接口入口，我想这个根据项目来决定吧=。=)</p>
<h2 id="需求">需求</h2><ul>
<li>所有网络接口都从统一的类调用，如HttpProxy。</li>
<li>网络接口的具体实现，按照业务划分到不同的类中，如“<strong>UserHttpHandler</strong>”、“<strong>CommentHttpHandler</strong>”。</li>
</ul>
<p>其实，按照面向对象的原则，就是接口代理类<strong>HttpProxy</strong>拥有若干个按照业务划分的接口（Interface），这些接口的所有方法组成了网络层的不同的Http请求。如下图：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_ios_http_proxy_1_1.jpg" alt="请求示意图"></p>
<p>那么，调用的时候，所有接口都用HttpProxy调用，如：</p>
<pre><code><span class="comment">//实际调用的是UserHttpHandler类的方法</span>
<span class="attr_selector">[[HttpProxy sharedInstance]</span> <span class="tag">getUserWithID</span>:@<span class="tag">100</span>];

<span class="comment">//实际调用的是CommentHttpHandler类的方法</span>
<span class="attr_selector">[[HttpProxy sharedInstance]</span> <span class="tag">getCommentsWithDate</span><span class="pseudo">:date</span>];
</code></pre><h2 id="关键">关键</h2><p>根据前面的描述，我们可以得出，关键就是：<strong>消息转发（Message Forward）</strong></p>
<p>Objective-C里面没有我们传统的“方法调用”，取而代之的是“消息”，所有的方法都是通过向对象发送“消息”实现调用的。而这个机制，也就为我们的实现提供了方便。</p>
<p>也就是说：我们要将发给“<strong>HttpProxy</strong>”的消息，让HttpProxy转发给真正能接受这个消息的对象，HttpProxy就是个<strong>代理</strong>。</p>
<p>苹果已经给我们提供了这个“代理”类了-NSProxy。</p>
<h2 id="NSProxy">NSProxy</h2><p>什么是NSProxy：</p>
<ul>
<li>NSProxy没有父类，是顶级类(根类)，跟NSObject同等地位。</li>
<li>NSProxy和NSObject都实现了“<strong>NSObject</strong> Protocol”。</li>
<li>NSProxy设计时就是以“抽象类”设计的，专门为<strong>转发消息</strong>而生。</li>
</ul>
<p>实现要求:</p>
<ol>
<li>继承NSProxy的子类要实现自己的初始化方法，如“init”、“initWith”。</li>
<li>重写“<strong> - forwardInvocation: </strong>”和“<strong> - methodSignatureForSelector: </strong>”方法，完成消息转发。</li>
</ol>
<p>详细内容参考Apple的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSProxy_Class/index.html#//apple_ref/occ/instm/NSProxy/forwardInvocation:" target="_blank" rel="external">文档</a>。</p>
<h2 id="实现">实现</h2><h3 id="定义">定义</h3><p>先不管HttpProxy，咱们看看具体的接口，先举两个例子：</p>
<pre><code><span class="comment">//UserHttpHandler.h</span>
<span class="comment">//用户相关接口</span>
<span class="variable">@protocol</span> UserHttpHandler &lt;NSObject&gt;
- (void)<span class="attribute">getUserWithID</span>:(NSNumber *)userID;
<span class="variable">@end</span>

<span class="comment">//CommentHttpHandler.h</span>
<span class="comment">//评论相关接口</span>
<span class="variable">@protocol</span> CommentHttpHandler &lt;NSObject&gt;
- (void)<span class="attribute">getCommentsWithDate</span>:(NSDate *)date;
<span class="variable">@end</span>
</code></pre><p>好的，接口有了，我们的HttpProxy类应该“实现”了这两个接口。<br>然后，最好是单例类，所以还要有个获取单例的方法。<br>最后，还需要一个向HttpProxy注册具体实现了接口Protocol的方法。</p>
<p>所以，HttpProxy应该是这个样子的：</p>
<pre><code><span class="comment">//HttpProxy.h</span>

<span class="comment">//1. 继承了NSproxy。 2. “实现”了网络接口Protocol</span>
<span class="annotation">@interface</span> <span class="string">HttpProxy :</span> NSProxy &lt;UserHttpHandler, CommentHttpHandler&gt;

<span class="comment">//获取单例</span>
+ (instancetype)sharedInstance;

<span class="comment">//注册具体实现类</span>
- (<span class="typename">void</span>)<span class="string">registerHttpProtocol:</span>(Protocol *)httpProtocol <span class="string">handler:</span>(id)handler;

<span class="annotation">@end</span>
</code></pre><h3 id="找到消息对应的实现类对象">找到消息对应的实现类对象</h3><p>如何在HttpProxy做消息转发时，找到某个消息对应的真正的实现类对象呢？</p>
<p>最好的办法就是保存每个接口方法到其实现类对象的映射，可以用Dictionary保存，关系如下图：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_ios_http_proxy_1_2.jpg" alt="image"></p>
<p>所以，<strong>registerHttpProtocol:handler:</strong>方法的职责就是：</p>
<ol>
<li>遍历Protocol的所有方法（利用Objective-C的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html" target="_blank" rel="external">Runtime功能</a>）。</li>
<li>保存Protocol所有方法到实现类的对象的映射关系。（用方法的字符串表示作为key，实现类对象为value）</li>
</ol>
<p>所以，HttpProxy应该持有一个Dictionary的实例，用于保存映射关系，HttpProxy的实现部分如：</p>
<pre><code><span class="comment">//HttpProxy.m</span>

<span class="variable">@interface</span> HttpProxy ()
<span class="comment">//保存映射关系的字典。</span>
<span class="variable">@property</span>(strong, nonatomic) NSMutableDictionary *selToHandlerMap;
<span class="variable">@end</span>
</code></pre><p>注册方法实现如下：</p>
<pre><code>- (<span class="type">void</span>)registerHttpProtocol:(<span class="type">Protocol</span> *)httpProtocol handler:(id)handler {
    unsigned <span class="type">int</span> numberOfMethods = <span class="number">0</span>;

    //<span class="type">Get</span> all methods <span class="keyword">in</span> protocol
    struct objc_method_description *methods = protocol_copyMethodDescriptionList(
            httpProtocol, <span class="type">YES</span>, <span class="type">YES</span>, &amp;numberOfMethods);

    //<span class="type">Register</span> protocol methods
    <span class="keyword">for</span> (unsigned <span class="type">int</span> i = <span class="number">0</span>; i &lt; numberOfMethods; i++) {
        struct objc_method_description <span class="keyword">method</span> = methods[i];
        [_selToHandlerMap setValue:handler forKey:<span class="type">NSStringFromSelector</span>(<span class="keyword">method</span>.name)];
    }
}
</code></pre><h3 id="实现消息的转发">实现消息的转发</h3><p>我们已经可以注册接口、保存映射关系了，剩下的就是重写NSProxy的两个方法，以实现消息的转发，至于这两个方法具体作用是什么，读者可以自行查阅相关资料。如下：</p>
<pre><code><span class="comment">//HttpProxy.m</span>

<span class="comment">//获取Method signature</span>
- (NSMethodSignature *)<span class="string">methodSignatureForSelector:</span>(SEL)sel {

    <span class="comment">//获取method的字符串表示</span>
    NSString *methodsName = NSStringFromSelector(sel);

    <span class="comment">//查找对应实现类对象</span>
    id handler = [_selToHandlerMap <span class="string">valueForKey:</span>methodsName];

    <span class="comment">//再次检查handler是否可以相应此消息</span>
    <span class="keyword">if</span> (handler != nil &amp;&amp; [handler <span class="string">respondsToSelector:</span>sel]) {
        <span class="keyword">return</span> [handler <span class="string">methodSignatureForSelector:</span>sel];
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> [<span class="keyword">super</span> <span class="string">methodSignatureForSelector:</span>sel];
    }
}

<span class="comment">//转发方法消息</span>
- (<span class="typename">void</span>)<span class="string">forwardInvocation:</span>(NSInvocation *)invocation {
    NSString *methodsName = NSStringFromSelector(invocation.selector);
    id handler = [_selToHandlerMap <span class="string">valueForKey:</span>methodsName];

    <span class="keyword">if</span> (handler != nil &amp;&amp; [handler <span class="string">respondsToSelector:</span>invocation.selector]) {
        [invocation <span class="string">invokeWithTarget:</span>handler];
    } <span class="keyword">else</span> {
        [<span class="keyword">super</span> <span class="string">forwardInvocation:</span>invocation];
    }
}
</code></pre><h2 id="Example">Example</h2><p>看看如何使用HttpProxy：</p>
<pre><code><span class="comment">//初始化，注册Protocol对应的实现类对象</span>
<span class="attr_selector">[[HttpProxy sharedInstance]</span> <span class="tag">registerHttpProtocol</span>:@<span class="tag">protocol</span>(UserHttpHandler) <span class="tag">handler</span>:<span class="attr_selector">[UserHttpHandlerImp new]</span>];
<span class="attr_selector">[[HttpProxy sharedInstance]</span> <span class="tag">registerHttpProtocol</span>:@<span class="tag">protocol</span>(CommentHttpHandler) <span class="tag">handler</span>:<span class="attr_selector">[CommentHttpHandlerImp new]</span>];

<span class="comment">//调用</span>
<span class="attr_selector">[[HttpProxy sharedInstance]</span> <span class="tag">getUserWithID</span>:@<span class="tag">100</span>];
<span class="attr_selector">[[HttpProxy sharedInstance]</span> <span class="tag">getCommentsWithDate</span>:<span class="attr_selector">[NSDate new]</span>];
</code></pre><h2 id="总结">总结</h2><p>所有的代码及示例都提交到Github了，<a href="https://github.com/zekunyan/HttpProxyExample" target="_blank" rel="external">HttpProxyExample</a>。</p>
<p>总的来说，就是利用Objective-C的“消息”机制，继承NSProxy抽象类，实现自己定义的转发机制，将网络接口层的各个方法的实现与声明分离，提升项目代码的可维护性，更加模块化。如下图表示:</p>
<p><img src="http://zorrochen.qiniudn.com/blog_ios_http_proxy_1_3.jpg" alt="image"></p>
<p>以上，就是我自己在项目中，利用NSProxy设计并实现的网络接口层结构。💪</p>
<p>从了解NSProxy、Runtime到设计、实现出这个网络层架构，着实花了点时间，收获真是不少。其实像这种纯代码层次的重构，很多人会觉得“吃力不讨好”😨，但我觉得，正是这样，才能真正让自己提升。</p>
<p>代码是具有美感的！嗯！😝</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSProxy_Class/index.html#//apple_ref/occ/instm/NSProxy" target="_blank" rel="external">NSProxy Class Reference</a></li>
<li><a href="http://objectivetoast.com/2014/05/12/nsproxy-nsobjects-lesser-known-sibling/" target="_blank" rel="external">NSProxy, NSObject’s Lesser-Known Sibling</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html" target="_blank" rel="external">Objective-C Runtime Programming Guide</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>之前在做项目的时候，所有业务的网络接口方法，全部都写在了一个文件里面，一开始还好，毕竟每个方法的代码也只是十几行，增加、修改也比较容易。但是随着接口的增多，这个文件慢慢居然超过了1000行，里面几十个方法都写在一起，实在是不好维护。  </p>
<p>虽然保持这样也没有什么，多用用Cmd+F就能找到。但是，真是越看越不顺眼😳， 代码一定要有“美感”啊~😝</p>
<p>所以在查阅了大量文章后，终于想出了本文即将说明的办法，越发觉得Objective-C的“消息”机制是多么的赞~😚</p>
<h2 id="Github_示例">Github 示例</h2><p>贴上本文中的示例工程：<a href="https://github.com/zekunyan/HttpProxyExample">https://github.com/zekunyan/HttpProxyExample</a></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Effective-Objective-C-读书笔记-Item-3]]></title>
    <link href="http://tutuge.me/2015/02/14/Effective-Objective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Item-3/"/>
    <id>http://tutuge.me/2015/02/14/Effective-Objective-C-读书笔记-Item-3/</id>
    <published>2015-02-14T08:51:51.000Z</published>
    <updated>2015-04-06T03:14:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>item 3讲的是Objective-C里面的“字面量语法”-“Literal Syntax”，个人觉得非常有用。</p>
<h2 id="Item_3_-_Prefer_Literal_Syntax_over_the_Equivalent_Methods">Item 3 - Prefer Literal Syntax over the Equivalent Methods</h2><p>本节讲了Objective-C中的“字面量语法”，并且建议我们更多的使用这种语法，而不是使用传统的等价的函数方法。</p>
<a id="more"></a>
<h2 id="引子">引子</h2><p>当我们使用Objective-C编程的时候，总会经常使用到几种Foundation框架中的基本类，如NSString、NSNumber、NSArray、NSDictionary，或者是它们的子类。例如，当我们想创建一个字符串的时候，会这么写：</p>
<pre><code><span class="label">NSString</span> *<span class="keyword">str </span>= <span class="comment">@"a string";</span>
</code></pre><p>不知道各位写这句的时候有没有觉得奇怪？为什么不用先“alloc”，再“initWithXXX”这么来创建呢。是的，这里创建字符串，就用到了Objective-C提供的“字面量语法”-“Literal Syntax”，而这种语法的“标志”就是“@”符号。<br>有了字面量语法，我们就不用每次创建一些基本类型的时候，写一大堆alloc、init了。</p>
<h2 id="NSNumber">NSNumber</h2><p>字符串可以用字面量语法创建，数字类NSNumber肯定也可以，如下：</p>
<pre><code>NSNumber <span class="keyword">*</span>intNum = <span class="comment">@1;</span>
NSNumber <span class="keyword">*</span>floatNum = <span class="comment">@1.1f;</span>
NSNumber <span class="keyword">*</span>doubleNum = <span class="comment">@1.1;</span>
NSNumber <span class="keyword">*</span>boolNum = <span class="comment">@YES;</span>
NSNumber <span class="keyword">*</span>charNum = <span class="comment">@'a';</span>

//不用字面量语法
NSNumber <span class="keyword">*</span>intNumber = [[NSNumber alloc] initWithInt:1];
</code></pre><p>看，是不是很方便~</p>
<h2 id="NSArray">NSArray</h2><h3 id="创建">创建</h3><p>数组算是最常用的一种数据结构了，如果没有字面量语法，创建数组可能是这样：</p>
<pre><code><span class="constant">NSArray</span> *numbers = [[<span class="constant">NSArray</span> alloc] <span class="symbol">initWithObjects:</span>
    <span class="variable">@1</span>, <span class="variable">@1</span>.<span class="number">1</span>, <span class="variable">@2</span>.<span class="number">0</span>f, <span class="variable">@YES</span>, <span class="literal">nil</span>];
</code></pre><p>用字面量语法的话，就是这样：</p>
<pre><code><span class="constant">NSArray</span> *numbers = <span class="annotation">@[<span class="variable">@1</span>, <span class="variable">@1</span>.<span class="number">1</span>, <span class="variable">@2</span>.<span class="number">0</span>f, <span class="variable">@YES</span>]</span>;
</code></pre><h3 id="存取值">存取值</h3><p>创建了数组，肯定要从数组里面取值，用NSArray的方法就是这样：</p>
<pre><code><span class="comment">//取</span>
NSNumber *aNumber = [numbers objectAtIndex:<span class="number">2</span>];
<span class="comment">//存</span>
NSMutableArray *mutableArray = [[NSMutableArray alloc] initWithArray:
    @[@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>]];
[mutableArray replaceObjectAtIndex:<span class="number">1</span> withObject:@<span class="number">4</span>];
</code></pre><p>跟C语言、Java这些语法很不一样啊，人家都是通过中括号“[]”直接用下标取值就可以。有了字面量同语法，Objective-C也可以这样:</p>
<pre><code><span class="comment">//取</span>
NSNumber *aNumber = numbers[<span class="number">2</span>];
<span class="comment">//存</span>
NSMutableArray *mutableArray = [[NSMutableArray alloc] initWithArray:
    @[@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>]];
mutableArray[<span class="number">1</span>] = @<span class="number">4</span>;
</code></pre><h3 id="要注意的地方">要注意的地方</h3><p>传统的通过“initWithObjects”方法创建数组的时候，是根据最后的“nil”判断数组是否结束的，也就是说，用于初始化数组的元素中有“nil”值也不会导致异常（Exception），如下语句：</p>
<pre><code><span class="built_in">NSNumber</span> *number1 = @<span class="number">1</span>;
<span class="built_in">NSNumber</span> *number2 = <span class="literal">nil</span>; <span class="comment">//空指针</span>
<span class="built_in">NSNumber</span> *number3 = @<span class="number">3</span>;

<span class="comment">//创建</span>
<span class="built_in">NSArray</span> *numbers = [[<span class="built_in">NSArray</span> alloc] initWithObjects:
    number1, number2, number3, <span class="literal">nil</span>];

<span class="comment">//输出为1，因为number2，创建到number2就截止了</span>
<span class="built_in">NSLog</span>(<span class="string">@"numbers count: %d"</span>, numbers<span class="variable">.count</span>);
</code></pre><p>但是，如果用字面量语法创建，就是出问题：</p>
<pre><code><span class="constant">NSNumber</span> *number1 = <span class="variable">@1</span>;
<span class="constant">NSNumber</span> *number2 = <span class="literal">nil</span>;
<span class="constant">NSNumber</span> *number3 = <span class="variable">@3</span>;

<span class="regexp">//</span>创建出现异常！！！
<span class="constant">NSArray</span> *numbers = <span class="annotation">@[number1, number2, number3]</span>;

<span class="constant">NSLog</span>(@<span class="string">"numbers count: %d"</span>, numbers.count);
</code></pre><p>因为字面量语法只是单纯的将中括号中的元素全部加到数组中，但是，Objective-C中的数组是不可以存放nil值的，所以程序会运行时抛出异常。    </p>
<h2 id="NSDictionary">NSDictionary</h2><h3 id="创建-1">创建</h3><p>如果不用字面量语法创建字典，传统的创建函数简直令人匪夷所思：</p>
<pre><code><span class="comment">// number1-&gt;@1</span>
<span class="comment">// number2-&gt;@2</span>
<span class="built_in">NSDictionary</span> *dict = [[<span class="built_in">NSDictionary</span> alloc] initWithObjectsAndKeys:
    @<span class="number">1</span>, <span class="string">@"number1"</span>, @<span class="number">2</span>, <span class="string">@"number2"</span>, <span class="literal">nil</span>];
</code></pre><p>是不是很奇怪，<strong>value在前面，key在后面</strong></p>
<p>所以，还是用新的语法吧：</p>
<pre><code>NSDictionary *dict = @{@<span class="string">"number1"</span> : <span class="constant">@1</span>, @<span class="string">"number2"</span> : <span class="constant">@2</span>}<span class="comment">;</span>
</code></pre><p>这样才符合“常识”嘛，key在前，value在后面，跟JSON的定义一样。  </p>
<h3 id="存取值-1">存取值</h3><p>取值的语法跟NSArray的语法很想，只不过是将下标数字变成了key：</p>
<pre><code><span class="comment">//传统</span>
NSNumber *number1 = [dict <span class="string">objectForKey:</span>@<span class="string">"number1"</span>];
[dict <span class="string">setValue:</span>@<span class="number">5</span> <span class="string">forKey:</span>@<span class="string">"number1"</span>];

<span class="comment">//字面量语法</span>
NSNumber *number2 = dict[@<span class="string">"number1"</span>];
dict[@<span class="string">"number1"</span>] = @<span class="number">6</span>;
</code></pre><h3 id="注意">注意</h3><p>需要注意的地方，跟创建数组一样，NSDictionary的value不能为nil值，否则会抛出异常。</p>
<p>##总结<br>总的来说，使用字面量语法可以让代码更加清晰、简单，毕竟，更少的代码，有时候意味着更少的错误。      </p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>item 3讲的是Objective-C里面的“字面量语法”-“Literal Syntax”，个人觉得非常有用。</p>
<h2 id="Item_3_-_Prefer_Literal_Syntax_over_the_Equivalent_Methods">Item 3 - Prefer Literal Syntax over the Equivalent Methods</h2><p>本节讲了Objective-C中的“字面量语法”，并且建议我们更多的使用这种语法，而不是使用传统的等价的函数方法。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="笔记" scheme="http://tutuge.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="翻译" scheme="http://tutuge.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Effective-Objective-C-读书笔记-Item-2]]></title>
    <link href="http://tutuge.me/2015/02/06/Effective-Objective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Item-2/"/>
    <id>http://tutuge.me/2015/02/06/Effective-Objective-C-读书笔记-Item-2/</id>
    <published>2015-02-06T08:43:46.000Z</published>
    <updated>2015-04-06T03:14:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>第二弹来了。</p>
<h2 id="Item_2_-_Minimize_Importing_Headers_in_Headers">Item 2 - Minimize Importing Headers in Headers</h2><p>这一节讲的是尽量在一个头文件中减少其它头文件的引入。</p>
<a id="more"></a>
<h2 id="头文件">头文件</h2><p>Objective-C和C语言、C++很像，都将类的实现与声明分开，用.h后缀名文件表示声明文件，用.m文件实现类。当要用到这个类的时候，只需要引入头文件即可，至于编译器、运行时是如何知道头文件里面的类对应的实现在哪里，在这了不做说明。一下用例子说明，先看看下面的类：</p>
<pre><code><span class="comment">//Wheel.h</span>
<span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span>

<span class="comment">//车轮类</span>
<span class="class"><span class="keyword">@interface</span> <span class="title">Wheel</span> : <span class="title">NSObject</span></span>
<span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *manufacturer;
<span class="keyword">@property</span>(<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> radius;
<span class="keyword">@end</span>
</code></pre><p>第二个类 </p>
<pre><code><span class="comment">//Engine.h</span>
<span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span>

<span class="comment">//发动机类</span>
<span class="class"><span class="keyword">@interface</span> <span class="title">Engine</span> : <span class="title">NSObject</span></span>
<span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *manufacturer;
<span class="keyword">@property</span>(<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> power;
<span class="keyword">@end</span>
</code></pre><p>然后就是车类Car：</p>
<pre><code><span class="comment">//Car.h</span>
<span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span>

<span class="comment">//汽车类，只有一个轮子，不要奇怪=。=</span>
<span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span>
<span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) Wheel *wheel;
<span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) Engine *engine;
<span class="keyword">@end</span>
</code></pre><p>注意到少了什么东西没有？<br>是的，写过C语言、C++的童鞋一下就能发现，Car类没有引入Engine和Wheel的头文件，肯定会编译出错的，因为编译器不知道Engine、Wheel类是啥。<br>那好，我们加上下面两行：</p>
<pre><code><span class="id">#import</span> <span class="string">"Wheel.h"</span>
<span class="id">#import</span> <span class="string">"Engine.h"</span>
</code></pre><p>嗯。这样就不会出错了。但是这样真的好吗？Objective-C给我们提供了@class关键字，就是来解决这个问题的。</p>
<h2 id="前置声明（forward_declaration）">前置声明（forward declaration）</h2><p>何为前置声明？看看下面的Car类的头文件例子。</p>
<pre><code><span class="comment">//Car.h</span>
<span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span>

<span class="comment">//前置声明</span>
<span class="class"><span class="keyword">@class</span> <span class="title">Wheel</span>;</span>
<span class="class"><span class="keyword">@class</span> <span class="title">Engine</span>;</span>

<span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span>
<span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) Wheel *wheel;
<span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) Engine *engine;
<span class="keyword">@end</span>
</code></pre><p>@class就是类的前置声明（forward declaration），就是告诉编译器“嗨，不用找了，Wheel类和Engine类是肯定存在的，用到的时候再找”。有了前置声明，我们就不用显式的引入Wheel类和Engine类了。</p>
<p>当然，在Car类的实现文件.m文件中，我们还是要显式的引入Wheel和Engine类的，因为在这里我们要具体用到这两个类了，当然要知道类的细节。</p>
<h3 id="为何不要import？">为何不要import？</h3><p>为什么不直接import呢？因为如果直接用import引入Wheel和Engine的声明，那么任何import引入了Car类的文件，也同时会引入Wheel、Engine类的声明，而且最终我们可能并不一定会直接跟Wheel、Engine类打交道，这样不就引入了“没有用”的类了吗？而且这样做很可能造成文件引入成“环”。 </p>
<p>虽然import可以避免重复声明造成编译出错，传统的C语言、C++在声明的时候也可以通过如下方式避免重复声明：</p>
<pre><code><span class="id">#ifndef</span> _WHEEL_H_
<span class="hexcolor">#def</span>ine _WHEEL_H_

<span class="comment">//声明内容...</span>

#endif
</code></pre><p>但是既然Objective-C有@class这种前置声明的办法，为何不用呢。</p>
<h2 id="必须用import的时候">必须用import的时候</h2><p>当然，@class这样的前置声明并不能解决一切头文件引入的问题，如下这样的类，就必须要用import：</p>
<pre><code><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span>

<span class="comment">//Car 的声明</span>
<span class="preprocessor">#import <span class="title">"Car.h"</span></span>

<span class="comment">//Driver protocol的定义</span>
<span class="preprocessor">#import <span class="title">"Driver.h"</span></span>

<span class="class"><span class="keyword">@interface</span> <span class="title">BigCar</span> : <span class="title">Car</span> &lt;<span class="title">Driver</span>&gt;</span>
<span class="keyword">@end</span>
</code></pre><p>是的，当类需要被继承、定义的protocol需要实现的时候，就需要import相关的头文件了（protocol的实现如果跟类的使用者没有关联，可以定义在类的实现文件中的“扩展category”中）,当然，还有@protocol这样的protocol的前置声明，怎么用就留给读者自己查阅相关资料了。</p>
<h2 id="总结">总结</h2><p>大费周章的讲了这么多，其实目的就是一个：尽量少在头文件里面引入其他头文件。</p>
<p>最终的目的就是<strong>只暴露最少的细节</strong>。</p>
<p>写代码有段时间了，一直都在琢磨这句话，希望读者也能好好体会~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>第二弹来了。</p>
<h2 id="Item_2_-_Minimize_Importing_Headers_in_Headers">Item 2 - Minimize Importing Headers in Headers</h2><p>这一节讲的是尽量在一个头文件中减少其它头文件的引入。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="笔记" scheme="http://tutuge.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="翻译" scheme="http://tutuge.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Effective-Objective-C-读书笔记-Item-1]]></title>
    <link href="http://tutuge.me/2015/02/05/Effective-Objective-C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Item-1/"/>
    <id>http://tutuge.me/2015/02/05/Effective-Objective-C-读书笔记-Item-1/</id>
    <published>2015-02-04T17:17:08.000Z</published>
    <updated>2015-04-06T03:14:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>一直都在做项目，没什么时间作总结，感觉很不是滋味。现在放假了，嗯，终于有时间了~~哈哈（天生程序猿一枚好不好=。=）<br>最近开始读英文版的Effective Objective-C 2.0，觉得不错，就总结些东西，分享给各位读者吧。</p>
<h2 id="Item_1_-_Familiarize_Yourself_with_Objective-C’s_Roots">Item 1 - Familiarize Yourself with Objective-C’s Roots</h2><p>第一章的目的，就是让大家熟悉Objective-C，自然，标题的意思也就是“了解Objective-C的基本概念”，不多说，开写。</p>
<a id="more"></a>
<h2 id="消息与运行时">消息与运行时</h2><p>总的来说，Objective-C跟C++、Java这些面向对象的语言是非常相似的，但是还是有许多不同的地方。如果你是第一次看到Objective-C的语法，一定觉得非常奇怪，因为Objective-C使用的是基于消息（Message）的框架，而不是传统的方法、函数调用。如下：</p>
<pre><code><span class="comment">//Objective-C</span>
Person *person = [Person <span class="keyword">new</span>];
[person setName:@<span class="string">"tutuge"</span> age:<span class="number">24</span>];

<span class="comment">//Java</span>
Person person = <span class="keyword">new</span> Person();
person.setNameAndAge(<span class="string">"tutuge"</span>, <span class="number">24</span>);

<span class="comment">//C++</span>
Person *person = <span class="keyword">new</span> Person;
person-&gt;setNameAndAge(<span class="string">"tutuge"</span>, <span class="number">24</span>);
</code></pre><p>很奇怪是不是，各种中括号。但是我觉得，Objective—C这么设计就是为了时刻提醒你，“我是基于消息机制的！”。消息，的确是Objective-C与Java、C++这种语言最大的不同，而且，这种不同远不止在语法上面。简单来说如下两点：</p>
<ul>
<li><strong>基于消息的调用：</strong> 所有的函数调用都是在“运行时”决定的。</li>
<li><strong>基于方法的调用：</strong> 所有的函数调用都是在“编译时”决定的，就是编译器编译时决定的。</li>
</ul>
<p>其实，连被调方法的对象类型，都是在运行时决定的。所以说，Objective-C的运行时系统，担负了绝大部分的工作。这么设计的优点，举个例子，就是当运行时系统升级时，原有的代码不用重新编译即可“享受”升级带来的好处。</p>
<h2 id="C的超集">C的超集</h2><p>Objective-C是C语言的超集，所以C语言所具有的一切特性，Objective-C都可以兼容，充分理解C语言的内存模型，对理解Objective-C很有帮助。如下：</p>
<pre><code><span class="label">NSString</span> *<span class="keyword">str </span>= <span class="comment">@"a string";</span>
</code></pre><p>这一行代码跟C语言没有什么不同，（忽略@符号=。=），原理跟C语言也是一致的，就是str指针是NSString类型的指针，指向了一块存着字符串“a string”的内存区域。不同的是，在Objective-C里，所有的对象只可以声明为指针类型，所以如下代码是不合理的：</p>
<pre><code>NSString <span class="keyword">str</span>;
</code></pre><p>为了更充分的理解，咱们看看如下例子：</p>
<pre><code><span class="label">NSString</span> *<span class="keyword">str1 </span>= <span class="comment">@"a string";</span>
<span class="label">NSString</span> *<span class="keyword">str2 </span>= <span class="keyword">str1;</span>
</code></pre><p>熟悉C语言的朋友应该知道这是怎么回事，内存当中只有一块区域储存着“a string”这个字符串，str1、str2都是指向着这个区域的字符串指针。如下图：</p>
<p><img src="http://zorrochen.qiniudn.com/blog_effective_objective_c_item_1_1.jpg" alt="image"></p>
<ul>
<li>str1、str2都在栈内存上分配的，就是字符串（NSString）类型的指针。</li>
<li>“a string”字符串实际储存在堆内存上。</li>
<li>str1、str2均指向同一块内存区域。</li>
</ul>
<p>此处的栈内存、堆内存跟C语言中的概念也是一样的，不同的是，在Objective-C中，我们不用手动去malloc、free内存，Objective-C使用内存计数计数帮我们管理内存。</p>
<h2 id="结构体，基本类型">结构体，基本类型</h2><p>在Objective-C中，并不是所有的变量都是指针类型的，像int、float、double这些依旧是传统的“栈上分配”的，当然，还有结构体struct、枚举enum、联合union等。如：</p>
<pre><code>CGPoint point = CGPointMake(<span class="number">10</span>, <span class="number">10</span>);
CGRect frame = CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">10</span>);
</code></pre><p>这的CGPoint、CGRect都是结构体，但是都是直接在栈上分配内存的，以减少过度使用Objective-C类型的类（减少运行时的压力），各位读者使用的时候要注意。</p>
<h2 id="总结">总结</h2><p>零散的说了一些Objective-C的特点，远远不足以讲明白Objective-C，我这只是根据Effective Objective-C这本书给个引子，还是推荐Apple的官方教程、文档，要想掌握扎实，还是要一步一步来~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>一直都在做项目，没什么时间作总结，感觉很不是滋味。现在放假了，嗯，终于有时间了~~哈哈（天生程序猿一枚好不好=。=）<br>最近开始读英文版的Effective Objective-C 2.0，觉得不错，就总结些东西，分享给各位读者吧。</p>
<h2 id="Item_1_-_Familiarize_Yourself_with_Objective-C’s_Roots">Item 1 - Familiarize Yourself with Objective-C’s Roots</h2><p>第一章的目的，就是让大家熟悉Objective-C，自然，标题的意思也就是“了解Objective-C的基本概念”，不多说，开写。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="笔记" scheme="http://tutuge.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="翻译" scheme="http://tutuge.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS项目的目录结构-原创]]></title>
    <link href="http://tutuge.me/2015/02/01/iOS%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84-%E5%8E%9F%E5%88%9B/"/>
    <id>http://tutuge.me/2015/02/01/iOS项目的目录结构-原创/</id>
    <published>2015-01-31T18:27:21.000Z</published>
    <updated>2015-04-06T03:14:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>这段时间一直在做iOS的项目（<a href="https://itunes.apple.com/cn/app/qing-ju-yin-le-quan-guo-zui/id913235479?mt=8" target="_blank" rel="external">青桔音乐App</a>），随着代码量的上升，逐渐意识到项目的整体目录结构划分是多么重要，清晰的目录结构，能够更好的应对新的需求，更容易重构。虽然一直都是一个人在做=。=，但是还是深深地体会到目录结构的重要性。</p>
<a id="more"></a>
<h2 id="例子">例子</h2><p>说再多都不如来个例子实在，如下：(VC指的是viewController)</p>
<pre><code><span class="string">|---General</span>
    <span class="string">|---AppDelegate</span>
    <span class="string">|---Application</span>
    <span class="string">|---Constant</span>
    <span class="string">|---UI</span>
        <span class="string">|---View</span>
        <span class="string">|---VC</span>
        <span class="string">|---Common</span>
    ...
<span class="string">|---Entity</span>
    <span class="string">|---BaseEntity</span>
    ...
<span class="string">|---Http</span>
    <span class="string">|---Api</span>
    <span class="string">|---Util</span>
    <span class="string">|---CodeHandler</span>
    <span class="string">|---ErrorHandler</span>
    <span class="string">|---RequestHandler</span>
    ...
<span class="string">|---DB</span>
    <span class="string">|---DBHelper</span>
    <span class="string">|---DBService</span>
    ...
<span class="string">|---Util</span>
    <span class="string">|---StringUtil</span>
    <span class="string">|---NumberUtil</span>
    <span class="string">|---TimeUtil</span>
    ...
<span class="string">|---Service</span>
    <span class="string">|---AccountService</span>
    <span class="string">|---ShareService</span>
    ...
<span class="string">|---Lib</span>
    <span class="string">|---Umeng</span>
    <span class="string">|---QQSDK</span>
    <span class="string">|---SVProgressHUD</span>
    ...
<span class="string">|---Module</span>
    <span class="string">|---Login</span>
        <span class="string">|---View</span>
        <span class="string">|---VC</span>
        ...
    <span class="string">|---Comment</span>
    <span class="string">|---Feeds</span>
    ...
</code></pre><p>乍一看好多，别被吓到=。=，容我细细讲解。</p>
<h2 id="详细讲解">详细讲解</h2><h3 id="General">General</h3><p>General好理解，放的就是如AppDelegate之类的、项目中最普通的、最常用的组件。</p>
<p><strong>AppDelegate</strong>:<br>App的Delegate类实现，这个必须有，就不用说了吧。  </p>
<p><strong>Application</strong>:<br>如果自定义实现了Application类，就放在这里。  </p>
<p><strong>Constant</strong>:<br>顾名思义，常量，项目用到的所有公共常量，如enum枚举类型的、Notification的Tag，常用的颜色、字符串等等等，都可以按照自己的需求划分不同的Group，放到Constant里面。  </p>
<p><strong>UI</strong>:<br>项目中自定义的UIView、UIViewController子类，和自定义的对UI的扩展，如Category之类的代码，就对应放在UI下的View、VC和Common中。</p>
<p>如还有其他的通用组件，也不妨放到这里，做统一的管理。</p>
<hr>
<h3 id="Entity">Entity</h3><p>Entity，也有人喜欢叫Model（关于Entity和Model的区别，推荐看看<a href="http://blogsh.de/2011/09/08/models-vs-entities/" target="_blank" rel="external">这篇文章</a>，个人觉得研究研究Entity和Model概念的区别还是很有好处的），就是程序中的“实体”，如一个用户、一条评论、一首歌等等，简单来说就是一个独立“个体”的集合、打包，具体的自己查查吧，网上一大堆的，感觉跟JavaBean的概念比较像。</p>
<p>通常来说，每个Entity类都比较简单，只包含若干个属性。但是有时候可能要做统一的处理，如，在从服务器取回的JSON数据解包成具体的Entity类，并且执行一系列初始化操作等等，所以可能要对所有的Entity类做统一处理。所以说，可以定制相应的BaseEntity基类，利用模板方法等办法，定制统一的初始化流程（好像扯远了=。=，这个后面会详细写篇东西分享给大家），BaseEntity就是放这些基类的东西的。</p>
<hr>
<h3 id="Http">Http</h3><p>这个Group里面放跟网络请求相关的东西，详细如下：</p>
<p><strong>Api</strong>:<br>互联网应用少不了跟服务器打交道的各种网络接口，所以我在项目中把所有的API对应的相对URL地址、参数注释要求等等都放在了这里，好统一管理。</p>
<p><strong>Util</strong>:<br>定义最基本的网络请求，如GET、POST、PUT等请求的基本封装，获取图片的基本封装。<br>一般来说就是定制统一的基本请求接口，对上层提供一致、稳定的服务，真正的网络请求，可以自己用iOS原生的Api写，也可以用AFNetworking等第三方库做封装，图片也可以灵活的用AFNetworking、SDWebImage这些优秀的库实现。还有就是，可以方便的统一对请求做处理，如错误处理、Http的Code、状态处理等等。还可以统一的增加请求参数，如统一为每个请求都增加用户的ID、token什么的。</p>
<p><strong>CodeHandler</strong><br>大部分的API设计都会有相应的状态码、Code，为了方便扩展，可以把这些处理Code的类单独放在这里。</p>
<p><strong>ErrorHandler</strong><br>这个就少不了了，对Http的错误进行单独处理，加Log什么的。</p>
<p><strong>RequestHandler</strong><br>这个Group里面放的是真正实现接口的类，如什么UserHttpHandler、CommentHttpHandler之类的，就是具体实现了接口调用、处理返回数据、回调的类。</p>
<p>Http里面的各个Group的类其实都是相互关联的，设计的时候可以定制统一的接口（Protocol），然后创建类实现（conform）这些接口，也就是面向接口的编程，以最大限度的减少接口层的各个职能之间的耦合，方便扩展。</p>
<hr>
<h3 id="DB">DB</h3><p>介于iOS的SQLite不是那么好用，所以非常有必要为操作数据库的类建立单独的地盘=。=  </p>
<p><strong>DBHelper</strong>:<br>放基础的操作数据库的类，如简单的查找、插入、更新、事务更新等等操作，为负载的数据库业务逻辑封装底层接口。比如对流行的FMDB进行封装等等。</p>
<p><strong>DBService</strong>:<br>这里放具体的数据库业务实现类，至于为什么叫“Service”，因为我也想不出什么好的名字了=。= 按照自己的业务逻辑组织即可。</p>
<hr>
<h3 id="Util">Util</h3><p>放常用的工具类的地方。如字符串操作的类StringUtil、时间计算格式化类TimeUtil等，按具体需求而定，这个就不用多说了吧。</p>
<hr>
<h3 id="Service">Service</h3><p>项目的需求多了，业务逻辑的代码就会越来越多，总不能都放在view controller里面吧。一些多处用到的，或者非常独立的业务代码，完全可以抽离出来，实现为单独的、跟界面无关的业务类。因为做的事很杂，所以干脆就叫Service了。<br><strong>AccountService</strong>、<strong>ShareService</strong>就是这种类。而且大部分的Service都应该是单例类，如<strong>AccountService</strong>类可能维护着程序运行期间的账户信息，<strong>ShareService</strong>对程序的分享功能做了统一处理等等，具体怎么用就随各位了。</p>
<hr>
<h3 id="Lib">Lib</h3><p>Lib，放各种第三方库，因项目需要修改过的第三方组件等，像什么友盟、QQSDK之类的就可以放这。当然，一些不会做改动的库最好还是用CocoaoPod做统一管理。</p>
<hr>
<h3 id="Module">Module</h3><p>终于讲到了最重要的地方。<br>iOS工程中最多的文件往往就是各种View、ViewController类，以前总是看到有人只创建两个Group，一个叫Views，另一个叫ViewControllers，然后所有的Views、ViewController都往里面塞，然后随着需求的增加，这两个Group也臃肿不堪。。。  </p>
<p><strong>办法总是有的。就是为工程划分模块-Module</strong><br>如何划分Module？我认为，可以按照以下两点建立：  </p>
<ol>
<li>以页面跳转分支划分。  </li>
<li>以功能划分。  </li>
</ol>
<p><strong>以页面跳转分支划分</strong><br>就是按照应用的页面设计与业务逻辑，从最顶级开始，一级一级页面往下跳转，找出其中的独立分支，归为一个Module模块。<br>举例来说，应用主界面有4个Tab页，就先分出四个Module，然后一级一级往下跳转，遇到分支就建立新的Module，如此递归的建立，就能大致划分出各个Module。当然，这么做是最粗糙的，还要根据情况，将不同的分支Module合并成一个Module，简化代码的组成。我在这只是提供个划分Module的方法，具体怎么设计就看各位读者了=。=</p>
<p><strong>以功能划分</strong><br>这个好理解，无非就是根据前期项目的功能模块划分工程的代码Module组成。如什么用户设置Module、评论Module、登录Module等等。</p>
<p>总的来数，就是要用Module将工程的代码分类管理，每个Module具有大致相同的结构，如都可能有本Module用到的View、ViewController，自定义的类Class等等，就是说，按照职能对代码划分，避免将所有的类都堆在一起，也好应对新的需求。</p>
<h2 id="总结">总结</h2><p>啰啰嗦嗦说了一大堆，想必各位都看烦了吧=。=刚开始写博客，写到一个地方，又会引出另一块，写着写着容易写偏了。<br>写之前我也大致搜了一下，发现网上相关的资料好少，但是实际的经验告诉我，项目工程的目录结构非常重要，无论是对开发还是对后期的维护，所以想着应该写篇东西，分享我自己的经验给大家，有啥问题，多提意见啊~~~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>这段时间一直在做iOS的项目（<a href="https://itunes.apple.com/cn/app/qing-ju-yin-le-quan-guo-zui/id913235479?mt=8">青桔音乐App</a>），随着代码量的上升，逐渐意识到项目的整体目录结构划分是多么重要，清晰的目录结构，能够更好的应对新的需求，更容易重构。虽然一直都是一个人在做=。=，但是还是深深地体会到目录结构的重要性。</p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://tutuge.me/tags/iOS/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android开源库-LinkTextView-原创]]></title>
    <link href="http://tutuge.me/2014/11/02/LinkTextView-Android%E5%BC%80%E6%BA%90%E5%BA%93-%E5%8E%9F%E5%88%9B/"/>
    <id>http://tutuge.me/2014/11/02/LinkTextView-Android开源库-原创/</id>
    <published>2014-11-01T18:34:46.000Z</published>
    <updated>2015-09-24T10:59:54.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>近来因为项目的缘故，仔细研究了一下如何在Android的TextView里面绑定可以点击的链接，并且定制链接的颜色，包括正常状态、按下去时的文字、背景的颜色，当然，还有点击后的回调。</p>
<p>为了以后方便自己，也为了方便更多的人，就把这些封装成了一个简单的开源库，也算是我自己的<strong><em>第一个开源库</em></strong>吧。</p>
<h2 id="LinkTextView">LinkTextView</h2><p>名称：<a href="https://github.com/zekunyan/LinkTextView" target="_blank" rel="external">LinkTextView</a>。喜欢的话就Star一下吧。</p>
<h3 id="Example">Example</h3><p><img src="http://zorrochen.qiniudn.com/LinkTextView_Sample.gif" alt="示例"></p>
<a id="more"></a>
<h3 id="功能：">功能：<br></h3><ol>
<li>可以方便的对TextView里面的文字增加可点击链接，并且绑定回调。</li>
<li>可以为每个链接<strong>单独</strong>设置<strong>文字</strong>、链接<strong>背景</strong>的<strong>正常</strong>、<strong>按下</strong>状态下的颜色。</li>
<li>可以为每个链接绑定任意类型的“附件”对象，作为点击链接时的回调参数。</li>
</ol>
<h2 id="讲解">讲解</h2><p>下面分重点讲解一下。</p>
<h3 id="1-_为文字增加可点击链接，绑定回调。">1. 为文字增加可点击链接，绑定回调。</h3><p>为文字增加链接，已经是老生常谈了，真是一搜一大把，不过在这里还是简单讲一下。</p>
<p>用过TextView应该都知道这个接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setText</span> <span class="params">(CharSequence text)</span></span></span><br></pre></td></tr></table></figure></p>
<p>其中CharSequence接口的子接口里面有Spannable，而由这个接口派生出来的类SpannableString，就是我们可以对TextView里面的文字做附加效果的原因。如改变颜色、增加超链接等，有兴趣的各位可以去仔细查查。下面简单的说说怎么加可点击的链接。</p>
<p><strong>首先创建SpannableString</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpannableString text = <span class="keyword">new</span> SpannableString(<span class="string">"LinkTextView dadada"</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>绑定ClickableSpan回调</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ClickableSpan clickableSpan = <span class="keyword">new</span> ClickableSpan() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//点击了链接，做你想干的事吧=。=</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">text.setSpan(clickableSpan, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>最后再setText</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textView.setText(text);</span><br></pre></td></tr></table></figure></p>
<p>看，绑定可以点击的链接就是这么简单。</p>
<h3 id="2-_改变正常、按下时的文字、链接背景颜色。">2. 改变正常、按下时的文字、链接背景颜色。</h3><p>往往系统默认的链接颜色是不能满足我们的需求的，所以最好能对链接的文字、背景的按下、松开时的颜色做定制。</p>
<p><strong><em>但是好坑=。=，Google居然没有为ClickableSpan增加按下时的回调</em></strong></p>
<p>那就只好自己造轮子了。</p>
<h4 id="首先">首先</h4><p>必须要能获取到链接按下时的回调，应该是onTouch什么的，于是，就查到了类：LinkMovementMethod。<br>在TextView中可以用方法：public final void setMovementMethod (MovementMethod movement)设定监听，而LinkMovementMethod类里面就可以监听到链接的onTouch！</p>
<p><strong>LinkMovementMethod的onTouch就是介个样子的</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span>	 <span class="title">onTouchEvent</span><span class="params">(TextView textView, Spannable spannable, MotionEvent event)</span></span></span><br></pre></td></tr></table></figure></p>
<p>于是，我们可以通过event来判断是按下还是移动等等操作。<br>但是问题是，这里的spannable是整个TextView全部的文字，所以，只能通过event里面的x、y坐标，找到具体点击的是哪个链接。这里，要感谢stack overflow上的大神的<a href="http://stackoverflow.com/questions/20856105/change-the-text-color-of-a-clickablespan-when-pressed" target="_blank" rel="external">帖子</a>。</p>
<p>具体的找点击链接的方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TouchableSpan <span class="title">getPressedSpan</span><span class="params">(TextView textView, Spannable spannable, MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取点击的x、y坐标</span></span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">    <span class="comment">//减去Padding</span></span><br><span class="line">    x -= textView.getTotalPaddingLeft();</span><br><span class="line">    y -= textView.getTotalPaddingTop();</span><br><span class="line">    <span class="comment">//加上滚动的偏移</span></span><br><span class="line">    x += textView.getScrollX();</span><br><span class="line">    y += textView.getScrollY();</span><br><span class="line">    <span class="comment">//获取第几行、以及偏移</span></span><br><span class="line">    Layout layout = textView.getLayout();</span><br><span class="line">    <span class="keyword">int</span> line = layout.getLineForVertical(y);</span><br><span class="line">    <span class="keyword">int</span> off = layout.getOffsetForHorizontal(line, x);</span><br><span class="line">    <span class="comment">//获取真正点击的链接</span></span><br><span class="line">    TouchableSpan[] link = spannable.getSpans(off, off, TouchableSpan.class);</span><br><span class="line">    TouchableSpan touchedSpan = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (link.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        touchedSpan = link[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> touchedSpan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到此，我们已经能获取到链接的点击状态，并且捕捉到具体点击的ClickableSpan。</p>
<h4 id="接着">接着</h4><p>就是改变链接的文字、背景颜色。</p>
<p>ClickableSpan的方法里面，除了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View widget)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>还有就是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDrawState</span><span class="params">(TextPaint textPaint)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>很明显，就是更新文字渲染效果的。我们用如下两个方法，就能实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span> <span class="params">(<span class="keyword">int</span> color)</span></span>;</span><br><span class="line">bgColor属性</span><br></pre></td></tr></table></figure></p>
<h4 id="最后">最后</h4><p>到目前为止，我们已经可以捕捉到链接的点击状态，能获取到真正的点击的链接，还有能刷新链接的颜色了，相信聪明的你一定能自己琢磨出来，怎么样实现文章开头的效果。=v=</p>
<h4 id="本文参考">本文参考</h4><ol>
<li>Android官方文档。</li>
<li>StackOverFlow的：<a href="http://stackoverflow.com/questions/20856105/change-the-text-color-of-a-clickablespan-when-pressed" target="_blank" rel="external">Change the text color of a ClickableSpan when pressed。</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>近来因为项目的缘故，仔细研究了一下如何在Android的TextView里面绑定可以点击的链接，并且定制链接的颜色，包括正常状态、按下去时的文字、背景的颜色，当然，还有点击后的回调。</p>
<p>为了以后方便自己，也为了方便更多的人，就把这些封装成了一个简单的开源库，也算是我自己的<strong><em>第一个开源库</em></strong>吧。</p>
<h2 id="LinkTextView">LinkTextView</h2><p>名称：<a href="https://github.com/zekunyan/LinkTextView">LinkTextView</a>。喜欢的话就Star一下吧。</p>
<h3 id="Example">Example</h3><p><img src="http://zorrochen.qiniudn.com/LinkTextView_Sample.gif" alt="示例"></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://tutuge.me/tags/Android/"/>
    
      <category term="原创" scheme="http://tutuge.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="开源" scheme="http://tutuge.me/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第一篇Blog]]></title>
    <link href="http://tutuge.me/2014/11/01/%E7%AC%AC%E4%B8%80%E7%AF%87Blog/"/>
    <id>http://tutuge.me/2014/11/01/第一篇Blog/</id>
    <published>2014-10-31T16:13:15.000Z</published>
    <updated>2015-04-06T03:12:41.000Z</updated>
    <content type="html"><![CDATA[<p>拖了很久，终于开始写博客了。<br>一直觉得自己的知识储备不够，一直都在学习，一直都在积累。（其实就是懒好吗=。=）</p>
<p>说点啥呢，想到啥就说啥吧~</p>
<a id="more"></a>
<p>从小就喜欢模型、乐高积木，喜欢拆东西，印象最深的就是把家里的高级录音机拆了，装不回去，塞到了床底下。。。</p>
<p>上了学之后，又开始捣鼓四驱车，自己做马达，绕线圈，家里零件一大堆，串联一堆电池，组装遥控车，唯一的遗憾，就是没有做成遥控飞机（没钱=、=）。</p>
<p>接着，家里有了电脑！！！这要感谢老爹，当时花了一万多，液晶显示器，刚上市的奔腾4啊！</p>
<p>于是，我又开始拆电脑。。。换显卡、超频，跑分，再超频，再跑分，3DMark就是俺的祖宗啊~</p>
<p>终于，走上了<strong>编程</strong>这条“<strong>不归路</strong>”，义无反顾，一直到了现在。</p>
<p>用Dev-C++折腾C语言，数据结构、算法，接着又是C++，Window API，QT（这个真觉得不错），MFC（软件课设），Java，Python，Android（上线了几个小应用，拿了Google全国大学生Android应用开发大赛华中地区三等奖），iOS（上线应用，青桔音乐），Linux，还有各种MySQL、MongoDB等数据库的纠结，看各种博客。。。</p>
<p>每天看的很多，想的也不少，但是终究不够精通，路还很长啊~</p>
<p>当然，最感谢的就是我的女朋友~陈因素~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>拖了很久，终于开始写博客了。<br>一直觉得自己的知识储备不够，一直都在学习，一直都在积累。（其实就是懒好吗=。=）</p>
<p>说点啥呢，想到啥就说啥吧~</p>]]>
    
    </summary>
    
      <category term="杂烩" scheme="http://tutuge.me/tags/%E6%9D%82%E7%83%A9/"/>
    
  </entry>
  
</feed>
